
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model CardRequest
 * 
 */
export type CardRequest = $Result.DefaultSelection<Prisma.$CardRequestPayload>
/**
 * Model Holding
 * 
 */
export type Holding = $Result.DefaultSelection<Prisma.$HoldingPayload>
/**
 * Model RolloverRequest
 * 
 */
export type RolloverRequest = $Result.DefaultSelection<Prisma.$RolloverRequestPayload>
/**
 * Model RolloverFile
 * 
 */
export type RolloverFile = $Result.DefaultSelection<Prisma.$RolloverFilePayload>
/**
 * Model Withdrawal
 * 
 */
export type Withdrawal = $Result.DefaultSelection<Prisma.$WithdrawalPayload>
/**
 * Model Deposit
 * 
 */
export type Deposit = $Result.DefaultSelection<Prisma.$DepositPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model SupportMessage
 * 
 */
export type SupportMessage = $Result.DefaultSelection<Prisma.$SupportMessagePayload>
/**
 * Model AdminAudit
 * 
 */
export type AdminAudit = $Result.DefaultSelection<Prisma.$AdminAuditPayload>
/**
 * Model KycSubmission
 * 
 */
export type KycSubmission = $Result.DefaultSelection<Prisma.$KycSubmissionPayload>
/**
 * Model KycFile
 * 
 */
export type KycFile = $Result.DefaultSelection<Prisma.$KycFilePayload>
/**
 * Model WalletSync
 * 
 */
export type WalletSync = $Result.DefaultSelection<Prisma.$WalletSyncPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const KycStatus: {
  NOT_VERIFIED: 'NOT_VERIFIED',
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type KycStatus = (typeof KycStatus)[keyof typeof KycStatus]


export const TxType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAWAL: 'WITHDRAWAL',
  TRANSFER: 'TRANSFER'
};

export type TxType = (typeof TxType)[keyof typeof TxType]


export const TxStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  FAILED: 'FAILED'
};

export type TxStatus = (typeof TxStatus)[keyof typeof TxStatus]


export const RolloverStatus: {
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type RolloverStatus = (typeof RolloverStatus)[keyof typeof RolloverStatus]


export const WithdrawalStatus: {
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type WithdrawalStatus = (typeof WithdrawalStatus)[keyof typeof WithdrawalStatus]


export const ReviewStatus: {
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus]


export const SupportPriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type SupportPriority = (typeof SupportPriority)[keyof typeof SupportPriority]


export const SupportStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type SupportStatus = (typeof SupportStatus)[keyof typeof SupportStatus]


export const AdminAction: {
  USER_UPDATE: 'USER_UPDATE',
  USER_DELETE: 'USER_DELETE',
  USER_FUND: 'USER_FUND',
  USER_WIPE_BALANCES: 'USER_WIPE_BALANCES',
  WITHDRAWAL_STATUS_CHANGE: 'WITHDRAWAL_STATUS_CHANGE',
  DEPOSIT_STATUS_CHANGE: 'DEPOSIT_STATUS_CHANGE'
};

export type AdminAction = (typeof AdminAction)[keyof typeof AdminAction]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type KycStatus = $Enums.KycStatus

export const KycStatus: typeof $Enums.KycStatus

export type TxType = $Enums.TxType

export const TxType: typeof $Enums.TxType

export type TxStatus = $Enums.TxStatus

export const TxStatus: typeof $Enums.TxStatus

export type RolloverStatus = $Enums.RolloverStatus

export const RolloverStatus: typeof $Enums.RolloverStatus

export type WithdrawalStatus = $Enums.WithdrawalStatus

export const WithdrawalStatus: typeof $Enums.WithdrawalStatus

export type ReviewStatus = $Enums.ReviewStatus

export const ReviewStatus: typeof $Enums.ReviewStatus

export type SupportPriority = $Enums.SupportPriority

export const SupportPriority: typeof $Enums.SupportPriority

export type SupportStatus = $Enums.SupportStatus

export const SupportStatus: typeof $Enums.SupportStatus

export type AdminAction = $Enums.AdminAction

export const AdminAction: typeof $Enums.AdminAction

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.cardRequest`: Exposes CRUD operations for the **CardRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardRequests
    * const cardRequests = await prisma.cardRequest.findMany()
    * ```
    */
  get cardRequest(): Prisma.CardRequestDelegate<ExtArgs>;

  /**
   * `prisma.holding`: Exposes CRUD operations for the **Holding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holdings
    * const holdings = await prisma.holding.findMany()
    * ```
    */
  get holding(): Prisma.HoldingDelegate<ExtArgs>;

  /**
   * `prisma.rolloverRequest`: Exposes CRUD operations for the **RolloverRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolloverRequests
    * const rolloverRequests = await prisma.rolloverRequest.findMany()
    * ```
    */
  get rolloverRequest(): Prisma.RolloverRequestDelegate<ExtArgs>;

  /**
   * `prisma.rolloverFile`: Exposes CRUD operations for the **RolloverFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolloverFiles
    * const rolloverFiles = await prisma.rolloverFile.findMany()
    * ```
    */
  get rolloverFile(): Prisma.RolloverFileDelegate<ExtArgs>;

  /**
   * `prisma.withdrawal`: Exposes CRUD operations for the **Withdrawal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdrawals
    * const withdrawals = await prisma.withdrawal.findMany()
    * ```
    */
  get withdrawal(): Prisma.WithdrawalDelegate<ExtArgs>;

  /**
   * `prisma.deposit`: Exposes CRUD operations for the **Deposit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deposits
    * const deposits = await prisma.deposit.findMany()
    * ```
    */
  get deposit(): Prisma.DepositDelegate<ExtArgs>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs>;

  /**
   * `prisma.supportMessage`: Exposes CRUD operations for the **SupportMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportMessages
    * const supportMessages = await prisma.supportMessage.findMany()
    * ```
    */
  get supportMessage(): Prisma.SupportMessageDelegate<ExtArgs>;

  /**
   * `prisma.adminAudit`: Exposes CRUD operations for the **AdminAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAudits
    * const adminAudits = await prisma.adminAudit.findMany()
    * ```
    */
  get adminAudit(): Prisma.AdminAuditDelegate<ExtArgs>;

  /**
   * `prisma.kycSubmission`: Exposes CRUD operations for the **KycSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KycSubmissions
    * const kycSubmissions = await prisma.kycSubmission.findMany()
    * ```
    */
  get kycSubmission(): Prisma.KycSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.kycFile`: Exposes CRUD operations for the **KycFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KycFiles
    * const kycFiles = await prisma.kycFile.findMany()
    * ```
    */
  get kycFile(): Prisma.KycFileDelegate<ExtArgs>;

  /**
   * `prisma.walletSync`: Exposes CRUD operations for the **WalletSync** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletSyncs
    * const walletSyncs = await prisma.walletSync.findMany()
    * ```
    */
  get walletSync(): Prisma.WalletSyncDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    Transaction: 'Transaction',
    CardRequest: 'CardRequest',
    Holding: 'Holding',
    RolloverRequest: 'RolloverRequest',
    RolloverFile: 'RolloverFile',
    Withdrawal: 'Withdrawal',
    Deposit: 'Deposit',
    SupportTicket: 'SupportTicket',
    SupportMessage: 'SupportMessage',
    AdminAudit: 'AdminAudit',
    KycSubmission: 'KycSubmission',
    KycFile: 'KycFile',
    WalletSync: 'WalletSync'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "project" | "transaction" | "cardRequest" | "holding" | "rolloverRequest" | "rolloverFile" | "withdrawal" | "deposit" | "supportTicket" | "supportMessage" | "adminAudit" | "kycSubmission" | "kycFile" | "walletSync"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      CardRequest: {
        payload: Prisma.$CardRequestPayload<ExtArgs>
        fields: Prisma.CardRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          findFirst: {
            args: Prisma.CardRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          findMany: {
            args: Prisma.CardRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>[]
          }
          create: {
            args: Prisma.CardRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          createMany: {
            args: Prisma.CardRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>[]
          }
          delete: {
            args: Prisma.CardRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          update: {
            args: Prisma.CardRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          deleteMany: {
            args: Prisma.CardRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardRequestPayload>
          }
          aggregate: {
            args: Prisma.CardRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardRequest>
          }
          groupBy: {
            args: Prisma.CardRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CardRequestCountAggregateOutputType> | number
          }
        }
      }
      Holding: {
        payload: Prisma.$HoldingPayload<ExtArgs>
        fields: Prisma.HoldingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HoldingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HoldingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload>
          }
          findFirst: {
            args: Prisma.HoldingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HoldingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload>
          }
          findMany: {
            args: Prisma.HoldingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload>[]
          }
          create: {
            args: Prisma.HoldingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload>
          }
          createMany: {
            args: Prisma.HoldingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HoldingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload>[]
          }
          delete: {
            args: Prisma.HoldingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload>
          }
          update: {
            args: Prisma.HoldingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload>
          }
          deleteMany: {
            args: Prisma.HoldingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HoldingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HoldingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoldingPayload>
          }
          aggregate: {
            args: Prisma.HoldingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHolding>
          }
          groupBy: {
            args: Prisma.HoldingGroupByArgs<ExtArgs>
            result: $Utils.Optional<HoldingGroupByOutputType>[]
          }
          count: {
            args: Prisma.HoldingCountArgs<ExtArgs>
            result: $Utils.Optional<HoldingCountAggregateOutputType> | number
          }
        }
      }
      RolloverRequest: {
        payload: Prisma.$RolloverRequestPayload<ExtArgs>
        fields: Prisma.RolloverRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolloverRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolloverRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload>
          }
          findFirst: {
            args: Prisma.RolloverRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolloverRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload>
          }
          findMany: {
            args: Prisma.RolloverRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload>[]
          }
          create: {
            args: Prisma.RolloverRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload>
          }
          createMany: {
            args: Prisma.RolloverRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolloverRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload>[]
          }
          delete: {
            args: Prisma.RolloverRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload>
          }
          update: {
            args: Prisma.RolloverRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload>
          }
          deleteMany: {
            args: Prisma.RolloverRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolloverRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolloverRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverRequestPayload>
          }
          aggregate: {
            args: Prisma.RolloverRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolloverRequest>
          }
          groupBy: {
            args: Prisma.RolloverRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolloverRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolloverRequestCountArgs<ExtArgs>
            result: $Utils.Optional<RolloverRequestCountAggregateOutputType> | number
          }
        }
      }
      RolloverFile: {
        payload: Prisma.$RolloverFilePayload<ExtArgs>
        fields: Prisma.RolloverFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolloverFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolloverFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload>
          }
          findFirst: {
            args: Prisma.RolloverFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolloverFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload>
          }
          findMany: {
            args: Prisma.RolloverFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload>[]
          }
          create: {
            args: Prisma.RolloverFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload>
          }
          createMany: {
            args: Prisma.RolloverFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolloverFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload>[]
          }
          delete: {
            args: Prisma.RolloverFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload>
          }
          update: {
            args: Prisma.RolloverFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload>
          }
          deleteMany: {
            args: Prisma.RolloverFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolloverFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolloverFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolloverFilePayload>
          }
          aggregate: {
            args: Prisma.RolloverFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolloverFile>
          }
          groupBy: {
            args: Prisma.RolloverFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolloverFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolloverFileCountArgs<ExtArgs>
            result: $Utils.Optional<RolloverFileCountAggregateOutputType> | number
          }
        }
      }
      Withdrawal: {
        payload: Prisma.$WithdrawalPayload<ExtArgs>
        fields: Prisma.WithdrawalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WithdrawalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WithdrawalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          findFirst: {
            args: Prisma.WithdrawalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WithdrawalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          findMany: {
            args: Prisma.WithdrawalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          create: {
            args: Prisma.WithdrawalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          createMany: {
            args: Prisma.WithdrawalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WithdrawalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          delete: {
            args: Prisma.WithdrawalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          update: {
            args: Prisma.WithdrawalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          deleteMany: {
            args: Prisma.WithdrawalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WithdrawalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WithdrawalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          aggregate: {
            args: Prisma.WithdrawalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWithdrawal>
          }
          groupBy: {
            args: Prisma.WithdrawalGroupByArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalGroupByOutputType>[]
          }
          count: {
            args: Prisma.WithdrawalCountArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalCountAggregateOutputType> | number
          }
        }
      }
      Deposit: {
        payload: Prisma.$DepositPayload<ExtArgs>
        fields: Prisma.DepositFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepositFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepositFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          findFirst: {
            args: Prisma.DepositFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepositFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          findMany: {
            args: Prisma.DepositFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          create: {
            args: Prisma.DepositCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          createMany: {
            args: Prisma.DepositCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepositCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          delete: {
            args: Prisma.DepositDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          update: {
            args: Prisma.DepositUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          deleteMany: {
            args: Prisma.DepositDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepositUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepositUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          aggregate: {
            args: Prisma.DepositAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeposit>
          }
          groupBy: {
            args: Prisma.DepositGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepositGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepositCountArgs<ExtArgs>
            result: $Utils.Optional<DepositCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      SupportMessage: {
        payload: Prisma.$SupportMessagePayload<ExtArgs>
        fields: Prisma.SupportMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          findFirst: {
            args: Prisma.SupportMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          findMany: {
            args: Prisma.SupportMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
          }
          create: {
            args: Prisma.SupportMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          createMany: {
            args: Prisma.SupportMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
          }
          delete: {
            args: Prisma.SupportMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          update: {
            args: Prisma.SupportMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          deleteMany: {
            args: Prisma.SupportMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupportMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          aggregate: {
            args: Prisma.SupportMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportMessage>
          }
          groupBy: {
            args: Prisma.SupportMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportMessageCountArgs<ExtArgs>
            result: $Utils.Optional<SupportMessageCountAggregateOutputType> | number
          }
        }
      }
      AdminAudit: {
        payload: Prisma.$AdminAuditPayload<ExtArgs>
        fields: Prisma.AdminAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          findMany: {
            args: Prisma.AdminAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>[]
          }
          create: {
            args: Prisma.AdminAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          createMany: {
            args: Prisma.AdminAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          update: {
            args: Prisma.AdminAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAudit>
          }
          groupBy: {
            args: Prisma.AdminAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditCountAggregateOutputType> | number
          }
        }
      }
      KycSubmission: {
        payload: Prisma.$KycSubmissionPayload<ExtArgs>
        fields: Prisma.KycSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KycSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KycSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload>
          }
          findFirst: {
            args: Prisma.KycSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KycSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload>
          }
          findMany: {
            args: Prisma.KycSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload>[]
          }
          create: {
            args: Prisma.KycSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload>
          }
          createMany: {
            args: Prisma.KycSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KycSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload>[]
          }
          delete: {
            args: Prisma.KycSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload>
          }
          update: {
            args: Prisma.KycSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.KycSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KycSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KycSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycSubmissionPayload>
          }
          aggregate: {
            args: Prisma.KycSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKycSubmission>
          }
          groupBy: {
            args: Prisma.KycSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<KycSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.KycSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<KycSubmissionCountAggregateOutputType> | number
          }
        }
      }
      KycFile: {
        payload: Prisma.$KycFilePayload<ExtArgs>
        fields: Prisma.KycFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KycFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KycFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload>
          }
          findFirst: {
            args: Prisma.KycFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KycFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload>
          }
          findMany: {
            args: Prisma.KycFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload>[]
          }
          create: {
            args: Prisma.KycFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload>
          }
          createMany: {
            args: Prisma.KycFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KycFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload>[]
          }
          delete: {
            args: Prisma.KycFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload>
          }
          update: {
            args: Prisma.KycFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload>
          }
          deleteMany: {
            args: Prisma.KycFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KycFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KycFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycFilePayload>
          }
          aggregate: {
            args: Prisma.KycFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKycFile>
          }
          groupBy: {
            args: Prisma.KycFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<KycFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.KycFileCountArgs<ExtArgs>
            result: $Utils.Optional<KycFileCountAggregateOutputType> | number
          }
        }
      }
      WalletSync: {
        payload: Prisma.$WalletSyncPayload<ExtArgs>
        fields: Prisma.WalletSyncFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletSyncFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletSyncFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload>
          }
          findFirst: {
            args: Prisma.WalletSyncFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletSyncFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload>
          }
          findMany: {
            args: Prisma.WalletSyncFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload>[]
          }
          create: {
            args: Prisma.WalletSyncCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload>
          }
          createMany: {
            args: Prisma.WalletSyncCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletSyncCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload>[]
          }
          delete: {
            args: Prisma.WalletSyncDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload>
          }
          update: {
            args: Prisma.WalletSyncUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload>
          }
          deleteMany: {
            args: Prisma.WalletSyncDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletSyncUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletSyncUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletSyncPayload>
          }
          aggregate: {
            args: Prisma.WalletSyncAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletSync>
          }
          groupBy: {
            args: Prisma.WalletSyncGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletSyncGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletSyncCountArgs<ExtArgs>
            result: $Utils.Optional<WalletSyncCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    projects: number
    txs: number
    cards: number
    holdings: number
    rollovers: number
    withdrawals: number
    supportTickets: number
    supportMessages: number
    deposits: number
    adminAuditLogs: number
    kycSubmissions: number
    walletSyncs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    txs?: boolean | UserCountOutputTypeCountTxsArgs
    cards?: boolean | UserCountOutputTypeCountCardsArgs
    holdings?: boolean | UserCountOutputTypeCountHoldingsArgs
    rollovers?: boolean | UserCountOutputTypeCountRolloversArgs
    withdrawals?: boolean | UserCountOutputTypeCountWithdrawalsArgs
    supportTickets?: boolean | UserCountOutputTypeCountSupportTicketsArgs
    supportMessages?: boolean | UserCountOutputTypeCountSupportMessagesArgs
    deposits?: boolean | UserCountOutputTypeCountDepositsArgs
    adminAuditLogs?: boolean | UserCountOutputTypeCountAdminAuditLogsArgs
    kycSubmissions?: boolean | UserCountOutputTypeCountKycSubmissionsArgs
    walletSyncs?: boolean | UserCountOutputTypeCountWalletSyncsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTxsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoldingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolloversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolloverRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWithdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKycSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KycSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWalletSyncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletSyncWhereInput
  }


  /**
   * Count Type RolloverRequestCountOutputType
   */

  export type RolloverRequestCountOutputType = {
    files: number
  }

  export type RolloverRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | RolloverRequestCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * RolloverRequestCountOutputType without action
   */
  export type RolloverRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequestCountOutputType
     */
    select?: RolloverRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolloverRequestCountOutputType without action
   */
  export type RolloverRequestCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolloverFileWhereInput
  }


  /**
   * Count Type SupportTicketCountOutputType
   */

  export type SupportTicketCountOutputType = {
    messages: number
  }

  export type SupportTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | SupportTicketCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketCountOutputType
     */
    select?: SupportTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportMessageWhereInput
  }


  /**
   * Count Type KycSubmissionCountOutputType
   */

  export type KycSubmissionCountOutputType = {
    files: number
  }

  export type KycSubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | KycSubmissionCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * KycSubmissionCountOutputType without action
   */
  export type KycSubmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmissionCountOutputType
     */
    select?: KycSubmissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KycSubmissionCountOutputType without action
   */
  export type KycSubmissionCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KycFileWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    username: string | null
    email: string | null
    country: string | null
    phone: string | null
    password: string | null
    role: $Enums.Role | null
    emailVerified: boolean | null
    verificationToken: string | null
    wallet: string | null
    kycStatus: $Enums.KycStatus | null
    kycSubmittedAt: Date | null
    createdAt: Date | null
    twoFAEnabled: boolean | null
    twoFASecret: string | null
    city: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    username: string | null
    email: string | null
    country: string | null
    phone: string | null
    password: string | null
    role: $Enums.Role | null
    emailVerified: boolean | null
    verificationToken: string | null
    wallet: string | null
    kycStatus: $Enums.KycStatus | null
    kycSubmittedAt: Date | null
    createdAt: Date | null
    twoFAEnabled: boolean | null
    twoFASecret: string | null
    city: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    username: number
    email: number
    country: number
    phone: number
    password: number
    role: number
    emailVerified: number
    verificationToken: number
    wallet: number
    kycStatus: number
    kycSubmittedAt: number
    wallets: number
    createdAt: number
    twoFAEnabled: number
    twoFASecret: number
    city: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    country?: true
    phone?: true
    password?: true
    role?: true
    emailVerified?: true
    verificationToken?: true
    wallet?: true
    kycStatus?: true
    kycSubmittedAt?: true
    createdAt?: true
    twoFAEnabled?: true
    twoFASecret?: true
    city?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    country?: true
    phone?: true
    password?: true
    role?: true
    emailVerified?: true
    verificationToken?: true
    wallet?: true
    kycStatus?: true
    kycSubmittedAt?: true
    createdAt?: true
    twoFAEnabled?: true
    twoFASecret?: true
    city?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    country?: true
    phone?: true
    password?: true
    role?: true
    emailVerified?: true
    verificationToken?: true
    wallet?: true
    kycStatus?: true
    kycSubmittedAt?: true
    wallets?: true
    createdAt?: true
    twoFAEnabled?: true
    twoFASecret?: true
    city?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    username: string
    email: string
    country: string | null
    phone: string | null
    password: string
    role: $Enums.Role
    emailVerified: boolean
    verificationToken: string | null
    wallet: string | null
    kycStatus: $Enums.KycStatus
    kycSubmittedAt: Date | null
    wallets: string[]
    createdAt: Date
    twoFAEnabled: boolean
    twoFASecret: string | null
    city: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    country?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    wallet?: boolean
    kycStatus?: boolean
    kycSubmittedAt?: boolean
    wallets?: boolean
    createdAt?: boolean
    twoFAEnabled?: boolean
    twoFASecret?: boolean
    city?: boolean
    projects?: boolean | User$projectsArgs<ExtArgs>
    txs?: boolean | User$txsArgs<ExtArgs>
    cards?: boolean | User$cardsArgs<ExtArgs>
    holdings?: boolean | User$holdingsArgs<ExtArgs>
    rollovers?: boolean | User$rolloversArgs<ExtArgs>
    withdrawals?: boolean | User$withdrawalsArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    supportMessages?: boolean | User$supportMessagesArgs<ExtArgs>
    deposits?: boolean | User$depositsArgs<ExtArgs>
    adminAuditLogs?: boolean | User$adminAuditLogsArgs<ExtArgs>
    kycSubmissions?: boolean | User$kycSubmissionsArgs<ExtArgs>
    walletSyncs?: boolean | User$walletSyncsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    country?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    wallet?: boolean
    kycStatus?: boolean
    kycSubmittedAt?: boolean
    wallets?: boolean
    createdAt?: boolean
    twoFAEnabled?: boolean
    twoFASecret?: boolean
    city?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    country?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    wallet?: boolean
    kycStatus?: boolean
    kycSubmittedAt?: boolean
    wallets?: boolean
    createdAt?: boolean
    twoFAEnabled?: boolean
    twoFASecret?: boolean
    city?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | User$projectsArgs<ExtArgs>
    txs?: boolean | User$txsArgs<ExtArgs>
    cards?: boolean | User$cardsArgs<ExtArgs>
    holdings?: boolean | User$holdingsArgs<ExtArgs>
    rollovers?: boolean | User$rolloversArgs<ExtArgs>
    withdrawals?: boolean | User$withdrawalsArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    supportMessages?: boolean | User$supportMessagesArgs<ExtArgs>
    deposits?: boolean | User$depositsArgs<ExtArgs>
    adminAuditLogs?: boolean | User$adminAuditLogsArgs<ExtArgs>
    kycSubmissions?: boolean | User$kycSubmissionsArgs<ExtArgs>
    walletSyncs?: boolean | User$walletSyncsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      txs: Prisma.$TransactionPayload<ExtArgs>[]
      cards: Prisma.$CardRequestPayload<ExtArgs>[]
      holdings: Prisma.$HoldingPayload<ExtArgs>[]
      rollovers: Prisma.$RolloverRequestPayload<ExtArgs>[]
      withdrawals: Prisma.$WithdrawalPayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      supportMessages: Prisma.$SupportMessagePayload<ExtArgs>[]
      deposits: Prisma.$DepositPayload<ExtArgs>[]
      adminAuditLogs: Prisma.$AdminAuditPayload<ExtArgs>[]
      kycSubmissions: Prisma.$KycSubmissionPayload<ExtArgs>[]
      walletSyncs: Prisma.$WalletSyncPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      username: string
      email: string
      country: string | null
      phone: string | null
      password: string
      role: $Enums.Role
      emailVerified: boolean
      verificationToken: string | null
      wallet: string | null
      kycStatus: $Enums.KycStatus
      kycSubmittedAt: Date | null
      wallets: string[]
      createdAt: Date
      twoFAEnabled: boolean
      twoFASecret: string | null
      city: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    txs<T extends User$txsArgs<ExtArgs> = {}>(args?: Subset<T, User$txsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    cards<T extends User$cardsArgs<ExtArgs> = {}>(args?: Subset<T, User$cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findMany"> | Null>
    holdings<T extends User$holdingsArgs<ExtArgs> = {}>(args?: Subset<T, User$holdingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "findMany"> | Null>
    rollovers<T extends User$rolloversArgs<ExtArgs> = {}>(args?: Subset<T, User$rolloversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "findMany"> | Null>
    withdrawals<T extends User$withdrawalsArgs<ExtArgs> = {}>(args?: Subset<T, User$withdrawalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findMany"> | Null>
    supportTickets<T extends User$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany"> | Null>
    supportMessages<T extends User$supportMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$supportMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findMany"> | Null>
    deposits<T extends User$depositsArgs<ExtArgs> = {}>(args?: Subset<T, User$depositsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany"> | Null>
    adminAuditLogs<T extends User$adminAuditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$adminAuditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findMany"> | Null>
    kycSubmissions<T extends User$kycSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$kycSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    walletSyncs<T extends User$walletSyncsArgs<ExtArgs> = {}>(args?: Subset<T, User$walletSyncsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly wallet: FieldRef<"User", 'String'>
    readonly kycStatus: FieldRef<"User", 'KycStatus'>
    readonly kycSubmittedAt: FieldRef<"User", 'DateTime'>
    readonly wallets: FieldRef<"User", 'String[]'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly twoFAEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFASecret: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.txs
   */
  export type User$txsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.cards
   */
  export type User$cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    where?: CardRequestWhereInput
    orderBy?: CardRequestOrderByWithRelationInput | CardRequestOrderByWithRelationInput[]
    cursor?: CardRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardRequestScalarFieldEnum | CardRequestScalarFieldEnum[]
  }

  /**
   * User.holdings
   */
  export type User$holdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    where?: HoldingWhereInput
    orderBy?: HoldingOrderByWithRelationInput | HoldingOrderByWithRelationInput[]
    cursor?: HoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoldingScalarFieldEnum | HoldingScalarFieldEnum[]
  }

  /**
   * User.rollovers
   */
  export type User$rolloversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    where?: RolloverRequestWhereInput
    orderBy?: RolloverRequestOrderByWithRelationInput | RolloverRequestOrderByWithRelationInput[]
    cursor?: RolloverRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolloverRequestScalarFieldEnum | RolloverRequestScalarFieldEnum[]
  }

  /**
   * User.withdrawals
   */
  export type User$withdrawalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    where?: WithdrawalWhereInput
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    cursor?: WithdrawalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * User.supportTickets
   */
  export type User$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.supportMessages
   */
  export type User$supportMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    where?: SupportMessageWhereInput
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    cursor?: SupportMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * User.deposits
   */
  export type User$depositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    cursor?: DepositWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * User.adminAuditLogs
   */
  export type User$adminAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    where?: AdminAuditWhereInput
    orderBy?: AdminAuditOrderByWithRelationInput | AdminAuditOrderByWithRelationInput[]
    cursor?: AdminAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuditScalarFieldEnum | AdminAuditScalarFieldEnum[]
  }

  /**
   * User.kycSubmissions
   */
  export type User$kycSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    where?: KycSubmissionWhereInput
    orderBy?: KycSubmissionOrderByWithRelationInput | KycSubmissionOrderByWithRelationInput[]
    cursor?: KycSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KycSubmissionScalarFieldEnum | KycSubmissionScalarFieldEnum[]
  }

  /**
   * User.walletSyncs
   */
  export type User$walletSyncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    where?: WalletSyncWhereInput
    orderBy?: WalletSyncOrderByWithRelationInput | WalletSyncOrderByWithRelationInput[]
    cursor?: WalletSyncWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletSyncScalarFieldEnum | WalletSyncScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    title: string | null
    status: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    title: string | null
    status: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    title: number
    status: number
    userId: number
    createdAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    title?: true
    status?: true
    userId?: true
    createdAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    title?: true
    status?: true
    userId?: true
    createdAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    title?: true
    status?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    title: string
    status: string
    userId: number
    createdAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    title?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      status: string
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly title: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly userId: FieldRef<"Project", 'Int'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    ref: string | null
    type: $Enums.TxType | null
    amount: string | null
    status: $Enums.TxStatus | null
    userId: number | null
    createdAt: Date | null
    symbol: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    ref: string | null
    type: $Enums.TxType | null
    amount: string | null
    status: $Enums.TxStatus | null
    userId: number | null
    createdAt: Date | null
    symbol: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    ref: number
    type: number
    amount: number
    status: number
    userId: number
    createdAt: number
    symbol: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    ref?: true
    type?: true
    amount?: true
    status?: true
    userId?: true
    createdAt?: true
    symbol?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    ref?: true
    type?: true
    amount?: true
    status?: true
    userId?: true
    createdAt?: true
    symbol?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    ref?: true
    type?: true
    amount?: true
    status?: true
    userId?: true
    createdAt?: true
    symbol?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    ref: string | null
    type: $Enums.TxType
    amount: string
    status: $Enums.TxStatus
    userId: number
    createdAt: Date
    symbol: string | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ref?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    symbol?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ref?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    symbol?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    ref?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    symbol?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ref: string | null
      type: $Enums.TxType
      amount: string
      status: $Enums.TxStatus
      userId: number
      createdAt: Date
      symbol: string | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly ref: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TxType'>
    readonly amount: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'TxStatus'>
    readonly userId: FieldRef<"Transaction", 'Int'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly symbol: FieldRef<"Transaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model CardRequest
   */

  export type AggregateCardRequest = {
    _count: CardRequestCountAggregateOutputType | null
    _avg: CardRequestAvgAggregateOutputType | null
    _sum: CardRequestSumAggregateOutputType | null
    _min: CardRequestMinAggregateOutputType | null
    _max: CardRequestMaxAggregateOutputType | null
  }

  export type CardRequestAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CardRequestSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CardRequestMinAggregateOutputType = {
    id: number | null
    status: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type CardRequestMaxAggregateOutputType = {
    id: number | null
    status: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type CardRequestCountAggregateOutputType = {
    id: number
    status: number
    userId: number
    createdAt: number
    _all: number
  }


  export type CardRequestAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CardRequestSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CardRequestMinAggregateInputType = {
    id?: true
    status?: true
    userId?: true
    createdAt?: true
  }

  export type CardRequestMaxAggregateInputType = {
    id?: true
    status?: true
    userId?: true
    createdAt?: true
  }

  export type CardRequestCountAggregateInputType = {
    id?: true
    status?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type CardRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardRequest to aggregate.
     */
    where?: CardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequests to fetch.
     */
    orderBy?: CardRequestOrderByWithRelationInput | CardRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardRequests
    **/
    _count?: true | CardRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardRequestMaxAggregateInputType
  }

  export type GetCardRequestAggregateType<T extends CardRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCardRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardRequest[P]>
      : GetScalarType<T[P], AggregateCardRequest[P]>
  }




  export type CardRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardRequestWhereInput
    orderBy?: CardRequestOrderByWithAggregationInput | CardRequestOrderByWithAggregationInput[]
    by: CardRequestScalarFieldEnum[] | CardRequestScalarFieldEnum
    having?: CardRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardRequestCountAggregateInputType | true
    _avg?: CardRequestAvgAggregateInputType
    _sum?: CardRequestSumAggregateInputType
    _min?: CardRequestMinAggregateInputType
    _max?: CardRequestMaxAggregateInputType
  }

  export type CardRequestGroupByOutputType = {
    id: number
    status: string
    userId: number
    createdAt: Date
    _count: CardRequestCountAggregateOutputType | null
    _avg: CardRequestAvgAggregateOutputType | null
    _sum: CardRequestSumAggregateOutputType | null
    _min: CardRequestMinAggregateOutputType | null
    _max: CardRequestMaxAggregateOutputType | null
  }

  type GetCardRequestGroupByPayload<T extends CardRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CardRequestGroupByOutputType[P]>
        }
      >
    >


  export type CardRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardRequest"]>

  export type CardRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardRequest"]>

  export type CardRequestSelectScalar = {
    id?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type CardRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CardRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CardRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["cardRequest"]>
    composites: {}
  }

  type CardRequestGetPayload<S extends boolean | null | undefined | CardRequestDefaultArgs> = $Result.GetResult<Prisma.$CardRequestPayload, S>

  type CardRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CardRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CardRequestCountAggregateInputType | true
    }

  export interface CardRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardRequest'], meta: { name: 'CardRequest' } }
    /**
     * Find zero or one CardRequest that matches the filter.
     * @param {CardRequestFindUniqueArgs} args - Arguments to find a CardRequest
     * @example
     * // Get one CardRequest
     * const cardRequest = await prisma.cardRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardRequestFindUniqueArgs>(args: SelectSubset<T, CardRequestFindUniqueArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CardRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CardRequestFindUniqueOrThrowArgs} args - Arguments to find a CardRequest
     * @example
     * // Get one CardRequest
     * const cardRequest = await prisma.cardRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CardRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CardRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestFindFirstArgs} args - Arguments to find a CardRequest
     * @example
     * // Get one CardRequest
     * const cardRequest = await prisma.cardRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardRequestFindFirstArgs>(args?: SelectSubset<T, CardRequestFindFirstArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CardRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestFindFirstOrThrowArgs} args - Arguments to find a CardRequest
     * @example
     * // Get one CardRequest
     * const cardRequest = await prisma.cardRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CardRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CardRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardRequests
     * const cardRequests = await prisma.cardRequest.findMany()
     * 
     * // Get first 10 CardRequests
     * const cardRequests = await prisma.cardRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardRequestWithIdOnly = await prisma.cardRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardRequestFindManyArgs>(args?: SelectSubset<T, CardRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CardRequest.
     * @param {CardRequestCreateArgs} args - Arguments to create a CardRequest.
     * @example
     * // Create one CardRequest
     * const CardRequest = await prisma.cardRequest.create({
     *   data: {
     *     // ... data to create a CardRequest
     *   }
     * })
     * 
     */
    create<T extends CardRequestCreateArgs>(args: SelectSubset<T, CardRequestCreateArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CardRequests.
     * @param {CardRequestCreateManyArgs} args - Arguments to create many CardRequests.
     * @example
     * // Create many CardRequests
     * const cardRequest = await prisma.cardRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardRequestCreateManyArgs>(args?: SelectSubset<T, CardRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CardRequests and returns the data saved in the database.
     * @param {CardRequestCreateManyAndReturnArgs} args - Arguments to create many CardRequests.
     * @example
     * // Create many CardRequests
     * const cardRequest = await prisma.cardRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CardRequests and only return the `id`
     * const cardRequestWithIdOnly = await prisma.cardRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CardRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CardRequest.
     * @param {CardRequestDeleteArgs} args - Arguments to delete one CardRequest.
     * @example
     * // Delete one CardRequest
     * const CardRequest = await prisma.cardRequest.delete({
     *   where: {
     *     // ... filter to delete one CardRequest
     *   }
     * })
     * 
     */
    delete<T extends CardRequestDeleteArgs>(args: SelectSubset<T, CardRequestDeleteArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CardRequest.
     * @param {CardRequestUpdateArgs} args - Arguments to update one CardRequest.
     * @example
     * // Update one CardRequest
     * const cardRequest = await prisma.cardRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardRequestUpdateArgs>(args: SelectSubset<T, CardRequestUpdateArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CardRequests.
     * @param {CardRequestDeleteManyArgs} args - Arguments to filter CardRequests to delete.
     * @example
     * // Delete a few CardRequests
     * const { count } = await prisma.cardRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardRequestDeleteManyArgs>(args?: SelectSubset<T, CardRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardRequests
     * const cardRequest = await prisma.cardRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardRequestUpdateManyArgs>(args: SelectSubset<T, CardRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CardRequest.
     * @param {CardRequestUpsertArgs} args - Arguments to update or create a CardRequest.
     * @example
     * // Update or create a CardRequest
     * const cardRequest = await prisma.cardRequest.upsert({
     *   create: {
     *     // ... data to create a CardRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardRequest we want to update
     *   }
     * })
     */
    upsert<T extends CardRequestUpsertArgs>(args: SelectSubset<T, CardRequestUpsertArgs<ExtArgs>>): Prisma__CardRequestClient<$Result.GetResult<Prisma.$CardRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CardRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestCountArgs} args - Arguments to filter CardRequests to count.
     * @example
     * // Count the number of CardRequests
     * const count = await prisma.cardRequest.count({
     *   where: {
     *     // ... the filter for the CardRequests we want to count
     *   }
     * })
    **/
    count<T extends CardRequestCountArgs>(
      args?: Subset<T, CardRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardRequestAggregateArgs>(args: Subset<T, CardRequestAggregateArgs>): Prisma.PrismaPromise<GetCardRequestAggregateType<T>>

    /**
     * Group by CardRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardRequestGroupByArgs['orderBy'] }
        : { orderBy?: CardRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardRequest model
   */
  readonly fields: CardRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardRequest model
   */ 
  interface CardRequestFieldRefs {
    readonly id: FieldRef<"CardRequest", 'Int'>
    readonly status: FieldRef<"CardRequest", 'String'>
    readonly userId: FieldRef<"CardRequest", 'Int'>
    readonly createdAt: FieldRef<"CardRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CardRequest findUnique
   */
  export type CardRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequest to fetch.
     */
    where: CardRequestWhereUniqueInput
  }

  /**
   * CardRequest findUniqueOrThrow
   */
  export type CardRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequest to fetch.
     */
    where: CardRequestWhereUniqueInput
  }

  /**
   * CardRequest findFirst
   */
  export type CardRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequest to fetch.
     */
    where?: CardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequests to fetch.
     */
    orderBy?: CardRequestOrderByWithRelationInput | CardRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardRequests.
     */
    cursor?: CardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardRequests.
     */
    distinct?: CardRequestScalarFieldEnum | CardRequestScalarFieldEnum[]
  }

  /**
   * CardRequest findFirstOrThrow
   */
  export type CardRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequest to fetch.
     */
    where?: CardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequests to fetch.
     */
    orderBy?: CardRequestOrderByWithRelationInput | CardRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardRequests.
     */
    cursor?: CardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardRequests.
     */
    distinct?: CardRequestScalarFieldEnum | CardRequestScalarFieldEnum[]
  }

  /**
   * CardRequest findMany
   */
  export type CardRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter, which CardRequests to fetch.
     */
    where?: CardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardRequests to fetch.
     */
    orderBy?: CardRequestOrderByWithRelationInput | CardRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardRequests.
     */
    cursor?: CardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardRequests.
     */
    skip?: number
    distinct?: CardRequestScalarFieldEnum | CardRequestScalarFieldEnum[]
  }

  /**
   * CardRequest create
   */
  export type CardRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CardRequest.
     */
    data: XOR<CardRequestCreateInput, CardRequestUncheckedCreateInput>
  }

  /**
   * CardRequest createMany
   */
  export type CardRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardRequests.
     */
    data: CardRequestCreateManyInput | CardRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CardRequest createManyAndReturn
   */
  export type CardRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CardRequests.
     */
    data: CardRequestCreateManyInput | CardRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardRequest update
   */
  export type CardRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CardRequest.
     */
    data: XOR<CardRequestUpdateInput, CardRequestUncheckedUpdateInput>
    /**
     * Choose, which CardRequest to update.
     */
    where: CardRequestWhereUniqueInput
  }

  /**
   * CardRequest updateMany
   */
  export type CardRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardRequests.
     */
    data: XOR<CardRequestUpdateManyMutationInput, CardRequestUncheckedUpdateManyInput>
    /**
     * Filter which CardRequests to update
     */
    where?: CardRequestWhereInput
  }

  /**
   * CardRequest upsert
   */
  export type CardRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CardRequest to update in case it exists.
     */
    where: CardRequestWhereUniqueInput
    /**
     * In case the CardRequest found by the `where` argument doesn't exist, create a new CardRequest with this data.
     */
    create: XOR<CardRequestCreateInput, CardRequestUncheckedCreateInput>
    /**
     * In case the CardRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardRequestUpdateInput, CardRequestUncheckedUpdateInput>
  }

  /**
   * CardRequest delete
   */
  export type CardRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
    /**
     * Filter which CardRequest to delete.
     */
    where: CardRequestWhereUniqueInput
  }

  /**
   * CardRequest deleteMany
   */
  export type CardRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardRequests to delete
     */
    where?: CardRequestWhereInput
  }

  /**
   * CardRequest without action
   */
  export type CardRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardRequest
     */
    select?: CardRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardRequestInclude<ExtArgs> | null
  }


  /**
   * Model Holding
   */

  export type AggregateHolding = {
    _count: HoldingCountAggregateOutputType | null
    _avg: HoldingAvgAggregateOutputType | null
    _sum: HoldingSumAggregateOutputType | null
    _min: HoldingMinAggregateOutputType | null
    _max: HoldingMaxAggregateOutputType | null
  }

  export type HoldingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: Decimal | null
    locked: Decimal | null
  }

  export type HoldingSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: Decimal | null
    locked: Decimal | null
  }

  export type HoldingMinAggregateOutputType = {
    id: number | null
    userId: number | null
    symbol: string | null
    amount: Decimal | null
    locked: Decimal | null
    updatedAt: Date | null
  }

  export type HoldingMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    symbol: string | null
    amount: Decimal | null
    locked: Decimal | null
    updatedAt: Date | null
  }

  export type HoldingCountAggregateOutputType = {
    id: number
    userId: number
    symbol: number
    amount: number
    locked: number
    updatedAt: number
    _all: number
  }


  export type HoldingAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    locked?: true
  }

  export type HoldingSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    locked?: true
  }

  export type HoldingMinAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    amount?: true
    locked?: true
    updatedAt?: true
  }

  export type HoldingMaxAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    amount?: true
    locked?: true
    updatedAt?: true
  }

  export type HoldingCountAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    amount?: true
    locked?: true
    updatedAt?: true
    _all?: true
  }

  export type HoldingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holding to aggregate.
     */
    where?: HoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holdings to fetch.
     */
    orderBy?: HoldingOrderByWithRelationInput | HoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Holdings
    **/
    _count?: true | HoldingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HoldingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HoldingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HoldingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HoldingMaxAggregateInputType
  }

  export type GetHoldingAggregateType<T extends HoldingAggregateArgs> = {
        [P in keyof T & keyof AggregateHolding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHolding[P]>
      : GetScalarType<T[P], AggregateHolding[P]>
  }




  export type HoldingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoldingWhereInput
    orderBy?: HoldingOrderByWithAggregationInput | HoldingOrderByWithAggregationInput[]
    by: HoldingScalarFieldEnum[] | HoldingScalarFieldEnum
    having?: HoldingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HoldingCountAggregateInputType | true
    _avg?: HoldingAvgAggregateInputType
    _sum?: HoldingSumAggregateInputType
    _min?: HoldingMinAggregateInputType
    _max?: HoldingMaxAggregateInputType
  }

  export type HoldingGroupByOutputType = {
    id: number
    userId: number
    symbol: string
    amount: Decimal
    locked: Decimal
    updatedAt: Date
    _count: HoldingCountAggregateOutputType | null
    _avg: HoldingAvgAggregateOutputType | null
    _sum: HoldingSumAggregateOutputType | null
    _min: HoldingMinAggregateOutputType | null
    _max: HoldingMaxAggregateOutputType | null
  }

  type GetHoldingGroupByPayload<T extends HoldingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HoldingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HoldingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HoldingGroupByOutputType[P]>
            : GetScalarType<T[P], HoldingGroupByOutputType[P]>
        }
      >
    >


  export type HoldingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    amount?: boolean
    locked?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holding"]>

  export type HoldingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    amount?: boolean
    locked?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holding"]>

  export type HoldingSelectScalar = {
    id?: boolean
    userId?: boolean
    symbol?: boolean
    amount?: boolean
    locked?: boolean
    updatedAt?: boolean
  }

  export type HoldingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HoldingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HoldingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Holding"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      symbol: string
      amount: Prisma.Decimal
      locked: Prisma.Decimal
      updatedAt: Date
    }, ExtArgs["result"]["holding"]>
    composites: {}
  }

  type HoldingGetPayload<S extends boolean | null | undefined | HoldingDefaultArgs> = $Result.GetResult<Prisma.$HoldingPayload, S>

  type HoldingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HoldingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HoldingCountAggregateInputType | true
    }

  export interface HoldingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Holding'], meta: { name: 'Holding' } }
    /**
     * Find zero or one Holding that matches the filter.
     * @param {HoldingFindUniqueArgs} args - Arguments to find a Holding
     * @example
     * // Get one Holding
     * const holding = await prisma.holding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HoldingFindUniqueArgs>(args: SelectSubset<T, HoldingFindUniqueArgs<ExtArgs>>): Prisma__HoldingClient<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Holding that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HoldingFindUniqueOrThrowArgs} args - Arguments to find a Holding
     * @example
     * // Get one Holding
     * const holding = await prisma.holding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HoldingFindUniqueOrThrowArgs>(args: SelectSubset<T, HoldingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HoldingClient<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Holding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldingFindFirstArgs} args - Arguments to find a Holding
     * @example
     * // Get one Holding
     * const holding = await prisma.holding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HoldingFindFirstArgs>(args?: SelectSubset<T, HoldingFindFirstArgs<ExtArgs>>): Prisma__HoldingClient<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Holding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldingFindFirstOrThrowArgs} args - Arguments to find a Holding
     * @example
     * // Get one Holding
     * const holding = await prisma.holding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HoldingFindFirstOrThrowArgs>(args?: SelectSubset<T, HoldingFindFirstOrThrowArgs<ExtArgs>>): Prisma__HoldingClient<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Holdings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holdings
     * const holdings = await prisma.holding.findMany()
     * 
     * // Get first 10 Holdings
     * const holdings = await prisma.holding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holdingWithIdOnly = await prisma.holding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HoldingFindManyArgs>(args?: SelectSubset<T, HoldingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Holding.
     * @param {HoldingCreateArgs} args - Arguments to create a Holding.
     * @example
     * // Create one Holding
     * const Holding = await prisma.holding.create({
     *   data: {
     *     // ... data to create a Holding
     *   }
     * })
     * 
     */
    create<T extends HoldingCreateArgs>(args: SelectSubset<T, HoldingCreateArgs<ExtArgs>>): Prisma__HoldingClient<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Holdings.
     * @param {HoldingCreateManyArgs} args - Arguments to create many Holdings.
     * @example
     * // Create many Holdings
     * const holding = await prisma.holding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HoldingCreateManyArgs>(args?: SelectSubset<T, HoldingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holdings and returns the data saved in the database.
     * @param {HoldingCreateManyAndReturnArgs} args - Arguments to create many Holdings.
     * @example
     * // Create many Holdings
     * const holding = await prisma.holding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holdings and only return the `id`
     * const holdingWithIdOnly = await prisma.holding.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HoldingCreateManyAndReturnArgs>(args?: SelectSubset<T, HoldingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Holding.
     * @param {HoldingDeleteArgs} args - Arguments to delete one Holding.
     * @example
     * // Delete one Holding
     * const Holding = await prisma.holding.delete({
     *   where: {
     *     // ... filter to delete one Holding
     *   }
     * })
     * 
     */
    delete<T extends HoldingDeleteArgs>(args: SelectSubset<T, HoldingDeleteArgs<ExtArgs>>): Prisma__HoldingClient<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Holding.
     * @param {HoldingUpdateArgs} args - Arguments to update one Holding.
     * @example
     * // Update one Holding
     * const holding = await prisma.holding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HoldingUpdateArgs>(args: SelectSubset<T, HoldingUpdateArgs<ExtArgs>>): Prisma__HoldingClient<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Holdings.
     * @param {HoldingDeleteManyArgs} args - Arguments to filter Holdings to delete.
     * @example
     * // Delete a few Holdings
     * const { count } = await prisma.holding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HoldingDeleteManyArgs>(args?: SelectSubset<T, HoldingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holdings
     * const holding = await prisma.holding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HoldingUpdateManyArgs>(args: SelectSubset<T, HoldingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Holding.
     * @param {HoldingUpsertArgs} args - Arguments to update or create a Holding.
     * @example
     * // Update or create a Holding
     * const holding = await prisma.holding.upsert({
     *   create: {
     *     // ... data to create a Holding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holding we want to update
     *   }
     * })
     */
    upsert<T extends HoldingUpsertArgs>(args: SelectSubset<T, HoldingUpsertArgs<ExtArgs>>): Prisma__HoldingClient<$Result.GetResult<Prisma.$HoldingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldingCountArgs} args - Arguments to filter Holdings to count.
     * @example
     * // Count the number of Holdings
     * const count = await prisma.holding.count({
     *   where: {
     *     // ... the filter for the Holdings we want to count
     *   }
     * })
    **/
    count<T extends HoldingCountArgs>(
      args?: Subset<T, HoldingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HoldingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HoldingAggregateArgs>(args: Subset<T, HoldingAggregateArgs>): Prisma.PrismaPromise<GetHoldingAggregateType<T>>

    /**
     * Group by Holding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HoldingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HoldingGroupByArgs['orderBy'] }
        : { orderBy?: HoldingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HoldingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHoldingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Holding model
   */
  readonly fields: HoldingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Holding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HoldingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Holding model
   */ 
  interface HoldingFieldRefs {
    readonly id: FieldRef<"Holding", 'Int'>
    readonly userId: FieldRef<"Holding", 'Int'>
    readonly symbol: FieldRef<"Holding", 'String'>
    readonly amount: FieldRef<"Holding", 'Decimal'>
    readonly locked: FieldRef<"Holding", 'Decimal'>
    readonly updatedAt: FieldRef<"Holding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Holding findUnique
   */
  export type HoldingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    /**
     * Filter, which Holding to fetch.
     */
    where: HoldingWhereUniqueInput
  }

  /**
   * Holding findUniqueOrThrow
   */
  export type HoldingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    /**
     * Filter, which Holding to fetch.
     */
    where: HoldingWhereUniqueInput
  }

  /**
   * Holding findFirst
   */
  export type HoldingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    /**
     * Filter, which Holding to fetch.
     */
    where?: HoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holdings to fetch.
     */
    orderBy?: HoldingOrderByWithRelationInput | HoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holdings.
     */
    cursor?: HoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holdings.
     */
    distinct?: HoldingScalarFieldEnum | HoldingScalarFieldEnum[]
  }

  /**
   * Holding findFirstOrThrow
   */
  export type HoldingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    /**
     * Filter, which Holding to fetch.
     */
    where?: HoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holdings to fetch.
     */
    orderBy?: HoldingOrderByWithRelationInput | HoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holdings.
     */
    cursor?: HoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holdings.
     */
    distinct?: HoldingScalarFieldEnum | HoldingScalarFieldEnum[]
  }

  /**
   * Holding findMany
   */
  export type HoldingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    /**
     * Filter, which Holdings to fetch.
     */
    where?: HoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holdings to fetch.
     */
    orderBy?: HoldingOrderByWithRelationInput | HoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Holdings.
     */
    cursor?: HoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holdings.
     */
    skip?: number
    distinct?: HoldingScalarFieldEnum | HoldingScalarFieldEnum[]
  }

  /**
   * Holding create
   */
  export type HoldingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    /**
     * The data needed to create a Holding.
     */
    data: XOR<HoldingCreateInput, HoldingUncheckedCreateInput>
  }

  /**
   * Holding createMany
   */
  export type HoldingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Holdings.
     */
    data: HoldingCreateManyInput | HoldingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holding createManyAndReturn
   */
  export type HoldingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Holdings.
     */
    data: HoldingCreateManyInput | HoldingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Holding update
   */
  export type HoldingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    /**
     * The data needed to update a Holding.
     */
    data: XOR<HoldingUpdateInput, HoldingUncheckedUpdateInput>
    /**
     * Choose, which Holding to update.
     */
    where: HoldingWhereUniqueInput
  }

  /**
   * Holding updateMany
   */
  export type HoldingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Holdings.
     */
    data: XOR<HoldingUpdateManyMutationInput, HoldingUncheckedUpdateManyInput>
    /**
     * Filter which Holdings to update
     */
    where?: HoldingWhereInput
  }

  /**
   * Holding upsert
   */
  export type HoldingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    /**
     * The filter to search for the Holding to update in case it exists.
     */
    where: HoldingWhereUniqueInput
    /**
     * In case the Holding found by the `where` argument doesn't exist, create a new Holding with this data.
     */
    create: XOR<HoldingCreateInput, HoldingUncheckedCreateInput>
    /**
     * In case the Holding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HoldingUpdateInput, HoldingUncheckedUpdateInput>
  }

  /**
   * Holding delete
   */
  export type HoldingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
    /**
     * Filter which Holding to delete.
     */
    where: HoldingWhereUniqueInput
  }

  /**
   * Holding deleteMany
   */
  export type HoldingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holdings to delete
     */
    where?: HoldingWhereInput
  }

  /**
   * Holding without action
   */
  export type HoldingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holding
     */
    select?: HoldingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HoldingInclude<ExtArgs> | null
  }


  /**
   * Model RolloverRequest
   */

  export type AggregateRolloverRequest = {
    _count: RolloverRequestCountAggregateOutputType | null
    _avg: RolloverRequestAvgAggregateOutputType | null
    _sum: RolloverRequestSumAggregateOutputType | null
    _min: RolloverRequestMinAggregateOutputType | null
    _max: RolloverRequestMaxAggregateOutputType | null
  }

  export type RolloverRequestAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    approxBalance: Decimal | null
  }

  export type RolloverRequestSumAggregateOutputType = {
    id: number | null
    userId: number | null
    approxBalance: Decimal | null
  }

  export type RolloverRequestMinAggregateOutputType = {
    id: number | null
    userId: number | null
    provider: string | null
    approxBalance: Decimal | null
    taxType: string | null
    destType: string | null
    destInstitution: string | null
    destAccountLast4: string | null
    legalName: string | null
    dob: Date | null
    status: $Enums.RolloverStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolloverRequestMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    provider: string | null
    approxBalance: Decimal | null
    taxType: string | null
    destType: string | null
    destInstitution: string | null
    destAccountLast4: string | null
    legalName: string | null
    dob: Date | null
    status: $Enums.RolloverStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolloverRequestCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    approxBalance: number
    taxType: number
    destType: number
    destInstitution: number
    destAccountLast4: number
    legalName: number
    dob: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolloverRequestAvgAggregateInputType = {
    id?: true
    userId?: true
    approxBalance?: true
  }

  export type RolloverRequestSumAggregateInputType = {
    id?: true
    userId?: true
    approxBalance?: true
  }

  export type RolloverRequestMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    approxBalance?: true
    taxType?: true
    destType?: true
    destInstitution?: true
    destAccountLast4?: true
    legalName?: true
    dob?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolloverRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    approxBalance?: true
    taxType?: true
    destType?: true
    destInstitution?: true
    destAccountLast4?: true
    legalName?: true
    dob?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolloverRequestCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    approxBalance?: true
    taxType?: true
    destType?: true
    destInstitution?: true
    destAccountLast4?: true
    legalName?: true
    dob?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolloverRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolloverRequest to aggregate.
     */
    where?: RolloverRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolloverRequests to fetch.
     */
    orderBy?: RolloverRequestOrderByWithRelationInput | RolloverRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolloverRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolloverRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolloverRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolloverRequests
    **/
    _count?: true | RolloverRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolloverRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolloverRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolloverRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolloverRequestMaxAggregateInputType
  }

  export type GetRolloverRequestAggregateType<T extends RolloverRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRolloverRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolloverRequest[P]>
      : GetScalarType<T[P], AggregateRolloverRequest[P]>
  }




  export type RolloverRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolloverRequestWhereInput
    orderBy?: RolloverRequestOrderByWithAggregationInput | RolloverRequestOrderByWithAggregationInput[]
    by: RolloverRequestScalarFieldEnum[] | RolloverRequestScalarFieldEnum
    having?: RolloverRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolloverRequestCountAggregateInputType | true
    _avg?: RolloverRequestAvgAggregateInputType
    _sum?: RolloverRequestSumAggregateInputType
    _min?: RolloverRequestMinAggregateInputType
    _max?: RolloverRequestMaxAggregateInputType
  }

  export type RolloverRequestGroupByOutputType = {
    id: number
    userId: number
    provider: string
    approxBalance: Decimal
    taxType: string
    destType: string
    destInstitution: string | null
    destAccountLast4: string | null
    legalName: string
    dob: Date
    status: $Enums.RolloverStatus
    createdAt: Date
    updatedAt: Date
    _count: RolloverRequestCountAggregateOutputType | null
    _avg: RolloverRequestAvgAggregateOutputType | null
    _sum: RolloverRequestSumAggregateOutputType | null
    _min: RolloverRequestMinAggregateOutputType | null
    _max: RolloverRequestMaxAggregateOutputType | null
  }

  type GetRolloverRequestGroupByPayload<T extends RolloverRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolloverRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolloverRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolloverRequestGroupByOutputType[P]>
            : GetScalarType<T[P], RolloverRequestGroupByOutputType[P]>
        }
      >
    >


  export type RolloverRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    approxBalance?: boolean
    taxType?: boolean
    destType?: boolean
    destInstitution?: boolean
    destAccountLast4?: boolean
    legalName?: boolean
    dob?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | RolloverRequest$filesArgs<ExtArgs>
    _count?: boolean | RolloverRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolloverRequest"]>

  export type RolloverRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    approxBalance?: boolean
    taxType?: boolean
    destType?: boolean
    destInstitution?: boolean
    destAccountLast4?: boolean
    legalName?: boolean
    dob?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolloverRequest"]>

  export type RolloverRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    approxBalance?: boolean
    taxType?: boolean
    destType?: boolean
    destInstitution?: boolean
    destAccountLast4?: boolean
    legalName?: boolean
    dob?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RolloverRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | RolloverRequest$filesArgs<ExtArgs>
    _count?: boolean | RolloverRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolloverRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RolloverRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolloverRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      files: Prisma.$RolloverFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      provider: string
      approxBalance: Prisma.Decimal
      taxType: string
      destType: string
      destInstitution: string | null
      destAccountLast4: string | null
      legalName: string
      dob: Date
      status: $Enums.RolloverStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rolloverRequest"]>
    composites: {}
  }

  type RolloverRequestGetPayload<S extends boolean | null | undefined | RolloverRequestDefaultArgs> = $Result.GetResult<Prisma.$RolloverRequestPayload, S>

  type RolloverRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolloverRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolloverRequestCountAggregateInputType | true
    }

  export interface RolloverRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolloverRequest'], meta: { name: 'RolloverRequest' } }
    /**
     * Find zero or one RolloverRequest that matches the filter.
     * @param {RolloverRequestFindUniqueArgs} args - Arguments to find a RolloverRequest
     * @example
     * // Get one RolloverRequest
     * const rolloverRequest = await prisma.rolloverRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolloverRequestFindUniqueArgs>(args: SelectSubset<T, RolloverRequestFindUniqueArgs<ExtArgs>>): Prisma__RolloverRequestClient<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolloverRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolloverRequestFindUniqueOrThrowArgs} args - Arguments to find a RolloverRequest
     * @example
     * // Get one RolloverRequest
     * const rolloverRequest = await prisma.rolloverRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolloverRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RolloverRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolloverRequestClient<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolloverRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverRequestFindFirstArgs} args - Arguments to find a RolloverRequest
     * @example
     * // Get one RolloverRequest
     * const rolloverRequest = await prisma.rolloverRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolloverRequestFindFirstArgs>(args?: SelectSubset<T, RolloverRequestFindFirstArgs<ExtArgs>>): Prisma__RolloverRequestClient<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolloverRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverRequestFindFirstOrThrowArgs} args - Arguments to find a RolloverRequest
     * @example
     * // Get one RolloverRequest
     * const rolloverRequest = await prisma.rolloverRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolloverRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RolloverRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolloverRequestClient<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolloverRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolloverRequests
     * const rolloverRequests = await prisma.rolloverRequest.findMany()
     * 
     * // Get first 10 RolloverRequests
     * const rolloverRequests = await prisma.rolloverRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolloverRequestWithIdOnly = await prisma.rolloverRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolloverRequestFindManyArgs>(args?: SelectSubset<T, RolloverRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolloverRequest.
     * @param {RolloverRequestCreateArgs} args - Arguments to create a RolloverRequest.
     * @example
     * // Create one RolloverRequest
     * const RolloverRequest = await prisma.rolloverRequest.create({
     *   data: {
     *     // ... data to create a RolloverRequest
     *   }
     * })
     * 
     */
    create<T extends RolloverRequestCreateArgs>(args: SelectSubset<T, RolloverRequestCreateArgs<ExtArgs>>): Prisma__RolloverRequestClient<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolloverRequests.
     * @param {RolloverRequestCreateManyArgs} args - Arguments to create many RolloverRequests.
     * @example
     * // Create many RolloverRequests
     * const rolloverRequest = await prisma.rolloverRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolloverRequestCreateManyArgs>(args?: SelectSubset<T, RolloverRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolloverRequests and returns the data saved in the database.
     * @param {RolloverRequestCreateManyAndReturnArgs} args - Arguments to create many RolloverRequests.
     * @example
     * // Create many RolloverRequests
     * const rolloverRequest = await prisma.rolloverRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolloverRequests and only return the `id`
     * const rolloverRequestWithIdOnly = await prisma.rolloverRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolloverRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RolloverRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolloverRequest.
     * @param {RolloverRequestDeleteArgs} args - Arguments to delete one RolloverRequest.
     * @example
     * // Delete one RolloverRequest
     * const RolloverRequest = await prisma.rolloverRequest.delete({
     *   where: {
     *     // ... filter to delete one RolloverRequest
     *   }
     * })
     * 
     */
    delete<T extends RolloverRequestDeleteArgs>(args: SelectSubset<T, RolloverRequestDeleteArgs<ExtArgs>>): Prisma__RolloverRequestClient<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolloverRequest.
     * @param {RolloverRequestUpdateArgs} args - Arguments to update one RolloverRequest.
     * @example
     * // Update one RolloverRequest
     * const rolloverRequest = await prisma.rolloverRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolloverRequestUpdateArgs>(args: SelectSubset<T, RolloverRequestUpdateArgs<ExtArgs>>): Prisma__RolloverRequestClient<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolloverRequests.
     * @param {RolloverRequestDeleteManyArgs} args - Arguments to filter RolloverRequests to delete.
     * @example
     * // Delete a few RolloverRequests
     * const { count } = await prisma.rolloverRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolloverRequestDeleteManyArgs>(args?: SelectSubset<T, RolloverRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolloverRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolloverRequests
     * const rolloverRequest = await prisma.rolloverRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolloverRequestUpdateManyArgs>(args: SelectSubset<T, RolloverRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolloverRequest.
     * @param {RolloverRequestUpsertArgs} args - Arguments to update or create a RolloverRequest.
     * @example
     * // Update or create a RolloverRequest
     * const rolloverRequest = await prisma.rolloverRequest.upsert({
     *   create: {
     *     // ... data to create a RolloverRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolloverRequest we want to update
     *   }
     * })
     */
    upsert<T extends RolloverRequestUpsertArgs>(args: SelectSubset<T, RolloverRequestUpsertArgs<ExtArgs>>): Prisma__RolloverRequestClient<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolloverRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverRequestCountArgs} args - Arguments to filter RolloverRequests to count.
     * @example
     * // Count the number of RolloverRequests
     * const count = await prisma.rolloverRequest.count({
     *   where: {
     *     // ... the filter for the RolloverRequests we want to count
     *   }
     * })
    **/
    count<T extends RolloverRequestCountArgs>(
      args?: Subset<T, RolloverRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolloverRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolloverRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolloverRequestAggregateArgs>(args: Subset<T, RolloverRequestAggregateArgs>): Prisma.PrismaPromise<GetRolloverRequestAggregateType<T>>

    /**
     * Group by RolloverRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolloverRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolloverRequestGroupByArgs['orderBy'] }
        : { orderBy?: RolloverRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolloverRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolloverRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolloverRequest model
   */
  readonly fields: RolloverRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolloverRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolloverRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    files<T extends RolloverRequest$filesArgs<ExtArgs> = {}>(args?: Subset<T, RolloverRequest$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolloverRequest model
   */ 
  interface RolloverRequestFieldRefs {
    readonly id: FieldRef<"RolloverRequest", 'Int'>
    readonly userId: FieldRef<"RolloverRequest", 'Int'>
    readonly provider: FieldRef<"RolloverRequest", 'String'>
    readonly approxBalance: FieldRef<"RolloverRequest", 'Decimal'>
    readonly taxType: FieldRef<"RolloverRequest", 'String'>
    readonly destType: FieldRef<"RolloverRequest", 'String'>
    readonly destInstitution: FieldRef<"RolloverRequest", 'String'>
    readonly destAccountLast4: FieldRef<"RolloverRequest", 'String'>
    readonly legalName: FieldRef<"RolloverRequest", 'String'>
    readonly dob: FieldRef<"RolloverRequest", 'DateTime'>
    readonly status: FieldRef<"RolloverRequest", 'RolloverStatus'>
    readonly createdAt: FieldRef<"RolloverRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"RolloverRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolloverRequest findUnique
   */
  export type RolloverRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    /**
     * Filter, which RolloverRequest to fetch.
     */
    where: RolloverRequestWhereUniqueInput
  }

  /**
   * RolloverRequest findUniqueOrThrow
   */
  export type RolloverRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    /**
     * Filter, which RolloverRequest to fetch.
     */
    where: RolloverRequestWhereUniqueInput
  }

  /**
   * RolloverRequest findFirst
   */
  export type RolloverRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    /**
     * Filter, which RolloverRequest to fetch.
     */
    where?: RolloverRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolloverRequests to fetch.
     */
    orderBy?: RolloverRequestOrderByWithRelationInput | RolloverRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolloverRequests.
     */
    cursor?: RolloverRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolloverRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolloverRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolloverRequests.
     */
    distinct?: RolloverRequestScalarFieldEnum | RolloverRequestScalarFieldEnum[]
  }

  /**
   * RolloverRequest findFirstOrThrow
   */
  export type RolloverRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    /**
     * Filter, which RolloverRequest to fetch.
     */
    where?: RolloverRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolloverRequests to fetch.
     */
    orderBy?: RolloverRequestOrderByWithRelationInput | RolloverRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolloverRequests.
     */
    cursor?: RolloverRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolloverRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolloverRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolloverRequests.
     */
    distinct?: RolloverRequestScalarFieldEnum | RolloverRequestScalarFieldEnum[]
  }

  /**
   * RolloverRequest findMany
   */
  export type RolloverRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    /**
     * Filter, which RolloverRequests to fetch.
     */
    where?: RolloverRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolloverRequests to fetch.
     */
    orderBy?: RolloverRequestOrderByWithRelationInput | RolloverRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolloverRequests.
     */
    cursor?: RolloverRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolloverRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolloverRequests.
     */
    skip?: number
    distinct?: RolloverRequestScalarFieldEnum | RolloverRequestScalarFieldEnum[]
  }

  /**
   * RolloverRequest create
   */
  export type RolloverRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a RolloverRequest.
     */
    data: XOR<RolloverRequestCreateInput, RolloverRequestUncheckedCreateInput>
  }

  /**
   * RolloverRequest createMany
   */
  export type RolloverRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolloverRequests.
     */
    data: RolloverRequestCreateManyInput | RolloverRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolloverRequest createManyAndReturn
   */
  export type RolloverRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolloverRequests.
     */
    data: RolloverRequestCreateManyInput | RolloverRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolloverRequest update
   */
  export type RolloverRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a RolloverRequest.
     */
    data: XOR<RolloverRequestUpdateInput, RolloverRequestUncheckedUpdateInput>
    /**
     * Choose, which RolloverRequest to update.
     */
    where: RolloverRequestWhereUniqueInput
  }

  /**
   * RolloverRequest updateMany
   */
  export type RolloverRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolloverRequests.
     */
    data: XOR<RolloverRequestUpdateManyMutationInput, RolloverRequestUncheckedUpdateManyInput>
    /**
     * Filter which RolloverRequests to update
     */
    where?: RolloverRequestWhereInput
  }

  /**
   * RolloverRequest upsert
   */
  export type RolloverRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the RolloverRequest to update in case it exists.
     */
    where: RolloverRequestWhereUniqueInput
    /**
     * In case the RolloverRequest found by the `where` argument doesn't exist, create a new RolloverRequest with this data.
     */
    create: XOR<RolloverRequestCreateInput, RolloverRequestUncheckedCreateInput>
    /**
     * In case the RolloverRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolloverRequestUpdateInput, RolloverRequestUncheckedUpdateInput>
  }

  /**
   * RolloverRequest delete
   */
  export type RolloverRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
    /**
     * Filter which RolloverRequest to delete.
     */
    where: RolloverRequestWhereUniqueInput
  }

  /**
   * RolloverRequest deleteMany
   */
  export type RolloverRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolloverRequests to delete
     */
    where?: RolloverRequestWhereInput
  }

  /**
   * RolloverRequest.files
   */
  export type RolloverRequest$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    where?: RolloverFileWhereInput
    orderBy?: RolloverFileOrderByWithRelationInput | RolloverFileOrderByWithRelationInput[]
    cursor?: RolloverFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolloverFileScalarFieldEnum | RolloverFileScalarFieldEnum[]
  }

  /**
   * RolloverRequest without action
   */
  export type RolloverRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverRequest
     */
    select?: RolloverRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverRequestInclude<ExtArgs> | null
  }


  /**
   * Model RolloverFile
   */

  export type AggregateRolloverFile = {
    _count: RolloverFileCountAggregateOutputType | null
    _avg: RolloverFileAvgAggregateOutputType | null
    _sum: RolloverFileSumAggregateOutputType | null
    _min: RolloverFileMinAggregateOutputType | null
    _max: RolloverFileMaxAggregateOutputType | null
  }

  export type RolloverFileAvgAggregateOutputType = {
    id: number | null
    rolloverId: number | null
    size: number | null
  }

  export type RolloverFileSumAggregateOutputType = {
    id: number | null
    rolloverId: number | null
    size: number | null
  }

  export type RolloverFileMinAggregateOutputType = {
    id: number | null
    rolloverId: number | null
    path: string | null
    original: string | null
    mime: string | null
    size: number | null
    createdAt: Date | null
  }

  export type RolloverFileMaxAggregateOutputType = {
    id: number | null
    rolloverId: number | null
    path: string | null
    original: string | null
    mime: string | null
    size: number | null
    createdAt: Date | null
  }

  export type RolloverFileCountAggregateOutputType = {
    id: number
    rolloverId: number
    path: number
    original: number
    mime: number
    size: number
    createdAt: number
    _all: number
  }


  export type RolloverFileAvgAggregateInputType = {
    id?: true
    rolloverId?: true
    size?: true
  }

  export type RolloverFileSumAggregateInputType = {
    id?: true
    rolloverId?: true
    size?: true
  }

  export type RolloverFileMinAggregateInputType = {
    id?: true
    rolloverId?: true
    path?: true
    original?: true
    mime?: true
    size?: true
    createdAt?: true
  }

  export type RolloverFileMaxAggregateInputType = {
    id?: true
    rolloverId?: true
    path?: true
    original?: true
    mime?: true
    size?: true
    createdAt?: true
  }

  export type RolloverFileCountAggregateInputType = {
    id?: true
    rolloverId?: true
    path?: true
    original?: true
    mime?: true
    size?: true
    createdAt?: true
    _all?: true
  }

  export type RolloverFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolloverFile to aggregate.
     */
    where?: RolloverFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolloverFiles to fetch.
     */
    orderBy?: RolloverFileOrderByWithRelationInput | RolloverFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolloverFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolloverFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolloverFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolloverFiles
    **/
    _count?: true | RolloverFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolloverFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolloverFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolloverFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolloverFileMaxAggregateInputType
  }

  export type GetRolloverFileAggregateType<T extends RolloverFileAggregateArgs> = {
        [P in keyof T & keyof AggregateRolloverFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolloverFile[P]>
      : GetScalarType<T[P], AggregateRolloverFile[P]>
  }




  export type RolloverFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolloverFileWhereInput
    orderBy?: RolloverFileOrderByWithAggregationInput | RolloverFileOrderByWithAggregationInput[]
    by: RolloverFileScalarFieldEnum[] | RolloverFileScalarFieldEnum
    having?: RolloverFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolloverFileCountAggregateInputType | true
    _avg?: RolloverFileAvgAggregateInputType
    _sum?: RolloverFileSumAggregateInputType
    _min?: RolloverFileMinAggregateInputType
    _max?: RolloverFileMaxAggregateInputType
  }

  export type RolloverFileGroupByOutputType = {
    id: number
    rolloverId: number
    path: string
    original: string
    mime: string
    size: number
    createdAt: Date
    _count: RolloverFileCountAggregateOutputType | null
    _avg: RolloverFileAvgAggregateOutputType | null
    _sum: RolloverFileSumAggregateOutputType | null
    _min: RolloverFileMinAggregateOutputType | null
    _max: RolloverFileMaxAggregateOutputType | null
  }

  type GetRolloverFileGroupByPayload<T extends RolloverFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolloverFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolloverFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolloverFileGroupByOutputType[P]>
            : GetScalarType<T[P], RolloverFileGroupByOutputType[P]>
        }
      >
    >


  export type RolloverFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolloverId?: boolean
    path?: boolean
    original?: boolean
    mime?: boolean
    size?: boolean
    createdAt?: boolean
    rollover?: boolean | RolloverRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolloverFile"]>

  export type RolloverFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolloverId?: boolean
    path?: boolean
    original?: boolean
    mime?: boolean
    size?: boolean
    createdAt?: boolean
    rollover?: boolean | RolloverRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolloverFile"]>

  export type RolloverFileSelectScalar = {
    id?: boolean
    rolloverId?: boolean
    path?: boolean
    original?: boolean
    mime?: boolean
    size?: boolean
    createdAt?: boolean
  }

  export type RolloverFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rollover?: boolean | RolloverRequestDefaultArgs<ExtArgs>
  }
  export type RolloverFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rollover?: boolean | RolloverRequestDefaultArgs<ExtArgs>
  }

  export type $RolloverFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolloverFile"
    objects: {
      rollover: Prisma.$RolloverRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rolloverId: number
      path: string
      original: string
      mime: string
      size: number
      createdAt: Date
    }, ExtArgs["result"]["rolloverFile"]>
    composites: {}
  }

  type RolloverFileGetPayload<S extends boolean | null | undefined | RolloverFileDefaultArgs> = $Result.GetResult<Prisma.$RolloverFilePayload, S>

  type RolloverFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolloverFileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolloverFileCountAggregateInputType | true
    }

  export interface RolloverFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolloverFile'], meta: { name: 'RolloverFile' } }
    /**
     * Find zero or one RolloverFile that matches the filter.
     * @param {RolloverFileFindUniqueArgs} args - Arguments to find a RolloverFile
     * @example
     * // Get one RolloverFile
     * const rolloverFile = await prisma.rolloverFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolloverFileFindUniqueArgs>(args: SelectSubset<T, RolloverFileFindUniqueArgs<ExtArgs>>): Prisma__RolloverFileClient<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolloverFile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolloverFileFindUniqueOrThrowArgs} args - Arguments to find a RolloverFile
     * @example
     * // Get one RolloverFile
     * const rolloverFile = await prisma.rolloverFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolloverFileFindUniqueOrThrowArgs>(args: SelectSubset<T, RolloverFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolloverFileClient<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolloverFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverFileFindFirstArgs} args - Arguments to find a RolloverFile
     * @example
     * // Get one RolloverFile
     * const rolloverFile = await prisma.rolloverFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolloverFileFindFirstArgs>(args?: SelectSubset<T, RolloverFileFindFirstArgs<ExtArgs>>): Prisma__RolloverFileClient<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolloverFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverFileFindFirstOrThrowArgs} args - Arguments to find a RolloverFile
     * @example
     * // Get one RolloverFile
     * const rolloverFile = await prisma.rolloverFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolloverFileFindFirstOrThrowArgs>(args?: SelectSubset<T, RolloverFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolloverFileClient<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolloverFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolloverFiles
     * const rolloverFiles = await prisma.rolloverFile.findMany()
     * 
     * // Get first 10 RolloverFiles
     * const rolloverFiles = await prisma.rolloverFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolloverFileWithIdOnly = await prisma.rolloverFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolloverFileFindManyArgs>(args?: SelectSubset<T, RolloverFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolloverFile.
     * @param {RolloverFileCreateArgs} args - Arguments to create a RolloverFile.
     * @example
     * // Create one RolloverFile
     * const RolloverFile = await prisma.rolloverFile.create({
     *   data: {
     *     // ... data to create a RolloverFile
     *   }
     * })
     * 
     */
    create<T extends RolloverFileCreateArgs>(args: SelectSubset<T, RolloverFileCreateArgs<ExtArgs>>): Prisma__RolloverFileClient<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolloverFiles.
     * @param {RolloverFileCreateManyArgs} args - Arguments to create many RolloverFiles.
     * @example
     * // Create many RolloverFiles
     * const rolloverFile = await prisma.rolloverFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolloverFileCreateManyArgs>(args?: SelectSubset<T, RolloverFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolloverFiles and returns the data saved in the database.
     * @param {RolloverFileCreateManyAndReturnArgs} args - Arguments to create many RolloverFiles.
     * @example
     * // Create many RolloverFiles
     * const rolloverFile = await prisma.rolloverFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolloverFiles and only return the `id`
     * const rolloverFileWithIdOnly = await prisma.rolloverFile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolloverFileCreateManyAndReturnArgs>(args?: SelectSubset<T, RolloverFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolloverFile.
     * @param {RolloverFileDeleteArgs} args - Arguments to delete one RolloverFile.
     * @example
     * // Delete one RolloverFile
     * const RolloverFile = await prisma.rolloverFile.delete({
     *   where: {
     *     // ... filter to delete one RolloverFile
     *   }
     * })
     * 
     */
    delete<T extends RolloverFileDeleteArgs>(args: SelectSubset<T, RolloverFileDeleteArgs<ExtArgs>>): Prisma__RolloverFileClient<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolloverFile.
     * @param {RolloverFileUpdateArgs} args - Arguments to update one RolloverFile.
     * @example
     * // Update one RolloverFile
     * const rolloverFile = await prisma.rolloverFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolloverFileUpdateArgs>(args: SelectSubset<T, RolloverFileUpdateArgs<ExtArgs>>): Prisma__RolloverFileClient<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolloverFiles.
     * @param {RolloverFileDeleteManyArgs} args - Arguments to filter RolloverFiles to delete.
     * @example
     * // Delete a few RolloverFiles
     * const { count } = await prisma.rolloverFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolloverFileDeleteManyArgs>(args?: SelectSubset<T, RolloverFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolloverFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolloverFiles
     * const rolloverFile = await prisma.rolloverFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolloverFileUpdateManyArgs>(args: SelectSubset<T, RolloverFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolloverFile.
     * @param {RolloverFileUpsertArgs} args - Arguments to update or create a RolloverFile.
     * @example
     * // Update or create a RolloverFile
     * const rolloverFile = await prisma.rolloverFile.upsert({
     *   create: {
     *     // ... data to create a RolloverFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolloverFile we want to update
     *   }
     * })
     */
    upsert<T extends RolloverFileUpsertArgs>(args: SelectSubset<T, RolloverFileUpsertArgs<ExtArgs>>): Prisma__RolloverFileClient<$Result.GetResult<Prisma.$RolloverFilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolloverFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverFileCountArgs} args - Arguments to filter RolloverFiles to count.
     * @example
     * // Count the number of RolloverFiles
     * const count = await prisma.rolloverFile.count({
     *   where: {
     *     // ... the filter for the RolloverFiles we want to count
     *   }
     * })
    **/
    count<T extends RolloverFileCountArgs>(
      args?: Subset<T, RolloverFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolloverFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolloverFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolloverFileAggregateArgs>(args: Subset<T, RolloverFileAggregateArgs>): Prisma.PrismaPromise<GetRolloverFileAggregateType<T>>

    /**
     * Group by RolloverFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolloverFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolloverFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolloverFileGroupByArgs['orderBy'] }
        : { orderBy?: RolloverFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolloverFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolloverFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolloverFile model
   */
  readonly fields: RolloverFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolloverFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolloverFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rollover<T extends RolloverRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolloverRequestDefaultArgs<ExtArgs>>): Prisma__RolloverRequestClient<$Result.GetResult<Prisma.$RolloverRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolloverFile model
   */ 
  interface RolloverFileFieldRefs {
    readonly id: FieldRef<"RolloverFile", 'Int'>
    readonly rolloverId: FieldRef<"RolloverFile", 'Int'>
    readonly path: FieldRef<"RolloverFile", 'String'>
    readonly original: FieldRef<"RolloverFile", 'String'>
    readonly mime: FieldRef<"RolloverFile", 'String'>
    readonly size: FieldRef<"RolloverFile", 'Int'>
    readonly createdAt: FieldRef<"RolloverFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolloverFile findUnique
   */
  export type RolloverFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    /**
     * Filter, which RolloverFile to fetch.
     */
    where: RolloverFileWhereUniqueInput
  }

  /**
   * RolloverFile findUniqueOrThrow
   */
  export type RolloverFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    /**
     * Filter, which RolloverFile to fetch.
     */
    where: RolloverFileWhereUniqueInput
  }

  /**
   * RolloverFile findFirst
   */
  export type RolloverFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    /**
     * Filter, which RolloverFile to fetch.
     */
    where?: RolloverFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolloverFiles to fetch.
     */
    orderBy?: RolloverFileOrderByWithRelationInput | RolloverFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolloverFiles.
     */
    cursor?: RolloverFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolloverFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolloverFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolloverFiles.
     */
    distinct?: RolloverFileScalarFieldEnum | RolloverFileScalarFieldEnum[]
  }

  /**
   * RolloverFile findFirstOrThrow
   */
  export type RolloverFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    /**
     * Filter, which RolloverFile to fetch.
     */
    where?: RolloverFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolloverFiles to fetch.
     */
    orderBy?: RolloverFileOrderByWithRelationInput | RolloverFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolloverFiles.
     */
    cursor?: RolloverFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolloverFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolloverFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolloverFiles.
     */
    distinct?: RolloverFileScalarFieldEnum | RolloverFileScalarFieldEnum[]
  }

  /**
   * RolloverFile findMany
   */
  export type RolloverFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    /**
     * Filter, which RolloverFiles to fetch.
     */
    where?: RolloverFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolloverFiles to fetch.
     */
    orderBy?: RolloverFileOrderByWithRelationInput | RolloverFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolloverFiles.
     */
    cursor?: RolloverFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolloverFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolloverFiles.
     */
    skip?: number
    distinct?: RolloverFileScalarFieldEnum | RolloverFileScalarFieldEnum[]
  }

  /**
   * RolloverFile create
   */
  export type RolloverFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    /**
     * The data needed to create a RolloverFile.
     */
    data: XOR<RolloverFileCreateInput, RolloverFileUncheckedCreateInput>
  }

  /**
   * RolloverFile createMany
   */
  export type RolloverFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolloverFiles.
     */
    data: RolloverFileCreateManyInput | RolloverFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolloverFile createManyAndReturn
   */
  export type RolloverFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolloverFiles.
     */
    data: RolloverFileCreateManyInput | RolloverFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolloverFile update
   */
  export type RolloverFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    /**
     * The data needed to update a RolloverFile.
     */
    data: XOR<RolloverFileUpdateInput, RolloverFileUncheckedUpdateInput>
    /**
     * Choose, which RolloverFile to update.
     */
    where: RolloverFileWhereUniqueInput
  }

  /**
   * RolloverFile updateMany
   */
  export type RolloverFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolloverFiles.
     */
    data: XOR<RolloverFileUpdateManyMutationInput, RolloverFileUncheckedUpdateManyInput>
    /**
     * Filter which RolloverFiles to update
     */
    where?: RolloverFileWhereInput
  }

  /**
   * RolloverFile upsert
   */
  export type RolloverFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    /**
     * The filter to search for the RolloverFile to update in case it exists.
     */
    where: RolloverFileWhereUniqueInput
    /**
     * In case the RolloverFile found by the `where` argument doesn't exist, create a new RolloverFile with this data.
     */
    create: XOR<RolloverFileCreateInput, RolloverFileUncheckedCreateInput>
    /**
     * In case the RolloverFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolloverFileUpdateInput, RolloverFileUncheckedUpdateInput>
  }

  /**
   * RolloverFile delete
   */
  export type RolloverFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
    /**
     * Filter which RolloverFile to delete.
     */
    where: RolloverFileWhereUniqueInput
  }

  /**
   * RolloverFile deleteMany
   */
  export type RolloverFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolloverFiles to delete
     */
    where?: RolloverFileWhereInput
  }

  /**
   * RolloverFile without action
   */
  export type RolloverFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolloverFile
     */
    select?: RolloverFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolloverFileInclude<ExtArgs> | null
  }


  /**
   * Model Withdrawal
   */

  export type AggregateWithdrawal = {
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  export type WithdrawalAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: Decimal | null
    fee: Decimal | null
    netAmount: Decimal | null
  }

  export type WithdrawalSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: Decimal | null
    fee: Decimal | null
    netAmount: Decimal | null
  }

  export type WithdrawalMinAggregateOutputType = {
    id: number | null
    userId: number | null
    symbol: string | null
    network: string | null
    amount: Decimal | null
    fee: Decimal | null
    netAmount: Decimal | null
    address: string | null
    memo: string | null
    status: $Enums.WithdrawalStatus | null
    txHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
    adminStatus: $Enums.ReviewStatus | null
  }

  export type WithdrawalMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    symbol: string | null
    network: string | null
    amount: Decimal | null
    fee: Decimal | null
    netAmount: Decimal | null
    address: string | null
    memo: string | null
    status: $Enums.WithdrawalStatus | null
    txHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
    adminStatus: $Enums.ReviewStatus | null
  }

  export type WithdrawalCountAggregateOutputType = {
    id: number
    userId: number
    symbol: number
    network: number
    amount: number
    fee: number
    netAmount: number
    address: number
    memo: number
    status: number
    txHash: number
    createdAt: number
    updatedAt: number
    adminStatus: number
    _all: number
  }


  export type WithdrawalAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    fee?: true
    netAmount?: true
  }

  export type WithdrawalSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    fee?: true
    netAmount?: true
  }

  export type WithdrawalMinAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    network?: true
    amount?: true
    fee?: true
    netAmount?: true
    address?: true
    memo?: true
    status?: true
    txHash?: true
    createdAt?: true
    updatedAt?: true
    adminStatus?: true
  }

  export type WithdrawalMaxAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    network?: true
    amount?: true
    fee?: true
    netAmount?: true
    address?: true
    memo?: true
    status?: true
    txHash?: true
    createdAt?: true
    updatedAt?: true
    adminStatus?: true
  }

  export type WithdrawalCountAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    network?: true
    amount?: true
    fee?: true
    netAmount?: true
    address?: true
    memo?: true
    status?: true
    txHash?: true
    createdAt?: true
    updatedAt?: true
    adminStatus?: true
    _all?: true
  }

  export type WithdrawalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawal to aggregate.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Withdrawals
    **/
    _count?: true | WithdrawalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalMaxAggregateInputType
  }

  export type GetWithdrawalAggregateType<T extends WithdrawalAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawal[P]>
      : GetScalarType<T[P], AggregateWithdrawal[P]>
  }




  export type WithdrawalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalWhereInput
    orderBy?: WithdrawalOrderByWithAggregationInput | WithdrawalOrderByWithAggregationInput[]
    by: WithdrawalScalarFieldEnum[] | WithdrawalScalarFieldEnum
    having?: WithdrawalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalCountAggregateInputType | true
    _avg?: WithdrawalAvgAggregateInputType
    _sum?: WithdrawalSumAggregateInputType
    _min?: WithdrawalMinAggregateInputType
    _max?: WithdrawalMaxAggregateInputType
  }

  export type WithdrawalGroupByOutputType = {
    id: number
    userId: number
    symbol: string
    network: string
    amount: Decimal
    fee: Decimal
    netAmount: Decimal
    address: string
    memo: string | null
    status: $Enums.WithdrawalStatus
    txHash: string | null
    createdAt: Date
    updatedAt: Date
    adminStatus: $Enums.ReviewStatus
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  type GetWithdrawalGroupByPayload<T extends WithdrawalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
        }
      >
    >


  export type WithdrawalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    network?: boolean
    amount?: boolean
    fee?: boolean
    netAmount?: boolean
    address?: boolean
    memo?: boolean
    status?: boolean
    txHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    network?: boolean
    amount?: boolean
    fee?: boolean
    netAmount?: boolean
    address?: boolean
    memo?: boolean
    status?: boolean
    txHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectScalar = {
    id?: boolean
    userId?: boolean
    symbol?: boolean
    network?: boolean
    amount?: boolean
    fee?: boolean
    netAmount?: boolean
    address?: boolean
    memo?: boolean
    status?: boolean
    txHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminStatus?: boolean
  }

  export type WithdrawalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WithdrawalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WithdrawalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Withdrawal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      symbol: string
      network: string
      amount: Prisma.Decimal
      fee: Prisma.Decimal
      netAmount: Prisma.Decimal
      address: string
      memo: string | null
      status: $Enums.WithdrawalStatus
      txHash: string | null
      createdAt: Date
      updatedAt: Date
      adminStatus: $Enums.ReviewStatus
    }, ExtArgs["result"]["withdrawal"]>
    composites: {}
  }

  type WithdrawalGetPayload<S extends boolean | null | undefined | WithdrawalDefaultArgs> = $Result.GetResult<Prisma.$WithdrawalPayload, S>

  type WithdrawalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WithdrawalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WithdrawalCountAggregateInputType | true
    }

  export interface WithdrawalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Withdrawal'], meta: { name: 'Withdrawal' } }
    /**
     * Find zero or one Withdrawal that matches the filter.
     * @param {WithdrawalFindUniqueArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WithdrawalFindUniqueArgs>(args: SelectSubset<T, WithdrawalFindUniqueArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Withdrawal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WithdrawalFindUniqueOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WithdrawalFindUniqueOrThrowArgs>(args: SelectSubset<T, WithdrawalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Withdrawal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindFirstArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WithdrawalFindFirstArgs>(args?: SelectSubset<T, WithdrawalFindFirstArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Withdrawal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindFirstOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WithdrawalFindFirstOrThrowArgs>(args?: SelectSubset<T, WithdrawalFindFirstOrThrowArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany()
     * 
     * // Get first 10 Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WithdrawalFindManyArgs>(args?: SelectSubset<T, WithdrawalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Withdrawal.
     * @param {WithdrawalCreateArgs} args - Arguments to create a Withdrawal.
     * @example
     * // Create one Withdrawal
     * const Withdrawal = await prisma.withdrawal.create({
     *   data: {
     *     // ... data to create a Withdrawal
     *   }
     * })
     * 
     */
    create<T extends WithdrawalCreateArgs>(args: SelectSubset<T, WithdrawalCreateArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Withdrawals.
     * @param {WithdrawalCreateManyArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WithdrawalCreateManyArgs>(args?: SelectSubset<T, WithdrawalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Withdrawals and returns the data saved in the database.
     * @param {WithdrawalCreateManyAndReturnArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WithdrawalCreateManyAndReturnArgs>(args?: SelectSubset<T, WithdrawalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Withdrawal.
     * @param {WithdrawalDeleteArgs} args - Arguments to delete one Withdrawal.
     * @example
     * // Delete one Withdrawal
     * const Withdrawal = await prisma.withdrawal.delete({
     *   where: {
     *     // ... filter to delete one Withdrawal
     *   }
     * })
     * 
     */
    delete<T extends WithdrawalDeleteArgs>(args: SelectSubset<T, WithdrawalDeleteArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Withdrawal.
     * @param {WithdrawalUpdateArgs} args - Arguments to update one Withdrawal.
     * @example
     * // Update one Withdrawal
     * const withdrawal = await prisma.withdrawal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WithdrawalUpdateArgs>(args: SelectSubset<T, WithdrawalUpdateArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Withdrawals.
     * @param {WithdrawalDeleteManyArgs} args - Arguments to filter Withdrawals to delete.
     * @example
     * // Delete a few Withdrawals
     * const { count } = await prisma.withdrawal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WithdrawalDeleteManyArgs>(args?: SelectSubset<T, WithdrawalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WithdrawalUpdateManyArgs>(args: SelectSubset<T, WithdrawalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Withdrawal.
     * @param {WithdrawalUpsertArgs} args - Arguments to update or create a Withdrawal.
     * @example
     * // Update or create a Withdrawal
     * const withdrawal = await prisma.withdrawal.upsert({
     *   create: {
     *     // ... data to create a Withdrawal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdrawal we want to update
     *   }
     * })
     */
    upsert<T extends WithdrawalUpsertArgs>(args: SelectSubset<T, WithdrawalUpsertArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalCountArgs} args - Arguments to filter Withdrawals to count.
     * @example
     * // Count the number of Withdrawals
     * const count = await prisma.withdrawal.count({
     *   where: {
     *     // ... the filter for the Withdrawals we want to count
     *   }
     * })
    **/
    count<T extends WithdrawalCountArgs>(
      args?: Subset<T, WithdrawalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalAggregateArgs>(args: Subset<T, WithdrawalAggregateArgs>): Prisma.PrismaPromise<GetWithdrawalAggregateType<T>>

    /**
     * Group by Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WithdrawalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WithdrawalGroupByArgs['orderBy'] }
        : { orderBy?: WithdrawalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WithdrawalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Withdrawal model
   */
  readonly fields: WithdrawalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Withdrawal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WithdrawalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Withdrawal model
   */ 
  interface WithdrawalFieldRefs {
    readonly id: FieldRef<"Withdrawal", 'Int'>
    readonly userId: FieldRef<"Withdrawal", 'Int'>
    readonly symbol: FieldRef<"Withdrawal", 'String'>
    readonly network: FieldRef<"Withdrawal", 'String'>
    readonly amount: FieldRef<"Withdrawal", 'Decimal'>
    readonly fee: FieldRef<"Withdrawal", 'Decimal'>
    readonly netAmount: FieldRef<"Withdrawal", 'Decimal'>
    readonly address: FieldRef<"Withdrawal", 'String'>
    readonly memo: FieldRef<"Withdrawal", 'String'>
    readonly status: FieldRef<"Withdrawal", 'WithdrawalStatus'>
    readonly txHash: FieldRef<"Withdrawal", 'String'>
    readonly createdAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly updatedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly adminStatus: FieldRef<"Withdrawal", 'ReviewStatus'>
  }
    

  // Custom InputTypes
  /**
   * Withdrawal findUnique
   */
  export type WithdrawalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal findUniqueOrThrow
   */
  export type WithdrawalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal findFirst
   */
  export type WithdrawalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal findFirstOrThrow
   */
  export type WithdrawalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal findMany
   */
  export type WithdrawalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter, which Withdrawals to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal create
   */
  export type WithdrawalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * The data needed to create a Withdrawal.
     */
    data: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
  }

  /**
   * Withdrawal createMany
   */
  export type WithdrawalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalCreateManyInput | WithdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Withdrawal createManyAndReturn
   */
  export type WithdrawalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalCreateManyInput | WithdrawalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Withdrawal update
   */
  export type WithdrawalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * The data needed to update a Withdrawal.
     */
    data: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
    /**
     * Choose, which Withdrawal to update.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal updateMany
   */
  export type WithdrawalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Withdrawals.
     */
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyInput>
    /**
     * Filter which Withdrawals to update
     */
    where?: WithdrawalWhereInput
  }

  /**
   * Withdrawal upsert
   */
  export type WithdrawalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * The filter to search for the Withdrawal to update in case it exists.
     */
    where: WithdrawalWhereUniqueInput
    /**
     * In case the Withdrawal found by the `where` argument doesn't exist, create a new Withdrawal with this data.
     */
    create: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
    /**
     * In case the Withdrawal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
  }

  /**
   * Withdrawal delete
   */
  export type WithdrawalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
    /**
     * Filter which Withdrawal to delete.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal deleteMany
   */
  export type WithdrawalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawals to delete
     */
    where?: WithdrawalWhereInput
  }

  /**
   * Withdrawal without action
   */
  export type WithdrawalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalInclude<ExtArgs> | null
  }


  /**
   * Model Deposit
   */

  export type AggregateDeposit = {
    _count: DepositCountAggregateOutputType | null
    _avg: DepositAvgAggregateOutputType | null
    _sum: DepositSumAggregateOutputType | null
    _min: DepositMinAggregateOutputType | null
    _max: DepositMaxAggregateOutputType | null
  }

  export type DepositAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: Decimal | null
  }

  export type DepositSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: Decimal | null
  }

  export type DepositMinAggregateOutputType = {
    id: number | null
    userId: number | null
    symbol: string | null
    amount: Decimal | null
    txId: string | null
    adminStatus: $Enums.ReviewStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    symbol: string | null
    amount: Decimal | null
    txId: string | null
    adminStatus: $Enums.ReviewStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositCountAggregateOutputType = {
    id: number
    userId: number
    symbol: number
    amount: number
    txId: number
    adminStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepositAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type DepositSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type DepositMinAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    amount?: true
    txId?: true
    adminStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositMaxAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    amount?: true
    txId?: true
    adminStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositCountAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    amount?: true
    txId?: true
    adminStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepositAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposit to aggregate.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deposits
    **/
    _count?: true | DepositCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositMaxAggregateInputType
  }

  export type GetDepositAggregateType<T extends DepositAggregateArgs> = {
        [P in keyof T & keyof AggregateDeposit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeposit[P]>
      : GetScalarType<T[P], AggregateDeposit[P]>
  }




  export type DepositGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithAggregationInput | DepositOrderByWithAggregationInput[]
    by: DepositScalarFieldEnum[] | DepositScalarFieldEnum
    having?: DepositScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositCountAggregateInputType | true
    _avg?: DepositAvgAggregateInputType
    _sum?: DepositSumAggregateInputType
    _min?: DepositMinAggregateInputType
    _max?: DepositMaxAggregateInputType
  }

  export type DepositGroupByOutputType = {
    id: number
    userId: number
    symbol: string
    amount: Decimal
    txId: string | null
    adminStatus: $Enums.ReviewStatus
    createdAt: Date
    updatedAt: Date
    _count: DepositCountAggregateOutputType | null
    _avg: DepositAvgAggregateOutputType | null
    _sum: DepositSumAggregateOutputType | null
    _min: DepositMinAggregateOutputType | null
    _max: DepositMaxAggregateOutputType | null
  }

  type GetDepositGroupByPayload<T extends DepositGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositGroupByOutputType[P]>
            : GetScalarType<T[P], DepositGroupByOutputType[P]>
        }
      >
    >


  export type DepositSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    amount?: boolean
    txId?: boolean
    adminStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    amount?: boolean
    txId?: boolean
    adminStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectScalar = {
    id?: boolean
    userId?: boolean
    symbol?: boolean
    amount?: boolean
    txId?: boolean
    adminStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepositInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepositIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DepositPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deposit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      symbol: string
      amount: Prisma.Decimal
      txId: string | null
      adminStatus: $Enums.ReviewStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deposit"]>
    composites: {}
  }

  type DepositGetPayload<S extends boolean | null | undefined | DepositDefaultArgs> = $Result.GetResult<Prisma.$DepositPayload, S>

  type DepositCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepositFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepositCountAggregateInputType | true
    }

  export interface DepositDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deposit'], meta: { name: 'Deposit' } }
    /**
     * Find zero or one Deposit that matches the filter.
     * @param {DepositFindUniqueArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepositFindUniqueArgs>(args: SelectSubset<T, DepositFindUniqueArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deposit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepositFindUniqueOrThrowArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepositFindUniqueOrThrowArgs>(args: SelectSubset<T, DepositFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deposit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindFirstArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepositFindFirstArgs>(args?: SelectSubset<T, DepositFindFirstArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deposit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindFirstOrThrowArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepositFindFirstOrThrowArgs>(args?: SelectSubset<T, DepositFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deposits
     * const deposits = await prisma.deposit.findMany()
     * 
     * // Get first 10 Deposits
     * const deposits = await prisma.deposit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositWithIdOnly = await prisma.deposit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepositFindManyArgs>(args?: SelectSubset<T, DepositFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deposit.
     * @param {DepositCreateArgs} args - Arguments to create a Deposit.
     * @example
     * // Create one Deposit
     * const Deposit = await prisma.deposit.create({
     *   data: {
     *     // ... data to create a Deposit
     *   }
     * })
     * 
     */
    create<T extends DepositCreateArgs>(args: SelectSubset<T, DepositCreateArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deposits.
     * @param {DepositCreateManyArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposit = await prisma.deposit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepositCreateManyArgs>(args?: SelectSubset<T, DepositCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deposits and returns the data saved in the database.
     * @param {DepositCreateManyAndReturnArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposit = await prisma.deposit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deposits and only return the `id`
     * const depositWithIdOnly = await prisma.deposit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepositCreateManyAndReturnArgs>(args?: SelectSubset<T, DepositCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Deposit.
     * @param {DepositDeleteArgs} args - Arguments to delete one Deposit.
     * @example
     * // Delete one Deposit
     * const Deposit = await prisma.deposit.delete({
     *   where: {
     *     // ... filter to delete one Deposit
     *   }
     * })
     * 
     */
    delete<T extends DepositDeleteArgs>(args: SelectSubset<T, DepositDeleteArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deposit.
     * @param {DepositUpdateArgs} args - Arguments to update one Deposit.
     * @example
     * // Update one Deposit
     * const deposit = await prisma.deposit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepositUpdateArgs>(args: SelectSubset<T, DepositUpdateArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deposits.
     * @param {DepositDeleteManyArgs} args - Arguments to filter Deposits to delete.
     * @example
     * // Delete a few Deposits
     * const { count } = await prisma.deposit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepositDeleteManyArgs>(args?: SelectSubset<T, DepositDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deposits
     * const deposit = await prisma.deposit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepositUpdateManyArgs>(args: SelectSubset<T, DepositUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deposit.
     * @param {DepositUpsertArgs} args - Arguments to update or create a Deposit.
     * @example
     * // Update or create a Deposit
     * const deposit = await prisma.deposit.upsert({
     *   create: {
     *     // ... data to create a Deposit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deposit we want to update
     *   }
     * })
     */
    upsert<T extends DepositUpsertArgs>(args: SelectSubset<T, DepositUpsertArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositCountArgs} args - Arguments to filter Deposits to count.
     * @example
     * // Count the number of Deposits
     * const count = await prisma.deposit.count({
     *   where: {
     *     // ... the filter for the Deposits we want to count
     *   }
     * })
    **/
    count<T extends DepositCountArgs>(
      args?: Subset<T, DepositCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositAggregateArgs>(args: Subset<T, DepositAggregateArgs>): Prisma.PrismaPromise<GetDepositAggregateType<T>>

    /**
     * Group by Deposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositGroupByArgs['orderBy'] }
        : { orderBy?: DepositGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deposit model
   */
  readonly fields: DepositFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deposit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepositClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deposit model
   */ 
  interface DepositFieldRefs {
    readonly id: FieldRef<"Deposit", 'Int'>
    readonly userId: FieldRef<"Deposit", 'Int'>
    readonly symbol: FieldRef<"Deposit", 'String'>
    readonly amount: FieldRef<"Deposit", 'Decimal'>
    readonly txId: FieldRef<"Deposit", 'String'>
    readonly adminStatus: FieldRef<"Deposit", 'ReviewStatus'>
    readonly createdAt: FieldRef<"Deposit", 'DateTime'>
    readonly updatedAt: FieldRef<"Deposit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deposit findUnique
   */
  export type DepositFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit findUniqueOrThrow
   */
  export type DepositFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit findFirst
   */
  export type DepositFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit findFirstOrThrow
   */
  export type DepositFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit findMany
   */
  export type DepositFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposits to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit create
   */
  export type DepositCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The data needed to create a Deposit.
     */
    data: XOR<DepositCreateInput, DepositUncheckedCreateInput>
  }

  /**
   * Deposit createMany
   */
  export type DepositCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deposits.
     */
    data: DepositCreateManyInput | DepositCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deposit createManyAndReturn
   */
  export type DepositCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Deposits.
     */
    data: DepositCreateManyInput | DepositCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deposit update
   */
  export type DepositUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The data needed to update a Deposit.
     */
    data: XOR<DepositUpdateInput, DepositUncheckedUpdateInput>
    /**
     * Choose, which Deposit to update.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit updateMany
   */
  export type DepositUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deposits.
     */
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyInput>
    /**
     * Filter which Deposits to update
     */
    where?: DepositWhereInput
  }

  /**
   * Deposit upsert
   */
  export type DepositUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The filter to search for the Deposit to update in case it exists.
     */
    where: DepositWhereUniqueInput
    /**
     * In case the Deposit found by the `where` argument doesn't exist, create a new Deposit with this data.
     */
    create: XOR<DepositCreateInput, DepositUncheckedCreateInput>
    /**
     * In case the Deposit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepositUpdateInput, DepositUncheckedUpdateInput>
  }

  /**
   * Deposit delete
   */
  export type DepositDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter which Deposit to delete.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit deleteMany
   */
  export type DepositDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposits to delete
     */
    where?: DepositWhereInput
  }

  /**
   * Deposit without action
   */
  export type DepositDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _avg: SupportTicketAvgAggregateOutputType | null
    _sum: SupportTicketSumAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SupportTicketSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: number | null
    userId: number | null
    subject: string | null
    category: string | null
    priority: $Enums.SupportPriority | null
    status: $Enums.SupportStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    subject: string | null
    category: string | null
    priority: $Enums.SupportPriority | null
    status: $Enums.SupportStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    userId: number
    subject: number
    category: number
    priority: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupportTicketAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SupportTicketSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SupportTicketMinAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    category?: true
    priority?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    category?: true
    priority?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    category?: true
    priority?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupportTicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupportTicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _avg?: SupportTicketAvgAggregateInputType
    _sum?: SupportTicketSumAggregateInputType
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: number
    userId: number
    subject: string
    category: string
    priority: $Enums.SupportPriority
    status: $Enums.SupportStatus
    createdAt: Date
    updatedAt: Date
    _count: SupportTicketCountAggregateOutputType | null
    _avg: SupportTicketAvgAggregateOutputType | null
    _sum: SupportTicketSumAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SupportTicket$messagesArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    userId?: boolean
    subject?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SupportTicket$messagesArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$SupportMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      subject: string
      category: string
      priority: $Enums.SupportPriority
      status: $Enums.SupportStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends SupportTicket$messagesArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */ 
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'Int'>
    readonly userId: FieldRef<"SupportTicket", 'Int'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly category: FieldRef<"SupportTicket", 'String'>
    readonly priority: FieldRef<"SupportTicket", 'SupportPriority'>
    readonly status: FieldRef<"SupportTicket", 'SupportStatus'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket.messages
   */
  export type SupportTicket$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    where?: SupportMessageWhereInput
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    cursor?: SupportMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model SupportMessage
   */

  export type AggregateSupportMessage = {
    _count: SupportMessageCountAggregateOutputType | null
    _avg: SupportMessageAvgAggregateOutputType | null
    _sum: SupportMessageSumAggregateOutputType | null
    _min: SupportMessageMinAggregateOutputType | null
    _max: SupportMessageMaxAggregateOutputType | null
  }

  export type SupportMessageAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
  }

  export type SupportMessageSumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
  }

  export type SupportMessageMinAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
    isStaff: boolean | null
    message: string | null
    createdAt: Date | null
  }

  export type SupportMessageMaxAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
    isStaff: boolean | null
    message: string | null
    createdAt: Date | null
  }

  export type SupportMessageCountAggregateOutputType = {
    id: number
    ticketId: number
    userId: number
    isStaff: number
    message: number
    attachments: number
    createdAt: number
    _all: number
  }


  export type SupportMessageAvgAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
  }

  export type SupportMessageSumAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
  }

  export type SupportMessageMinAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    isStaff?: true
    message?: true
    createdAt?: true
  }

  export type SupportMessageMaxAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    isStaff?: true
    message?: true
    createdAt?: true
  }

  export type SupportMessageCountAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    isStaff?: true
    message?: true
    attachments?: true
    createdAt?: true
    _all?: true
  }

  export type SupportMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportMessage to aggregate.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportMessages
    **/
    _count?: true | SupportMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupportMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupportMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportMessageMaxAggregateInputType
  }

  export type GetSupportMessageAggregateType<T extends SupportMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportMessage[P]>
      : GetScalarType<T[P], AggregateSupportMessage[P]>
  }




  export type SupportMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportMessageWhereInput
    orderBy?: SupportMessageOrderByWithAggregationInput | SupportMessageOrderByWithAggregationInput[]
    by: SupportMessageScalarFieldEnum[] | SupportMessageScalarFieldEnum
    having?: SupportMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportMessageCountAggregateInputType | true
    _avg?: SupportMessageAvgAggregateInputType
    _sum?: SupportMessageSumAggregateInputType
    _min?: SupportMessageMinAggregateInputType
    _max?: SupportMessageMaxAggregateInputType
  }

  export type SupportMessageGroupByOutputType = {
    id: number
    ticketId: number
    userId: number | null
    isStaff: boolean
    message: string
    attachments: JsonValue | null
    createdAt: Date
    _count: SupportMessageCountAggregateOutputType | null
    _avg: SupportMessageAvgAggregateOutputType | null
    _sum: SupportMessageSumAggregateOutputType | null
    _min: SupportMessageMinAggregateOutputType | null
    _max: SupportMessageMaxAggregateOutputType | null
  }

  type GetSupportMessageGroupByPayload<T extends SupportMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportMessageGroupByOutputType[P]>
            : GetScalarType<T[P], SupportMessageGroupByOutputType[P]>
        }
      >
    >


  export type SupportMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    isStaff?: boolean
    message?: boolean
    attachments?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | SupportMessage$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportMessage"]>

  export type SupportMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    isStaff?: boolean
    message?: boolean
    attachments?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | SupportMessage$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportMessage"]>

  export type SupportMessageSelectScalar = {
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    isStaff?: boolean
    message?: boolean
    attachments?: boolean
    createdAt?: boolean
  }

  export type SupportMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | SupportMessage$userArgs<ExtArgs>
  }
  export type SupportMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | SupportMessage$userArgs<ExtArgs>
  }

  export type $SupportMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportMessage"
    objects: {
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketId: number
      userId: number | null
      isStaff: boolean
      message: string
      attachments: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["supportMessage"]>
    composites: {}
  }

  type SupportMessageGetPayload<S extends boolean | null | undefined | SupportMessageDefaultArgs> = $Result.GetResult<Prisma.$SupportMessagePayload, S>

  type SupportMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupportMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupportMessageCountAggregateInputType | true
    }

  export interface SupportMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportMessage'], meta: { name: 'SupportMessage' } }
    /**
     * Find zero or one SupportMessage that matches the filter.
     * @param {SupportMessageFindUniqueArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportMessageFindUniqueArgs>(args: SelectSubset<T, SupportMessageFindUniqueArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupportMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupportMessageFindUniqueOrThrowArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupportMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageFindFirstArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportMessageFindFirstArgs>(args?: SelectSubset<T, SupportMessageFindFirstArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupportMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageFindFirstOrThrowArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupportMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportMessages
     * const supportMessages = await prisma.supportMessage.findMany()
     * 
     * // Get first 10 SupportMessages
     * const supportMessages = await prisma.supportMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportMessageWithIdOnly = await prisma.supportMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportMessageFindManyArgs>(args?: SelectSubset<T, SupportMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupportMessage.
     * @param {SupportMessageCreateArgs} args - Arguments to create a SupportMessage.
     * @example
     * // Create one SupportMessage
     * const SupportMessage = await prisma.supportMessage.create({
     *   data: {
     *     // ... data to create a SupportMessage
     *   }
     * })
     * 
     */
    create<T extends SupportMessageCreateArgs>(args: SelectSubset<T, SupportMessageCreateArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupportMessages.
     * @param {SupportMessageCreateManyArgs} args - Arguments to create many SupportMessages.
     * @example
     * // Create many SupportMessages
     * const supportMessage = await prisma.supportMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportMessageCreateManyArgs>(args?: SelectSubset<T, SupportMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportMessages and returns the data saved in the database.
     * @param {SupportMessageCreateManyAndReturnArgs} args - Arguments to create many SupportMessages.
     * @example
     * // Create many SupportMessages
     * const supportMessage = await prisma.supportMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportMessages and only return the `id`
     * const supportMessageWithIdOnly = await prisma.supportMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SupportMessage.
     * @param {SupportMessageDeleteArgs} args - Arguments to delete one SupportMessage.
     * @example
     * // Delete one SupportMessage
     * const SupportMessage = await prisma.supportMessage.delete({
     *   where: {
     *     // ... filter to delete one SupportMessage
     *   }
     * })
     * 
     */
    delete<T extends SupportMessageDeleteArgs>(args: SelectSubset<T, SupportMessageDeleteArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupportMessage.
     * @param {SupportMessageUpdateArgs} args - Arguments to update one SupportMessage.
     * @example
     * // Update one SupportMessage
     * const supportMessage = await prisma.supportMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportMessageUpdateArgs>(args: SelectSubset<T, SupportMessageUpdateArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupportMessages.
     * @param {SupportMessageDeleteManyArgs} args - Arguments to filter SupportMessages to delete.
     * @example
     * // Delete a few SupportMessages
     * const { count } = await prisma.supportMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportMessageDeleteManyArgs>(args?: SelectSubset<T, SupportMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportMessages
     * const supportMessage = await prisma.supportMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportMessageUpdateManyArgs>(args: SelectSubset<T, SupportMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupportMessage.
     * @param {SupportMessageUpsertArgs} args - Arguments to update or create a SupportMessage.
     * @example
     * // Update or create a SupportMessage
     * const supportMessage = await prisma.supportMessage.upsert({
     *   create: {
     *     // ... data to create a SupportMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportMessage we want to update
     *   }
     * })
     */
    upsert<T extends SupportMessageUpsertArgs>(args: SelectSubset<T, SupportMessageUpsertArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupportMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageCountArgs} args - Arguments to filter SupportMessages to count.
     * @example
     * // Count the number of SupportMessages
     * const count = await prisma.supportMessage.count({
     *   where: {
     *     // ... the filter for the SupportMessages we want to count
     *   }
     * })
    **/
    count<T extends SupportMessageCountArgs>(
      args?: Subset<T, SupportMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportMessageAggregateArgs>(args: Subset<T, SupportMessageAggregateArgs>): Prisma.PrismaPromise<GetSupportMessageAggregateType<T>>

    /**
     * Group by SupportMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportMessageGroupByArgs['orderBy'] }
        : { orderBy?: SupportMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportMessage model
   */
  readonly fields: SupportMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends SupportMessage$userArgs<ExtArgs> = {}>(args?: Subset<T, SupportMessage$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportMessage model
   */ 
  interface SupportMessageFieldRefs {
    readonly id: FieldRef<"SupportMessage", 'Int'>
    readonly ticketId: FieldRef<"SupportMessage", 'Int'>
    readonly userId: FieldRef<"SupportMessage", 'Int'>
    readonly isStaff: FieldRef<"SupportMessage", 'Boolean'>
    readonly message: FieldRef<"SupportMessage", 'String'>
    readonly attachments: FieldRef<"SupportMessage", 'Json'>
    readonly createdAt: FieldRef<"SupportMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportMessage findUnique
   */
  export type SupportMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage findUniqueOrThrow
   */
  export type SupportMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage findFirst
   */
  export type SupportMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportMessages.
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportMessages.
     */
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportMessage findFirstOrThrow
   */
  export type SupportMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportMessages.
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportMessages.
     */
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportMessage findMany
   */
  export type SupportMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessages to fetch.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportMessages.
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportMessage create
   */
  export type SupportMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportMessage.
     */
    data: XOR<SupportMessageCreateInput, SupportMessageUncheckedCreateInput>
  }

  /**
   * SupportMessage createMany
   */
  export type SupportMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportMessages.
     */
    data: SupportMessageCreateManyInput | SupportMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportMessage createManyAndReturn
   */
  export type SupportMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SupportMessages.
     */
    data: SupportMessageCreateManyInput | SupportMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportMessage update
   */
  export type SupportMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportMessage.
     */
    data: XOR<SupportMessageUpdateInput, SupportMessageUncheckedUpdateInput>
    /**
     * Choose, which SupportMessage to update.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage updateMany
   */
  export type SupportMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportMessages.
     */
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyInput>
    /**
     * Filter which SupportMessages to update
     */
    where?: SupportMessageWhereInput
  }

  /**
   * SupportMessage upsert
   */
  export type SupportMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportMessage to update in case it exists.
     */
    where: SupportMessageWhereUniqueInput
    /**
     * In case the SupportMessage found by the `where` argument doesn't exist, create a new SupportMessage with this data.
     */
    create: XOR<SupportMessageCreateInput, SupportMessageUncheckedCreateInput>
    /**
     * In case the SupportMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportMessageUpdateInput, SupportMessageUncheckedUpdateInput>
  }

  /**
   * SupportMessage delete
   */
  export type SupportMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter which SupportMessage to delete.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage deleteMany
   */
  export type SupportMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportMessages to delete
     */
    where?: SupportMessageWhereInput
  }

  /**
   * SupportMessage.user
   */
  export type SupportMessage$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportMessage without action
   */
  export type SupportMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
  }


  /**
   * Model AdminAudit
   */

  export type AggregateAdminAudit = {
    _count: AdminAuditCountAggregateOutputType | null
    _avg: AdminAuditAvgAggregateOutputType | null
    _sum: AdminAuditSumAggregateOutputType | null
    _min: AdminAuditMinAggregateOutputType | null
    _max: AdminAuditMaxAggregateOutputType | null
  }

  export type AdminAuditAvgAggregateOutputType = {
    id: number | null
    adminId: number | null
    entityId: number | null
  }

  export type AdminAuditSumAggregateOutputType = {
    id: number | null
    adminId: number | null
    entityId: number | null
  }

  export type AdminAuditMinAggregateOutputType = {
    id: number | null
    adminId: number | null
    entity: string | null
    entityId: number | null
    action: $Enums.AdminAction | null
    createdAt: Date | null
  }

  export type AdminAuditMaxAggregateOutputType = {
    id: number | null
    adminId: number | null
    entity: string | null
    entityId: number | null
    action: $Enums.AdminAction | null
    createdAt: Date | null
  }

  export type AdminAuditCountAggregateOutputType = {
    id: number
    adminId: number
    entity: number
    entityId: number
    action: number
    meta: number
    createdAt: number
    _all: number
  }


  export type AdminAuditAvgAggregateInputType = {
    id?: true
    adminId?: true
    entityId?: true
  }

  export type AdminAuditSumAggregateInputType = {
    id?: true
    adminId?: true
    entityId?: true
  }

  export type AdminAuditMinAggregateInputType = {
    id?: true
    adminId?: true
    entity?: true
    entityId?: true
    action?: true
    createdAt?: true
  }

  export type AdminAuditMaxAggregateInputType = {
    id?: true
    adminId?: true
    entity?: true
    entityId?: true
    action?: true
    createdAt?: true
  }

  export type AdminAuditCountAggregateInputType = {
    id?: true
    adminId?: true
    entity?: true
    entityId?: true
    action?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAudit to aggregate.
     */
    where?: AdminAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAudits to fetch.
     */
    orderBy?: AdminAuditOrderByWithRelationInput | AdminAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAudits
    **/
    _count?: true | AdminAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAuditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminAuditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditMaxAggregateInputType
  }

  export type GetAdminAuditAggregateType<T extends AdminAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAudit[P]>
      : GetScalarType<T[P], AggregateAdminAudit[P]>
  }




  export type AdminAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditWhereInput
    orderBy?: AdminAuditOrderByWithAggregationInput | AdminAuditOrderByWithAggregationInput[]
    by: AdminAuditScalarFieldEnum[] | AdminAuditScalarFieldEnum
    having?: AdminAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditCountAggregateInputType | true
    _avg?: AdminAuditAvgAggregateInputType
    _sum?: AdminAuditSumAggregateInputType
    _min?: AdminAuditMinAggregateInputType
    _max?: AdminAuditMaxAggregateInputType
  }

  export type AdminAuditGroupByOutputType = {
    id: number
    adminId: number | null
    entity: string
    entityId: number
    action: $Enums.AdminAction
    meta: JsonValue | null
    createdAt: Date
    _count: AdminAuditCountAggregateOutputType | null
    _avg: AdminAuditAvgAggregateOutputType | null
    _sum: AdminAuditSumAggregateOutputType | null
    _min: AdminAuditMinAggregateOutputType | null
    _max: AdminAuditMaxAggregateOutputType | null
  }

  type GetAdminAuditGroupByPayload<T extends AdminAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    meta?: boolean
    createdAt?: boolean
    admin?: boolean | AdminAudit$adminArgs<ExtArgs>
  }, ExtArgs["result"]["adminAudit"]>

  export type AdminAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    meta?: boolean
    createdAt?: boolean
    admin?: boolean | AdminAudit$adminArgs<ExtArgs>
  }, ExtArgs["result"]["adminAudit"]>

  export type AdminAuditSelectScalar = {
    id?: boolean
    adminId?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type AdminAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminAudit$adminArgs<ExtArgs>
  }
  export type AdminAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminAudit$adminArgs<ExtArgs>
  }

  export type $AdminAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAudit"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adminId: number | null
      entity: string
      entityId: number
      action: $Enums.AdminAction
      meta: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["adminAudit"]>
    composites: {}
  }

  type AdminAuditGetPayload<S extends boolean | null | undefined | AdminAuditDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditPayload, S>

  type AdminAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminAuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminAuditCountAggregateInputType | true
    }

  export interface AdminAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAudit'], meta: { name: 'AdminAudit' } }
    /**
     * Find zero or one AdminAudit that matches the filter.
     * @param {AdminAuditFindUniqueArgs} args - Arguments to find a AdminAudit
     * @example
     * // Get one AdminAudit
     * const adminAudit = await prisma.adminAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditFindUniqueArgs>(args: SelectSubset<T, AdminAuditFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminAudit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminAuditFindUniqueOrThrowArgs} args - Arguments to find a AdminAudit
     * @example
     * // Get one AdminAudit
     * const adminAudit = await prisma.adminAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditFindFirstArgs} args - Arguments to find a AdminAudit
     * @example
     * // Get one AdminAudit
     * const adminAudit = await prisma.adminAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditFindFirstArgs>(args?: SelectSubset<T, AdminAuditFindFirstArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditFindFirstOrThrowArgs} args - Arguments to find a AdminAudit
     * @example
     * // Get one AdminAudit
     * const adminAudit = await prisma.adminAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAudits
     * const adminAudits = await prisma.adminAudit.findMany()
     * 
     * // Get first 10 AdminAudits
     * const adminAudits = await prisma.adminAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditWithIdOnly = await prisma.adminAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditFindManyArgs>(args?: SelectSubset<T, AdminAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminAudit.
     * @param {AdminAuditCreateArgs} args - Arguments to create a AdminAudit.
     * @example
     * // Create one AdminAudit
     * const AdminAudit = await prisma.adminAudit.create({
     *   data: {
     *     // ... data to create a AdminAudit
     *   }
     * })
     * 
     */
    create<T extends AdminAuditCreateArgs>(args: SelectSubset<T, AdminAuditCreateArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminAudits.
     * @param {AdminAuditCreateManyArgs} args - Arguments to create many AdminAudits.
     * @example
     * // Create many AdminAudits
     * const adminAudit = await prisma.adminAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditCreateManyArgs>(args?: SelectSubset<T, AdminAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAudits and returns the data saved in the database.
     * @param {AdminAuditCreateManyAndReturnArgs} args - Arguments to create many AdminAudits.
     * @example
     * // Create many AdminAudits
     * const adminAudit = await prisma.adminAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAudits and only return the `id`
     * const adminAuditWithIdOnly = await prisma.adminAudit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminAudit.
     * @param {AdminAuditDeleteArgs} args - Arguments to delete one AdminAudit.
     * @example
     * // Delete one AdminAudit
     * const AdminAudit = await prisma.adminAudit.delete({
     *   where: {
     *     // ... filter to delete one AdminAudit
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditDeleteArgs>(args: SelectSubset<T, AdminAuditDeleteArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminAudit.
     * @param {AdminAuditUpdateArgs} args - Arguments to update one AdminAudit.
     * @example
     * // Update one AdminAudit
     * const adminAudit = await prisma.adminAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditUpdateArgs>(args: SelectSubset<T, AdminAuditUpdateArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminAudits.
     * @param {AdminAuditDeleteManyArgs} args - Arguments to filter AdminAudits to delete.
     * @example
     * // Delete a few AdminAudits
     * const { count } = await prisma.adminAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditDeleteManyArgs>(args?: SelectSubset<T, AdminAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAudits
     * const adminAudit = await prisma.adminAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditUpdateManyArgs>(args: SelectSubset<T, AdminAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminAudit.
     * @param {AdminAuditUpsertArgs} args - Arguments to update or create a AdminAudit.
     * @example
     * // Update or create a AdminAudit
     * const adminAudit = await prisma.adminAudit.upsert({
     *   create: {
     *     // ... data to create a AdminAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAudit we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditUpsertArgs>(args: SelectSubset<T, AdminAuditUpsertArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditCountArgs} args - Arguments to filter AdminAudits to count.
     * @example
     * // Count the number of AdminAudits
     * const count = await prisma.adminAudit.count({
     *   where: {
     *     // ... the filter for the AdminAudits we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditCountArgs>(
      args?: Subset<T, AdminAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditAggregateArgs>(args: Subset<T, AdminAuditAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditAggregateType<T>>

    /**
     * Group by AdminAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAudit model
   */
  readonly fields: AdminAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminAudit$adminArgs<ExtArgs> = {}>(args?: Subset<T, AdminAudit$adminArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAudit model
   */ 
  interface AdminAuditFieldRefs {
    readonly id: FieldRef<"AdminAudit", 'Int'>
    readonly adminId: FieldRef<"AdminAudit", 'Int'>
    readonly entity: FieldRef<"AdminAudit", 'String'>
    readonly entityId: FieldRef<"AdminAudit", 'Int'>
    readonly action: FieldRef<"AdminAudit", 'AdminAction'>
    readonly meta: FieldRef<"AdminAudit", 'Json'>
    readonly createdAt: FieldRef<"AdminAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAudit findUnique
   */
  export type AdminAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    /**
     * Filter, which AdminAudit to fetch.
     */
    where: AdminAuditWhereUniqueInput
  }

  /**
   * AdminAudit findUniqueOrThrow
   */
  export type AdminAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    /**
     * Filter, which AdminAudit to fetch.
     */
    where: AdminAuditWhereUniqueInput
  }

  /**
   * AdminAudit findFirst
   */
  export type AdminAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    /**
     * Filter, which AdminAudit to fetch.
     */
    where?: AdminAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAudits to fetch.
     */
    orderBy?: AdminAuditOrderByWithRelationInput | AdminAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAudits.
     */
    cursor?: AdminAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAudits.
     */
    distinct?: AdminAuditScalarFieldEnum | AdminAuditScalarFieldEnum[]
  }

  /**
   * AdminAudit findFirstOrThrow
   */
  export type AdminAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    /**
     * Filter, which AdminAudit to fetch.
     */
    where?: AdminAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAudits to fetch.
     */
    orderBy?: AdminAuditOrderByWithRelationInput | AdminAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAudits.
     */
    cursor?: AdminAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAudits.
     */
    distinct?: AdminAuditScalarFieldEnum | AdminAuditScalarFieldEnum[]
  }

  /**
   * AdminAudit findMany
   */
  export type AdminAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    /**
     * Filter, which AdminAudits to fetch.
     */
    where?: AdminAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAudits to fetch.
     */
    orderBy?: AdminAuditOrderByWithRelationInput | AdminAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAudits.
     */
    cursor?: AdminAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAudits.
     */
    skip?: number
    distinct?: AdminAuditScalarFieldEnum | AdminAuditScalarFieldEnum[]
  }

  /**
   * AdminAudit create
   */
  export type AdminAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAudit.
     */
    data: XOR<AdminAuditCreateInput, AdminAuditUncheckedCreateInput>
  }

  /**
   * AdminAudit createMany
   */
  export type AdminAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAudits.
     */
    data: AdminAuditCreateManyInput | AdminAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAudit createManyAndReturn
   */
  export type AdminAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminAudits.
     */
    data: AdminAuditCreateManyInput | AdminAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAudit update
   */
  export type AdminAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAudit.
     */
    data: XOR<AdminAuditUpdateInput, AdminAuditUncheckedUpdateInput>
    /**
     * Choose, which AdminAudit to update.
     */
    where: AdminAuditWhereUniqueInput
  }

  /**
   * AdminAudit updateMany
   */
  export type AdminAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAudits.
     */
    data: XOR<AdminAuditUpdateManyMutationInput, AdminAuditUncheckedUpdateManyInput>
    /**
     * Filter which AdminAudits to update
     */
    where?: AdminAuditWhereInput
  }

  /**
   * AdminAudit upsert
   */
  export type AdminAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAudit to update in case it exists.
     */
    where: AdminAuditWhereUniqueInput
    /**
     * In case the AdminAudit found by the `where` argument doesn't exist, create a new AdminAudit with this data.
     */
    create: XOR<AdminAuditCreateInput, AdminAuditUncheckedCreateInput>
    /**
     * In case the AdminAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditUpdateInput, AdminAuditUncheckedUpdateInput>
  }

  /**
   * AdminAudit delete
   */
  export type AdminAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
    /**
     * Filter which AdminAudit to delete.
     */
    where: AdminAuditWhereUniqueInput
  }

  /**
   * AdminAudit deleteMany
   */
  export type AdminAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAudits to delete
     */
    where?: AdminAuditWhereInput
  }

  /**
   * AdminAudit.admin
   */
  export type AdminAudit$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AdminAudit without action
   */
  export type AdminAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditInclude<ExtArgs> | null
  }


  /**
   * Model KycSubmission
   */

  export type AggregateKycSubmission = {
    _count: KycSubmissionCountAggregateOutputType | null
    _avg: KycSubmissionAvgAggregateOutputType | null
    _sum: KycSubmissionSumAggregateOutputType | null
    _min: KycSubmissionMinAggregateOutputType | null
    _max: KycSubmissionMaxAggregateOutputType | null
  }

  export type KycSubmissionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type KycSubmissionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type KycSubmissionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    country: string | null
    docType: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    email: string | null
    phone: string | null
    address: string | null
    status: $Enums.KycStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KycSubmissionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    country: string | null
    docType: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    email: string | null
    phone: string | null
    address: string | null
    status: $Enums.KycStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KycSubmissionCountAggregateOutputType = {
    id: number
    userId: number
    country: number
    docType: number
    firstName: number
    lastName: number
    dob: number
    email: number
    phone: number
    address: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KycSubmissionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type KycSubmissionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type KycSubmissionMinAggregateInputType = {
    id?: true
    userId?: true
    country?: true
    docType?: true
    firstName?: true
    lastName?: true
    dob?: true
    email?: true
    phone?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KycSubmissionMaxAggregateInputType = {
    id?: true
    userId?: true
    country?: true
    docType?: true
    firstName?: true
    lastName?: true
    dob?: true
    email?: true
    phone?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KycSubmissionCountAggregateInputType = {
    id?: true
    userId?: true
    country?: true
    docType?: true
    firstName?: true
    lastName?: true
    dob?: true
    email?: true
    phone?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KycSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KycSubmission to aggregate.
     */
    where?: KycSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycSubmissions to fetch.
     */
    orderBy?: KycSubmissionOrderByWithRelationInput | KycSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KycSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KycSubmissions
    **/
    _count?: true | KycSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KycSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KycSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KycSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KycSubmissionMaxAggregateInputType
  }

  export type GetKycSubmissionAggregateType<T extends KycSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateKycSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKycSubmission[P]>
      : GetScalarType<T[P], AggregateKycSubmission[P]>
  }




  export type KycSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KycSubmissionWhereInput
    orderBy?: KycSubmissionOrderByWithAggregationInput | KycSubmissionOrderByWithAggregationInput[]
    by: KycSubmissionScalarFieldEnum[] | KycSubmissionScalarFieldEnum
    having?: KycSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KycSubmissionCountAggregateInputType | true
    _avg?: KycSubmissionAvgAggregateInputType
    _sum?: KycSubmissionSumAggregateInputType
    _min?: KycSubmissionMinAggregateInputType
    _max?: KycSubmissionMaxAggregateInputType
  }

  export type KycSubmissionGroupByOutputType = {
    id: number
    userId: number
    country: string | null
    docType: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    email: string | null
    phone: string | null
    address: string | null
    status: $Enums.KycStatus
    createdAt: Date
    updatedAt: Date
    _count: KycSubmissionCountAggregateOutputType | null
    _avg: KycSubmissionAvgAggregateOutputType | null
    _sum: KycSubmissionSumAggregateOutputType | null
    _min: KycSubmissionMinAggregateOutputType | null
    _max: KycSubmissionMaxAggregateOutputType | null
  }

  type GetKycSubmissionGroupByPayload<T extends KycSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KycSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KycSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KycSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], KycSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type KycSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    country?: boolean
    docType?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | KycSubmission$filesArgs<ExtArgs>
    _count?: boolean | KycSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kycSubmission"]>

  export type KycSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    country?: boolean
    docType?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kycSubmission"]>

  export type KycSubmissionSelectScalar = {
    id?: boolean
    userId?: boolean
    country?: boolean
    docType?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KycSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | KycSubmission$filesArgs<ExtArgs>
    _count?: boolean | KycSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KycSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KycSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KycSubmission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      files: Prisma.$KycFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      country: string | null
      docType: string | null
      firstName: string | null
      lastName: string | null
      dob: Date | null
      email: string | null
      phone: string | null
      address: string | null
      status: $Enums.KycStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kycSubmission"]>
    composites: {}
  }

  type KycSubmissionGetPayload<S extends boolean | null | undefined | KycSubmissionDefaultArgs> = $Result.GetResult<Prisma.$KycSubmissionPayload, S>

  type KycSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KycSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KycSubmissionCountAggregateInputType | true
    }

  export interface KycSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KycSubmission'], meta: { name: 'KycSubmission' } }
    /**
     * Find zero or one KycSubmission that matches the filter.
     * @param {KycSubmissionFindUniqueArgs} args - Arguments to find a KycSubmission
     * @example
     * // Get one KycSubmission
     * const kycSubmission = await prisma.kycSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KycSubmissionFindUniqueArgs>(args: SelectSubset<T, KycSubmissionFindUniqueArgs<ExtArgs>>): Prisma__KycSubmissionClient<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KycSubmission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KycSubmissionFindUniqueOrThrowArgs} args - Arguments to find a KycSubmission
     * @example
     * // Get one KycSubmission
     * const kycSubmission = await prisma.kycSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KycSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, KycSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KycSubmissionClient<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KycSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycSubmissionFindFirstArgs} args - Arguments to find a KycSubmission
     * @example
     * // Get one KycSubmission
     * const kycSubmission = await prisma.kycSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KycSubmissionFindFirstArgs>(args?: SelectSubset<T, KycSubmissionFindFirstArgs<ExtArgs>>): Prisma__KycSubmissionClient<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KycSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycSubmissionFindFirstOrThrowArgs} args - Arguments to find a KycSubmission
     * @example
     * // Get one KycSubmission
     * const kycSubmission = await prisma.kycSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KycSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, KycSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__KycSubmissionClient<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KycSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KycSubmissions
     * const kycSubmissions = await prisma.kycSubmission.findMany()
     * 
     * // Get first 10 KycSubmissions
     * const kycSubmissions = await prisma.kycSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kycSubmissionWithIdOnly = await prisma.kycSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KycSubmissionFindManyArgs>(args?: SelectSubset<T, KycSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KycSubmission.
     * @param {KycSubmissionCreateArgs} args - Arguments to create a KycSubmission.
     * @example
     * // Create one KycSubmission
     * const KycSubmission = await prisma.kycSubmission.create({
     *   data: {
     *     // ... data to create a KycSubmission
     *   }
     * })
     * 
     */
    create<T extends KycSubmissionCreateArgs>(args: SelectSubset<T, KycSubmissionCreateArgs<ExtArgs>>): Prisma__KycSubmissionClient<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KycSubmissions.
     * @param {KycSubmissionCreateManyArgs} args - Arguments to create many KycSubmissions.
     * @example
     * // Create many KycSubmissions
     * const kycSubmission = await prisma.kycSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KycSubmissionCreateManyArgs>(args?: SelectSubset<T, KycSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KycSubmissions and returns the data saved in the database.
     * @param {KycSubmissionCreateManyAndReturnArgs} args - Arguments to create many KycSubmissions.
     * @example
     * // Create many KycSubmissions
     * const kycSubmission = await prisma.kycSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KycSubmissions and only return the `id`
     * const kycSubmissionWithIdOnly = await prisma.kycSubmission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KycSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, KycSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KycSubmission.
     * @param {KycSubmissionDeleteArgs} args - Arguments to delete one KycSubmission.
     * @example
     * // Delete one KycSubmission
     * const KycSubmission = await prisma.kycSubmission.delete({
     *   where: {
     *     // ... filter to delete one KycSubmission
     *   }
     * })
     * 
     */
    delete<T extends KycSubmissionDeleteArgs>(args: SelectSubset<T, KycSubmissionDeleteArgs<ExtArgs>>): Prisma__KycSubmissionClient<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KycSubmission.
     * @param {KycSubmissionUpdateArgs} args - Arguments to update one KycSubmission.
     * @example
     * // Update one KycSubmission
     * const kycSubmission = await prisma.kycSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KycSubmissionUpdateArgs>(args: SelectSubset<T, KycSubmissionUpdateArgs<ExtArgs>>): Prisma__KycSubmissionClient<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KycSubmissions.
     * @param {KycSubmissionDeleteManyArgs} args - Arguments to filter KycSubmissions to delete.
     * @example
     * // Delete a few KycSubmissions
     * const { count } = await prisma.kycSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KycSubmissionDeleteManyArgs>(args?: SelectSubset<T, KycSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KycSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KycSubmissions
     * const kycSubmission = await prisma.kycSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KycSubmissionUpdateManyArgs>(args: SelectSubset<T, KycSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KycSubmission.
     * @param {KycSubmissionUpsertArgs} args - Arguments to update or create a KycSubmission.
     * @example
     * // Update or create a KycSubmission
     * const kycSubmission = await prisma.kycSubmission.upsert({
     *   create: {
     *     // ... data to create a KycSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KycSubmission we want to update
     *   }
     * })
     */
    upsert<T extends KycSubmissionUpsertArgs>(args: SelectSubset<T, KycSubmissionUpsertArgs<ExtArgs>>): Prisma__KycSubmissionClient<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KycSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycSubmissionCountArgs} args - Arguments to filter KycSubmissions to count.
     * @example
     * // Count the number of KycSubmissions
     * const count = await prisma.kycSubmission.count({
     *   where: {
     *     // ... the filter for the KycSubmissions we want to count
     *   }
     * })
    **/
    count<T extends KycSubmissionCountArgs>(
      args?: Subset<T, KycSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KycSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KycSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KycSubmissionAggregateArgs>(args: Subset<T, KycSubmissionAggregateArgs>): Prisma.PrismaPromise<GetKycSubmissionAggregateType<T>>

    /**
     * Group by KycSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KycSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KycSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: KycSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KycSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKycSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KycSubmission model
   */
  readonly fields: KycSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KycSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KycSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    files<T extends KycSubmission$filesArgs<ExtArgs> = {}>(args?: Subset<T, KycSubmission$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KycSubmission model
   */ 
  interface KycSubmissionFieldRefs {
    readonly id: FieldRef<"KycSubmission", 'Int'>
    readonly userId: FieldRef<"KycSubmission", 'Int'>
    readonly country: FieldRef<"KycSubmission", 'String'>
    readonly docType: FieldRef<"KycSubmission", 'String'>
    readonly firstName: FieldRef<"KycSubmission", 'String'>
    readonly lastName: FieldRef<"KycSubmission", 'String'>
    readonly dob: FieldRef<"KycSubmission", 'DateTime'>
    readonly email: FieldRef<"KycSubmission", 'String'>
    readonly phone: FieldRef<"KycSubmission", 'String'>
    readonly address: FieldRef<"KycSubmission", 'String'>
    readonly status: FieldRef<"KycSubmission", 'KycStatus'>
    readonly createdAt: FieldRef<"KycSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"KycSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KycSubmission findUnique
   */
  export type KycSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which KycSubmission to fetch.
     */
    where: KycSubmissionWhereUniqueInput
  }

  /**
   * KycSubmission findUniqueOrThrow
   */
  export type KycSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which KycSubmission to fetch.
     */
    where: KycSubmissionWhereUniqueInput
  }

  /**
   * KycSubmission findFirst
   */
  export type KycSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which KycSubmission to fetch.
     */
    where?: KycSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycSubmissions to fetch.
     */
    orderBy?: KycSubmissionOrderByWithRelationInput | KycSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KycSubmissions.
     */
    cursor?: KycSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KycSubmissions.
     */
    distinct?: KycSubmissionScalarFieldEnum | KycSubmissionScalarFieldEnum[]
  }

  /**
   * KycSubmission findFirstOrThrow
   */
  export type KycSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which KycSubmission to fetch.
     */
    where?: KycSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycSubmissions to fetch.
     */
    orderBy?: KycSubmissionOrderByWithRelationInput | KycSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KycSubmissions.
     */
    cursor?: KycSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KycSubmissions.
     */
    distinct?: KycSubmissionScalarFieldEnum | KycSubmissionScalarFieldEnum[]
  }

  /**
   * KycSubmission findMany
   */
  export type KycSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which KycSubmissions to fetch.
     */
    where?: KycSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycSubmissions to fetch.
     */
    orderBy?: KycSubmissionOrderByWithRelationInput | KycSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KycSubmissions.
     */
    cursor?: KycSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycSubmissions.
     */
    skip?: number
    distinct?: KycSubmissionScalarFieldEnum | KycSubmissionScalarFieldEnum[]
  }

  /**
   * KycSubmission create
   */
  export type KycSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a KycSubmission.
     */
    data: XOR<KycSubmissionCreateInput, KycSubmissionUncheckedCreateInput>
  }

  /**
   * KycSubmission createMany
   */
  export type KycSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KycSubmissions.
     */
    data: KycSubmissionCreateManyInput | KycSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KycSubmission createManyAndReturn
   */
  export type KycSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KycSubmissions.
     */
    data: KycSubmissionCreateManyInput | KycSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KycSubmission update
   */
  export type KycSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a KycSubmission.
     */
    data: XOR<KycSubmissionUpdateInput, KycSubmissionUncheckedUpdateInput>
    /**
     * Choose, which KycSubmission to update.
     */
    where: KycSubmissionWhereUniqueInput
  }

  /**
   * KycSubmission updateMany
   */
  export type KycSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KycSubmissions.
     */
    data: XOR<KycSubmissionUpdateManyMutationInput, KycSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which KycSubmissions to update
     */
    where?: KycSubmissionWhereInput
  }

  /**
   * KycSubmission upsert
   */
  export type KycSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the KycSubmission to update in case it exists.
     */
    where: KycSubmissionWhereUniqueInput
    /**
     * In case the KycSubmission found by the `where` argument doesn't exist, create a new KycSubmission with this data.
     */
    create: XOR<KycSubmissionCreateInput, KycSubmissionUncheckedCreateInput>
    /**
     * In case the KycSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KycSubmissionUpdateInput, KycSubmissionUncheckedUpdateInput>
  }

  /**
   * KycSubmission delete
   */
  export type KycSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
    /**
     * Filter which KycSubmission to delete.
     */
    where: KycSubmissionWhereUniqueInput
  }

  /**
   * KycSubmission deleteMany
   */
  export type KycSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KycSubmissions to delete
     */
    where?: KycSubmissionWhereInput
  }

  /**
   * KycSubmission.files
   */
  export type KycSubmission$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    where?: KycFileWhereInput
    orderBy?: KycFileOrderByWithRelationInput | KycFileOrderByWithRelationInput[]
    cursor?: KycFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KycFileScalarFieldEnum | KycFileScalarFieldEnum[]
  }

  /**
   * KycSubmission without action
   */
  export type KycSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycSubmission
     */
    select?: KycSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model KycFile
   */

  export type AggregateKycFile = {
    _count: KycFileCountAggregateOutputType | null
    _avg: KycFileAvgAggregateOutputType | null
    _sum: KycFileSumAggregateOutputType | null
    _min: KycFileMinAggregateOutputType | null
    _max: KycFileMaxAggregateOutputType | null
  }

  export type KycFileAvgAggregateOutputType = {
    id: number | null
    submissionId: number | null
    size: number | null
  }

  export type KycFileSumAggregateOutputType = {
    id: number | null
    submissionId: number | null
    size: number | null
  }

  export type KycFileMinAggregateOutputType = {
    id: number | null
    submissionId: number | null
    kind: string | null
    path: string | null
    original: string | null
    mime: string | null
    size: number | null
    data: Buffer | null
    createdAt: Date | null
  }

  export type KycFileMaxAggregateOutputType = {
    id: number | null
    submissionId: number | null
    kind: string | null
    path: string | null
    original: string | null
    mime: string | null
    size: number | null
    data: Buffer | null
    createdAt: Date | null
  }

  export type KycFileCountAggregateOutputType = {
    id: number
    submissionId: number
    kind: number
    path: number
    original: number
    mime: number
    size: number
    data: number
    createdAt: number
    _all: number
  }


  export type KycFileAvgAggregateInputType = {
    id?: true
    submissionId?: true
    size?: true
  }

  export type KycFileSumAggregateInputType = {
    id?: true
    submissionId?: true
    size?: true
  }

  export type KycFileMinAggregateInputType = {
    id?: true
    submissionId?: true
    kind?: true
    path?: true
    original?: true
    mime?: true
    size?: true
    data?: true
    createdAt?: true
  }

  export type KycFileMaxAggregateInputType = {
    id?: true
    submissionId?: true
    kind?: true
    path?: true
    original?: true
    mime?: true
    size?: true
    data?: true
    createdAt?: true
  }

  export type KycFileCountAggregateInputType = {
    id?: true
    submissionId?: true
    kind?: true
    path?: true
    original?: true
    mime?: true
    size?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type KycFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KycFile to aggregate.
     */
    where?: KycFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycFiles to fetch.
     */
    orderBy?: KycFileOrderByWithRelationInput | KycFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KycFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KycFiles
    **/
    _count?: true | KycFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KycFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KycFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KycFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KycFileMaxAggregateInputType
  }

  export type GetKycFileAggregateType<T extends KycFileAggregateArgs> = {
        [P in keyof T & keyof AggregateKycFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKycFile[P]>
      : GetScalarType<T[P], AggregateKycFile[P]>
  }




  export type KycFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KycFileWhereInput
    orderBy?: KycFileOrderByWithAggregationInput | KycFileOrderByWithAggregationInput[]
    by: KycFileScalarFieldEnum[] | KycFileScalarFieldEnum
    having?: KycFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KycFileCountAggregateInputType | true
    _avg?: KycFileAvgAggregateInputType
    _sum?: KycFileSumAggregateInputType
    _min?: KycFileMinAggregateInputType
    _max?: KycFileMaxAggregateInputType
  }

  export type KycFileGroupByOutputType = {
    id: number
    submissionId: number
    kind: string
    path: string
    original: string
    mime: string
    size: number
    data: Buffer | null
    createdAt: Date
    _count: KycFileCountAggregateOutputType | null
    _avg: KycFileAvgAggregateOutputType | null
    _sum: KycFileSumAggregateOutputType | null
    _min: KycFileMinAggregateOutputType | null
    _max: KycFileMaxAggregateOutputType | null
  }

  type GetKycFileGroupByPayload<T extends KycFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KycFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KycFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KycFileGroupByOutputType[P]>
            : GetScalarType<T[P], KycFileGroupByOutputType[P]>
        }
      >
    >


  export type KycFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submissionId?: boolean
    kind?: boolean
    path?: boolean
    original?: boolean
    mime?: boolean
    size?: boolean
    data?: boolean
    createdAt?: boolean
    submission?: boolean | KycSubmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kycFile"]>

  export type KycFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submissionId?: boolean
    kind?: boolean
    path?: boolean
    original?: boolean
    mime?: boolean
    size?: boolean
    data?: boolean
    createdAt?: boolean
    submission?: boolean | KycSubmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kycFile"]>

  export type KycFileSelectScalar = {
    id?: boolean
    submissionId?: boolean
    kind?: boolean
    path?: boolean
    original?: boolean
    mime?: boolean
    size?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type KycFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | KycSubmissionDefaultArgs<ExtArgs>
  }
  export type KycFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | KycSubmissionDefaultArgs<ExtArgs>
  }

  export type $KycFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KycFile"
    objects: {
      submission: Prisma.$KycSubmissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      submissionId: number
      kind: string
      path: string
      original: string
      mime: string
      size: number
      data: Buffer | null
      createdAt: Date
    }, ExtArgs["result"]["kycFile"]>
    composites: {}
  }

  type KycFileGetPayload<S extends boolean | null | undefined | KycFileDefaultArgs> = $Result.GetResult<Prisma.$KycFilePayload, S>

  type KycFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KycFileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KycFileCountAggregateInputType | true
    }

  export interface KycFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KycFile'], meta: { name: 'KycFile' } }
    /**
     * Find zero or one KycFile that matches the filter.
     * @param {KycFileFindUniqueArgs} args - Arguments to find a KycFile
     * @example
     * // Get one KycFile
     * const kycFile = await prisma.kycFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KycFileFindUniqueArgs>(args: SelectSubset<T, KycFileFindUniqueArgs<ExtArgs>>): Prisma__KycFileClient<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KycFile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KycFileFindUniqueOrThrowArgs} args - Arguments to find a KycFile
     * @example
     * // Get one KycFile
     * const kycFile = await prisma.kycFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KycFileFindUniqueOrThrowArgs>(args: SelectSubset<T, KycFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KycFileClient<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KycFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFileFindFirstArgs} args - Arguments to find a KycFile
     * @example
     * // Get one KycFile
     * const kycFile = await prisma.kycFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KycFileFindFirstArgs>(args?: SelectSubset<T, KycFileFindFirstArgs<ExtArgs>>): Prisma__KycFileClient<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KycFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFileFindFirstOrThrowArgs} args - Arguments to find a KycFile
     * @example
     * // Get one KycFile
     * const kycFile = await prisma.kycFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KycFileFindFirstOrThrowArgs>(args?: SelectSubset<T, KycFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__KycFileClient<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KycFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KycFiles
     * const kycFiles = await prisma.kycFile.findMany()
     * 
     * // Get first 10 KycFiles
     * const kycFiles = await prisma.kycFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kycFileWithIdOnly = await prisma.kycFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KycFileFindManyArgs>(args?: SelectSubset<T, KycFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KycFile.
     * @param {KycFileCreateArgs} args - Arguments to create a KycFile.
     * @example
     * // Create one KycFile
     * const KycFile = await prisma.kycFile.create({
     *   data: {
     *     // ... data to create a KycFile
     *   }
     * })
     * 
     */
    create<T extends KycFileCreateArgs>(args: SelectSubset<T, KycFileCreateArgs<ExtArgs>>): Prisma__KycFileClient<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KycFiles.
     * @param {KycFileCreateManyArgs} args - Arguments to create many KycFiles.
     * @example
     * // Create many KycFiles
     * const kycFile = await prisma.kycFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KycFileCreateManyArgs>(args?: SelectSubset<T, KycFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KycFiles and returns the data saved in the database.
     * @param {KycFileCreateManyAndReturnArgs} args - Arguments to create many KycFiles.
     * @example
     * // Create many KycFiles
     * const kycFile = await prisma.kycFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KycFiles and only return the `id`
     * const kycFileWithIdOnly = await prisma.kycFile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KycFileCreateManyAndReturnArgs>(args?: SelectSubset<T, KycFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KycFile.
     * @param {KycFileDeleteArgs} args - Arguments to delete one KycFile.
     * @example
     * // Delete one KycFile
     * const KycFile = await prisma.kycFile.delete({
     *   where: {
     *     // ... filter to delete one KycFile
     *   }
     * })
     * 
     */
    delete<T extends KycFileDeleteArgs>(args: SelectSubset<T, KycFileDeleteArgs<ExtArgs>>): Prisma__KycFileClient<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KycFile.
     * @param {KycFileUpdateArgs} args - Arguments to update one KycFile.
     * @example
     * // Update one KycFile
     * const kycFile = await prisma.kycFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KycFileUpdateArgs>(args: SelectSubset<T, KycFileUpdateArgs<ExtArgs>>): Prisma__KycFileClient<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KycFiles.
     * @param {KycFileDeleteManyArgs} args - Arguments to filter KycFiles to delete.
     * @example
     * // Delete a few KycFiles
     * const { count } = await prisma.kycFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KycFileDeleteManyArgs>(args?: SelectSubset<T, KycFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KycFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KycFiles
     * const kycFile = await prisma.kycFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KycFileUpdateManyArgs>(args: SelectSubset<T, KycFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KycFile.
     * @param {KycFileUpsertArgs} args - Arguments to update or create a KycFile.
     * @example
     * // Update or create a KycFile
     * const kycFile = await prisma.kycFile.upsert({
     *   create: {
     *     // ... data to create a KycFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KycFile we want to update
     *   }
     * })
     */
    upsert<T extends KycFileUpsertArgs>(args: SelectSubset<T, KycFileUpsertArgs<ExtArgs>>): Prisma__KycFileClient<$Result.GetResult<Prisma.$KycFilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KycFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFileCountArgs} args - Arguments to filter KycFiles to count.
     * @example
     * // Count the number of KycFiles
     * const count = await prisma.kycFile.count({
     *   where: {
     *     // ... the filter for the KycFiles we want to count
     *   }
     * })
    **/
    count<T extends KycFileCountArgs>(
      args?: Subset<T, KycFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KycFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KycFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KycFileAggregateArgs>(args: Subset<T, KycFileAggregateArgs>): Prisma.PrismaPromise<GetKycFileAggregateType<T>>

    /**
     * Group by KycFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KycFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KycFileGroupByArgs['orderBy'] }
        : { orderBy?: KycFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KycFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKycFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KycFile model
   */
  readonly fields: KycFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KycFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KycFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submission<T extends KycSubmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KycSubmissionDefaultArgs<ExtArgs>>): Prisma__KycSubmissionClient<$Result.GetResult<Prisma.$KycSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KycFile model
   */ 
  interface KycFileFieldRefs {
    readonly id: FieldRef<"KycFile", 'Int'>
    readonly submissionId: FieldRef<"KycFile", 'Int'>
    readonly kind: FieldRef<"KycFile", 'String'>
    readonly path: FieldRef<"KycFile", 'String'>
    readonly original: FieldRef<"KycFile", 'String'>
    readonly mime: FieldRef<"KycFile", 'String'>
    readonly size: FieldRef<"KycFile", 'Int'>
    readonly data: FieldRef<"KycFile", 'Bytes'>
    readonly createdAt: FieldRef<"KycFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KycFile findUnique
   */
  export type KycFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    /**
     * Filter, which KycFile to fetch.
     */
    where: KycFileWhereUniqueInput
  }

  /**
   * KycFile findUniqueOrThrow
   */
  export type KycFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    /**
     * Filter, which KycFile to fetch.
     */
    where: KycFileWhereUniqueInput
  }

  /**
   * KycFile findFirst
   */
  export type KycFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    /**
     * Filter, which KycFile to fetch.
     */
    where?: KycFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycFiles to fetch.
     */
    orderBy?: KycFileOrderByWithRelationInput | KycFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KycFiles.
     */
    cursor?: KycFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KycFiles.
     */
    distinct?: KycFileScalarFieldEnum | KycFileScalarFieldEnum[]
  }

  /**
   * KycFile findFirstOrThrow
   */
  export type KycFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    /**
     * Filter, which KycFile to fetch.
     */
    where?: KycFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycFiles to fetch.
     */
    orderBy?: KycFileOrderByWithRelationInput | KycFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KycFiles.
     */
    cursor?: KycFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KycFiles.
     */
    distinct?: KycFileScalarFieldEnum | KycFileScalarFieldEnum[]
  }

  /**
   * KycFile findMany
   */
  export type KycFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    /**
     * Filter, which KycFiles to fetch.
     */
    where?: KycFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycFiles to fetch.
     */
    orderBy?: KycFileOrderByWithRelationInput | KycFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KycFiles.
     */
    cursor?: KycFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycFiles.
     */
    skip?: number
    distinct?: KycFileScalarFieldEnum | KycFileScalarFieldEnum[]
  }

  /**
   * KycFile create
   */
  export type KycFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    /**
     * The data needed to create a KycFile.
     */
    data: XOR<KycFileCreateInput, KycFileUncheckedCreateInput>
  }

  /**
   * KycFile createMany
   */
  export type KycFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KycFiles.
     */
    data: KycFileCreateManyInput | KycFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KycFile createManyAndReturn
   */
  export type KycFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KycFiles.
     */
    data: KycFileCreateManyInput | KycFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KycFile update
   */
  export type KycFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    /**
     * The data needed to update a KycFile.
     */
    data: XOR<KycFileUpdateInput, KycFileUncheckedUpdateInput>
    /**
     * Choose, which KycFile to update.
     */
    where: KycFileWhereUniqueInput
  }

  /**
   * KycFile updateMany
   */
  export type KycFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KycFiles.
     */
    data: XOR<KycFileUpdateManyMutationInput, KycFileUncheckedUpdateManyInput>
    /**
     * Filter which KycFiles to update
     */
    where?: KycFileWhereInput
  }

  /**
   * KycFile upsert
   */
  export type KycFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    /**
     * The filter to search for the KycFile to update in case it exists.
     */
    where: KycFileWhereUniqueInput
    /**
     * In case the KycFile found by the `where` argument doesn't exist, create a new KycFile with this data.
     */
    create: XOR<KycFileCreateInput, KycFileUncheckedCreateInput>
    /**
     * In case the KycFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KycFileUpdateInput, KycFileUncheckedUpdateInput>
  }

  /**
   * KycFile delete
   */
  export type KycFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
    /**
     * Filter which KycFile to delete.
     */
    where: KycFileWhereUniqueInput
  }

  /**
   * KycFile deleteMany
   */
  export type KycFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KycFiles to delete
     */
    where?: KycFileWhereInput
  }

  /**
   * KycFile without action
   */
  export type KycFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycFile
     */
    select?: KycFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycFileInclude<ExtArgs> | null
  }


  /**
   * Model WalletSync
   */

  export type AggregateWalletSync = {
    _count: WalletSyncCountAggregateOutputType | null
    _avg: WalletSyncAvgAggregateOutputType | null
    _sum: WalletSyncSumAggregateOutputType | null
    _min: WalletSyncMinAggregateOutputType | null
    _max: WalletSyncMaxAggregateOutputType | null
  }

  export type WalletSyncAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type WalletSyncSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type WalletSyncMinAggregateOutputType = {
    id: number | null
    userId: number | null
    walletName: string | null
    method: string | null
    data: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletSyncMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    walletName: string | null
    method: string | null
    data: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletSyncCountAggregateOutputType = {
    id: number
    userId: number
    walletName: number
    method: number
    data: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletSyncAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WalletSyncSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WalletSyncMinAggregateInputType = {
    id?: true
    userId?: true
    walletName?: true
    method?: true
    data?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletSyncMaxAggregateInputType = {
    id?: true
    userId?: true
    walletName?: true
    method?: true
    data?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletSyncCountAggregateInputType = {
    id?: true
    userId?: true
    walletName?: true
    method?: true
    data?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletSyncAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletSync to aggregate.
     */
    where?: WalletSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletSyncs to fetch.
     */
    orderBy?: WalletSyncOrderByWithRelationInput | WalletSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletSyncs
    **/
    _count?: true | WalletSyncCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletSyncAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSyncSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletSyncMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletSyncMaxAggregateInputType
  }

  export type GetWalletSyncAggregateType<T extends WalletSyncAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletSync]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletSync[P]>
      : GetScalarType<T[P], AggregateWalletSync[P]>
  }




  export type WalletSyncGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletSyncWhereInput
    orderBy?: WalletSyncOrderByWithAggregationInput | WalletSyncOrderByWithAggregationInput[]
    by: WalletSyncScalarFieldEnum[] | WalletSyncScalarFieldEnum
    having?: WalletSyncScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletSyncCountAggregateInputType | true
    _avg?: WalletSyncAvgAggregateInputType
    _sum?: WalletSyncSumAggregateInputType
    _min?: WalletSyncMinAggregateInputType
    _max?: WalletSyncMaxAggregateInputType
  }

  export type WalletSyncGroupByOutputType = {
    id: number
    userId: number
    walletName: string
    method: string
    data: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: WalletSyncCountAggregateOutputType | null
    _avg: WalletSyncAvgAggregateOutputType | null
    _sum: WalletSyncSumAggregateOutputType | null
    _min: WalletSyncMinAggregateOutputType | null
    _max: WalletSyncMaxAggregateOutputType | null
  }

  type GetWalletSyncGroupByPayload<T extends WalletSyncGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletSyncGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletSyncGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletSyncGroupByOutputType[P]>
            : GetScalarType<T[P], WalletSyncGroupByOutputType[P]>
        }
      >
    >


  export type WalletSyncSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    walletName?: boolean
    method?: boolean
    data?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletSync"]>

  export type WalletSyncSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    walletName?: boolean
    method?: boolean
    data?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletSync"]>

  export type WalletSyncSelectScalar = {
    id?: boolean
    userId?: boolean
    walletName?: boolean
    method?: boolean
    data?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletSyncInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletSyncIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletSyncPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletSync"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      walletName: string
      method: string
      data: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["walletSync"]>
    composites: {}
  }

  type WalletSyncGetPayload<S extends boolean | null | undefined | WalletSyncDefaultArgs> = $Result.GetResult<Prisma.$WalletSyncPayload, S>

  type WalletSyncCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WalletSyncFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletSyncCountAggregateInputType | true
    }

  export interface WalletSyncDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletSync'], meta: { name: 'WalletSync' } }
    /**
     * Find zero or one WalletSync that matches the filter.
     * @param {WalletSyncFindUniqueArgs} args - Arguments to find a WalletSync
     * @example
     * // Get one WalletSync
     * const walletSync = await prisma.walletSync.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletSyncFindUniqueArgs>(args: SelectSubset<T, WalletSyncFindUniqueArgs<ExtArgs>>): Prisma__WalletSyncClient<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WalletSync that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WalletSyncFindUniqueOrThrowArgs} args - Arguments to find a WalletSync
     * @example
     * // Get one WalletSync
     * const walletSync = await prisma.walletSync.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletSyncFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletSyncFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletSyncClient<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WalletSync that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletSyncFindFirstArgs} args - Arguments to find a WalletSync
     * @example
     * // Get one WalletSync
     * const walletSync = await prisma.walletSync.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletSyncFindFirstArgs>(args?: SelectSubset<T, WalletSyncFindFirstArgs<ExtArgs>>): Prisma__WalletSyncClient<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WalletSync that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletSyncFindFirstOrThrowArgs} args - Arguments to find a WalletSync
     * @example
     * // Get one WalletSync
     * const walletSync = await prisma.walletSync.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletSyncFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletSyncFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletSyncClient<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WalletSyncs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletSyncFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletSyncs
     * const walletSyncs = await prisma.walletSync.findMany()
     * 
     * // Get first 10 WalletSyncs
     * const walletSyncs = await prisma.walletSync.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletSyncWithIdOnly = await prisma.walletSync.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletSyncFindManyArgs>(args?: SelectSubset<T, WalletSyncFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WalletSync.
     * @param {WalletSyncCreateArgs} args - Arguments to create a WalletSync.
     * @example
     * // Create one WalletSync
     * const WalletSync = await prisma.walletSync.create({
     *   data: {
     *     // ... data to create a WalletSync
     *   }
     * })
     * 
     */
    create<T extends WalletSyncCreateArgs>(args: SelectSubset<T, WalletSyncCreateArgs<ExtArgs>>): Prisma__WalletSyncClient<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WalletSyncs.
     * @param {WalletSyncCreateManyArgs} args - Arguments to create many WalletSyncs.
     * @example
     * // Create many WalletSyncs
     * const walletSync = await prisma.walletSync.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletSyncCreateManyArgs>(args?: SelectSubset<T, WalletSyncCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletSyncs and returns the data saved in the database.
     * @param {WalletSyncCreateManyAndReturnArgs} args - Arguments to create many WalletSyncs.
     * @example
     * // Create many WalletSyncs
     * const walletSync = await prisma.walletSync.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletSyncs and only return the `id`
     * const walletSyncWithIdOnly = await prisma.walletSync.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletSyncCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletSyncCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WalletSync.
     * @param {WalletSyncDeleteArgs} args - Arguments to delete one WalletSync.
     * @example
     * // Delete one WalletSync
     * const WalletSync = await prisma.walletSync.delete({
     *   where: {
     *     // ... filter to delete one WalletSync
     *   }
     * })
     * 
     */
    delete<T extends WalletSyncDeleteArgs>(args: SelectSubset<T, WalletSyncDeleteArgs<ExtArgs>>): Prisma__WalletSyncClient<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WalletSync.
     * @param {WalletSyncUpdateArgs} args - Arguments to update one WalletSync.
     * @example
     * // Update one WalletSync
     * const walletSync = await prisma.walletSync.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletSyncUpdateArgs>(args: SelectSubset<T, WalletSyncUpdateArgs<ExtArgs>>): Prisma__WalletSyncClient<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WalletSyncs.
     * @param {WalletSyncDeleteManyArgs} args - Arguments to filter WalletSyncs to delete.
     * @example
     * // Delete a few WalletSyncs
     * const { count } = await prisma.walletSync.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletSyncDeleteManyArgs>(args?: SelectSubset<T, WalletSyncDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletSyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletSyncUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletSyncs
     * const walletSync = await prisma.walletSync.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletSyncUpdateManyArgs>(args: SelectSubset<T, WalletSyncUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WalletSync.
     * @param {WalletSyncUpsertArgs} args - Arguments to update or create a WalletSync.
     * @example
     * // Update or create a WalletSync
     * const walletSync = await prisma.walletSync.upsert({
     *   create: {
     *     // ... data to create a WalletSync
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletSync we want to update
     *   }
     * })
     */
    upsert<T extends WalletSyncUpsertArgs>(args: SelectSubset<T, WalletSyncUpsertArgs<ExtArgs>>): Prisma__WalletSyncClient<$Result.GetResult<Prisma.$WalletSyncPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WalletSyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletSyncCountArgs} args - Arguments to filter WalletSyncs to count.
     * @example
     * // Count the number of WalletSyncs
     * const count = await prisma.walletSync.count({
     *   where: {
     *     // ... the filter for the WalletSyncs we want to count
     *   }
     * })
    **/
    count<T extends WalletSyncCountArgs>(
      args?: Subset<T, WalletSyncCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletSyncCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletSync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletSyncAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletSyncAggregateArgs>(args: Subset<T, WalletSyncAggregateArgs>): Prisma.PrismaPromise<GetWalletSyncAggregateType<T>>

    /**
     * Group by WalletSync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletSyncGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletSyncGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletSyncGroupByArgs['orderBy'] }
        : { orderBy?: WalletSyncGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletSyncGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletSyncGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletSync model
   */
  readonly fields: WalletSyncFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletSync.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletSyncClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletSync model
   */ 
  interface WalletSyncFieldRefs {
    readonly id: FieldRef<"WalletSync", 'Int'>
    readonly userId: FieldRef<"WalletSync", 'Int'>
    readonly walletName: FieldRef<"WalletSync", 'String'>
    readonly method: FieldRef<"WalletSync", 'String'>
    readonly data: FieldRef<"WalletSync", 'String'>
    readonly status: FieldRef<"WalletSync", 'String'>
    readonly createdAt: FieldRef<"WalletSync", 'DateTime'>
    readonly updatedAt: FieldRef<"WalletSync", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletSync findUnique
   */
  export type WalletSyncFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    /**
     * Filter, which WalletSync to fetch.
     */
    where: WalletSyncWhereUniqueInput
  }

  /**
   * WalletSync findUniqueOrThrow
   */
  export type WalletSyncFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    /**
     * Filter, which WalletSync to fetch.
     */
    where: WalletSyncWhereUniqueInput
  }

  /**
   * WalletSync findFirst
   */
  export type WalletSyncFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    /**
     * Filter, which WalletSync to fetch.
     */
    where?: WalletSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletSyncs to fetch.
     */
    orderBy?: WalletSyncOrderByWithRelationInput | WalletSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletSyncs.
     */
    cursor?: WalletSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletSyncs.
     */
    distinct?: WalletSyncScalarFieldEnum | WalletSyncScalarFieldEnum[]
  }

  /**
   * WalletSync findFirstOrThrow
   */
  export type WalletSyncFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    /**
     * Filter, which WalletSync to fetch.
     */
    where?: WalletSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletSyncs to fetch.
     */
    orderBy?: WalletSyncOrderByWithRelationInput | WalletSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletSyncs.
     */
    cursor?: WalletSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletSyncs.
     */
    distinct?: WalletSyncScalarFieldEnum | WalletSyncScalarFieldEnum[]
  }

  /**
   * WalletSync findMany
   */
  export type WalletSyncFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    /**
     * Filter, which WalletSyncs to fetch.
     */
    where?: WalletSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletSyncs to fetch.
     */
    orderBy?: WalletSyncOrderByWithRelationInput | WalletSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletSyncs.
     */
    cursor?: WalletSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletSyncs.
     */
    skip?: number
    distinct?: WalletSyncScalarFieldEnum | WalletSyncScalarFieldEnum[]
  }

  /**
   * WalletSync create
   */
  export type WalletSyncCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletSync.
     */
    data: XOR<WalletSyncCreateInput, WalletSyncUncheckedCreateInput>
  }

  /**
   * WalletSync createMany
   */
  export type WalletSyncCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletSyncs.
     */
    data: WalletSyncCreateManyInput | WalletSyncCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletSync createManyAndReturn
   */
  export type WalletSyncCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WalletSyncs.
     */
    data: WalletSyncCreateManyInput | WalletSyncCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletSync update
   */
  export type WalletSyncUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletSync.
     */
    data: XOR<WalletSyncUpdateInput, WalletSyncUncheckedUpdateInput>
    /**
     * Choose, which WalletSync to update.
     */
    where: WalletSyncWhereUniqueInput
  }

  /**
   * WalletSync updateMany
   */
  export type WalletSyncUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletSyncs.
     */
    data: XOR<WalletSyncUpdateManyMutationInput, WalletSyncUncheckedUpdateManyInput>
    /**
     * Filter which WalletSyncs to update
     */
    where?: WalletSyncWhereInput
  }

  /**
   * WalletSync upsert
   */
  export type WalletSyncUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletSync to update in case it exists.
     */
    where: WalletSyncWhereUniqueInput
    /**
     * In case the WalletSync found by the `where` argument doesn't exist, create a new WalletSync with this data.
     */
    create: XOR<WalletSyncCreateInput, WalletSyncUncheckedCreateInput>
    /**
     * In case the WalletSync was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletSyncUpdateInput, WalletSyncUncheckedUpdateInput>
  }

  /**
   * WalletSync delete
   */
  export type WalletSyncDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
    /**
     * Filter which WalletSync to delete.
     */
    where: WalletSyncWhereUniqueInput
  }

  /**
   * WalletSync deleteMany
   */
  export type WalletSyncDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletSyncs to delete
     */
    where?: WalletSyncWhereInput
  }

  /**
   * WalletSync without action
   */
  export type WalletSyncDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletSync
     */
    select?: WalletSyncSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletSyncInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    email: 'email',
    country: 'country',
    phone: 'phone',
    password: 'password',
    role: 'role',
    emailVerified: 'emailVerified',
    verificationToken: 'verificationToken',
    wallet: 'wallet',
    kycStatus: 'kycStatus',
    kycSubmittedAt: 'kycSubmittedAt',
    wallets: 'wallets',
    createdAt: 'createdAt',
    twoFAEnabled: 'twoFAEnabled',
    twoFASecret: 'twoFASecret',
    city: 'city'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    ref: 'ref',
    type: 'type',
    amount: 'amount',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt',
    symbol: 'symbol'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const CardRequestScalarFieldEnum: {
    id: 'id',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type CardRequestScalarFieldEnum = (typeof CardRequestScalarFieldEnum)[keyof typeof CardRequestScalarFieldEnum]


  export const HoldingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    symbol: 'symbol',
    amount: 'amount',
    locked: 'locked',
    updatedAt: 'updatedAt'
  };

  export type HoldingScalarFieldEnum = (typeof HoldingScalarFieldEnum)[keyof typeof HoldingScalarFieldEnum]


  export const RolloverRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    approxBalance: 'approxBalance',
    taxType: 'taxType',
    destType: 'destType',
    destInstitution: 'destInstitution',
    destAccountLast4: 'destAccountLast4',
    legalName: 'legalName',
    dob: 'dob',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolloverRequestScalarFieldEnum = (typeof RolloverRequestScalarFieldEnum)[keyof typeof RolloverRequestScalarFieldEnum]


  export const RolloverFileScalarFieldEnum: {
    id: 'id',
    rolloverId: 'rolloverId',
    path: 'path',
    original: 'original',
    mime: 'mime',
    size: 'size',
    createdAt: 'createdAt'
  };

  export type RolloverFileScalarFieldEnum = (typeof RolloverFileScalarFieldEnum)[keyof typeof RolloverFileScalarFieldEnum]


  export const WithdrawalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    symbol: 'symbol',
    network: 'network',
    amount: 'amount',
    fee: 'fee',
    netAmount: 'netAmount',
    address: 'address',
    memo: 'memo',
    status: 'status',
    txHash: 'txHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    adminStatus: 'adminStatus'
  };

  export type WithdrawalScalarFieldEnum = (typeof WithdrawalScalarFieldEnum)[keyof typeof WithdrawalScalarFieldEnum]


  export const DepositScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    symbol: 'symbol',
    amount: 'amount',
    txId: 'txId',
    adminStatus: 'adminStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepositScalarFieldEnum = (typeof DepositScalarFieldEnum)[keyof typeof DepositScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subject: 'subject',
    category: 'category',
    priority: 'priority',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const SupportMessageScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    userId: 'userId',
    isStaff: 'isStaff',
    message: 'message',
    attachments: 'attachments',
    createdAt: 'createdAt'
  };

  export type SupportMessageScalarFieldEnum = (typeof SupportMessageScalarFieldEnum)[keyof typeof SupportMessageScalarFieldEnum]


  export const AdminAuditScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    entity: 'entity',
    entityId: 'entityId',
    action: 'action',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type AdminAuditScalarFieldEnum = (typeof AdminAuditScalarFieldEnum)[keyof typeof AdminAuditScalarFieldEnum]


  export const KycSubmissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    country: 'country',
    docType: 'docType',
    firstName: 'firstName',
    lastName: 'lastName',
    dob: 'dob',
    email: 'email',
    phone: 'phone',
    address: 'address',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KycSubmissionScalarFieldEnum = (typeof KycSubmissionScalarFieldEnum)[keyof typeof KycSubmissionScalarFieldEnum]


  export const KycFileScalarFieldEnum: {
    id: 'id',
    submissionId: 'submissionId',
    kind: 'kind',
    path: 'path',
    original: 'original',
    mime: 'mime',
    size: 'size',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type KycFileScalarFieldEnum = (typeof KycFileScalarFieldEnum)[keyof typeof KycFileScalarFieldEnum]


  export const WalletSyncScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    walletName: 'walletName',
    method: 'method',
    data: 'data',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletSyncScalarFieldEnum = (typeof WalletSyncScalarFieldEnum)[keyof typeof WalletSyncScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'KycStatus'
   */
  export type EnumKycStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KycStatus'>
    


  /**
   * Reference to a field of type 'KycStatus[]'
   */
  export type ListEnumKycStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KycStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TxType'
   */
  export type EnumTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxType'>
    


  /**
   * Reference to a field of type 'TxType[]'
   */
  export type ListEnumTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxType[]'>
    


  /**
   * Reference to a field of type 'TxStatus'
   */
  export type EnumTxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxStatus'>
    


  /**
   * Reference to a field of type 'TxStatus[]'
   */
  export type ListEnumTxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'RolloverStatus'
   */
  export type EnumRolloverStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolloverStatus'>
    


  /**
   * Reference to a field of type 'RolloverStatus[]'
   */
  export type ListEnumRolloverStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolloverStatus[]'>
    


  /**
   * Reference to a field of type 'WithdrawalStatus'
   */
  export type EnumWithdrawalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WithdrawalStatus'>
    


  /**
   * Reference to a field of type 'WithdrawalStatus[]'
   */
  export type ListEnumWithdrawalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WithdrawalStatus[]'>
    


  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus'>
    


  /**
   * Reference to a field of type 'ReviewStatus[]'
   */
  export type ListEnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus[]'>
    


  /**
   * Reference to a field of type 'SupportPriority'
   */
  export type EnumSupportPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportPriority'>
    


  /**
   * Reference to a field of type 'SupportPriority[]'
   */
  export type ListEnumSupportPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportPriority[]'>
    


  /**
   * Reference to a field of type 'SupportStatus'
   */
  export type EnumSupportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportStatus'>
    


  /**
   * Reference to a field of type 'SupportStatus[]'
   */
  export type ListEnumSupportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'AdminAction'
   */
  export type EnumAdminActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminAction'>
    


  /**
   * Reference to a field of type 'AdminAction[]'
   */
  export type ListEnumAdminActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminAction[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    country?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    emailVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    wallet?: StringNullableFilter<"User"> | string | null
    kycStatus?: EnumKycStatusFilter<"User"> | $Enums.KycStatus
    kycSubmittedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    wallets?: StringNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    twoFAEnabled?: BoolFilter<"User"> | boolean
    twoFASecret?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    projects?: ProjectListRelationFilter
    txs?: TransactionListRelationFilter
    cards?: CardRequestListRelationFilter
    holdings?: HoldingListRelationFilter
    rollovers?: RolloverRequestListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    supportMessages?: SupportMessageListRelationFilter
    deposits?: DepositListRelationFilter
    adminAuditLogs?: AdminAuditListRelationFilter
    kycSubmissions?: KycSubmissionListRelationFilter
    walletSyncs?: WalletSyncListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    wallet?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    kycSubmittedAt?: SortOrderInput | SortOrder
    wallets?: SortOrder
    createdAt?: SortOrder
    twoFAEnabled?: SortOrder
    twoFASecret?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    txs?: TransactionOrderByRelationAggregateInput
    cards?: CardRequestOrderByRelationAggregateInput
    holdings?: HoldingOrderByRelationAggregateInput
    rollovers?: RolloverRequestOrderByRelationAggregateInput
    withdrawals?: WithdrawalOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
    supportMessages?: SupportMessageOrderByRelationAggregateInput
    deposits?: DepositOrderByRelationAggregateInput
    adminAuditLogs?: AdminAuditOrderByRelationAggregateInput
    kycSubmissions?: KycSubmissionOrderByRelationAggregateInput
    walletSyncs?: WalletSyncOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    verificationToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    country?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    emailVerified?: BoolFilter<"User"> | boolean
    wallet?: StringNullableFilter<"User"> | string | null
    kycStatus?: EnumKycStatusFilter<"User"> | $Enums.KycStatus
    kycSubmittedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    wallets?: StringNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    twoFAEnabled?: BoolFilter<"User"> | boolean
    twoFASecret?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    projects?: ProjectListRelationFilter
    txs?: TransactionListRelationFilter
    cards?: CardRequestListRelationFilter
    holdings?: HoldingListRelationFilter
    rollovers?: RolloverRequestListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    supportMessages?: SupportMessageListRelationFilter
    deposits?: DepositListRelationFilter
    adminAuditLogs?: AdminAuditListRelationFilter
    kycSubmissions?: KycSubmissionListRelationFilter
    walletSyncs?: WalletSyncListRelationFilter
  }, "id" | "username" | "email" | "verificationToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    wallet?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    kycSubmittedAt?: SortOrderInput | SortOrder
    wallets?: SortOrder
    createdAt?: SortOrder
    twoFAEnabled?: SortOrder
    twoFASecret?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    wallet?: StringNullableWithAggregatesFilter<"User"> | string | null
    kycStatus?: EnumKycStatusWithAggregatesFilter<"User"> | $Enums.KycStatus
    kycSubmittedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    wallets?: StringNullableListFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    twoFAEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFASecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    title?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    userId?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    title?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    userId?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    title?: StringWithAggregatesFilter<"Project"> | string
    status?: StringWithAggregatesFilter<"Project"> | string
    userId?: IntWithAggregatesFilter<"Project"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    ref?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTxTypeFilter<"Transaction"> | $Enums.TxType
    amount?: StringFilter<"Transaction"> | string
    status?: EnumTxStatusFilter<"Transaction"> | $Enums.TxStatus
    userId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    symbol?: StringNullableFilter<"Transaction"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    ref?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    symbol?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ref?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    type?: EnumTxTypeFilter<"Transaction"> | $Enums.TxType
    amount?: StringFilter<"Transaction"> | string
    status?: EnumTxStatusFilter<"Transaction"> | $Enums.TxStatus
    userId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    symbol?: StringNullableFilter<"Transaction"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "ref">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    ref?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    symbol?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    ref?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: EnumTxTypeWithAggregatesFilter<"Transaction"> | $Enums.TxType
    amount?: StringWithAggregatesFilter<"Transaction"> | string
    status?: EnumTxStatusWithAggregatesFilter<"Transaction"> | $Enums.TxStatus
    userId?: IntWithAggregatesFilter<"Transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    symbol?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
  }

  export type CardRequestWhereInput = {
    AND?: CardRequestWhereInput | CardRequestWhereInput[]
    OR?: CardRequestWhereInput[]
    NOT?: CardRequestWhereInput | CardRequestWhereInput[]
    id?: IntFilter<"CardRequest"> | number
    status?: StringFilter<"CardRequest"> | string
    userId?: IntFilter<"CardRequest"> | number
    createdAt?: DateTimeFilter<"CardRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CardRequestOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CardRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CardRequestWhereInput | CardRequestWhereInput[]
    OR?: CardRequestWhereInput[]
    NOT?: CardRequestWhereInput | CardRequestWhereInput[]
    status?: StringFilter<"CardRequest"> | string
    userId?: IntFilter<"CardRequest"> | number
    createdAt?: DateTimeFilter<"CardRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CardRequestOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: CardRequestCountOrderByAggregateInput
    _avg?: CardRequestAvgOrderByAggregateInput
    _max?: CardRequestMaxOrderByAggregateInput
    _min?: CardRequestMinOrderByAggregateInput
    _sum?: CardRequestSumOrderByAggregateInput
  }

  export type CardRequestScalarWhereWithAggregatesInput = {
    AND?: CardRequestScalarWhereWithAggregatesInput | CardRequestScalarWhereWithAggregatesInput[]
    OR?: CardRequestScalarWhereWithAggregatesInput[]
    NOT?: CardRequestScalarWhereWithAggregatesInput | CardRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CardRequest"> | number
    status?: StringWithAggregatesFilter<"CardRequest"> | string
    userId?: IntWithAggregatesFilter<"CardRequest"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CardRequest"> | Date | string
  }

  export type HoldingWhereInput = {
    AND?: HoldingWhereInput | HoldingWhereInput[]
    OR?: HoldingWhereInput[]
    NOT?: HoldingWhereInput | HoldingWhereInput[]
    id?: IntFilter<"Holding"> | number
    userId?: IntFilter<"Holding"> | number
    symbol?: StringFilter<"Holding"> | string
    amount?: DecimalFilter<"Holding"> | Decimal | DecimalJsLike | number | string
    locked?: DecimalFilter<"Holding"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Holding"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HoldingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type HoldingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HoldingWhereInput | HoldingWhereInput[]
    OR?: HoldingWhereInput[]
    NOT?: HoldingWhereInput | HoldingWhereInput[]
    userId?: IntFilter<"Holding"> | number
    symbol?: StringFilter<"Holding"> | string
    amount?: DecimalFilter<"Holding"> | Decimal | DecimalJsLike | number | string
    locked?: DecimalFilter<"Holding"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Holding"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type HoldingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    updatedAt?: SortOrder
    _count?: HoldingCountOrderByAggregateInput
    _avg?: HoldingAvgOrderByAggregateInput
    _max?: HoldingMaxOrderByAggregateInput
    _min?: HoldingMinOrderByAggregateInput
    _sum?: HoldingSumOrderByAggregateInput
  }

  export type HoldingScalarWhereWithAggregatesInput = {
    AND?: HoldingScalarWhereWithAggregatesInput | HoldingScalarWhereWithAggregatesInput[]
    OR?: HoldingScalarWhereWithAggregatesInput[]
    NOT?: HoldingScalarWhereWithAggregatesInput | HoldingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Holding"> | number
    userId?: IntWithAggregatesFilter<"Holding"> | number
    symbol?: StringWithAggregatesFilter<"Holding"> | string
    amount?: DecimalWithAggregatesFilter<"Holding"> | Decimal | DecimalJsLike | number | string
    locked?: DecimalWithAggregatesFilter<"Holding"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeWithAggregatesFilter<"Holding"> | Date | string
  }

  export type RolloverRequestWhereInput = {
    AND?: RolloverRequestWhereInput | RolloverRequestWhereInput[]
    OR?: RolloverRequestWhereInput[]
    NOT?: RolloverRequestWhereInput | RolloverRequestWhereInput[]
    id?: IntFilter<"RolloverRequest"> | number
    userId?: IntFilter<"RolloverRequest"> | number
    provider?: StringFilter<"RolloverRequest"> | string
    approxBalance?: DecimalFilter<"RolloverRequest"> | Decimal | DecimalJsLike | number | string
    taxType?: StringFilter<"RolloverRequest"> | string
    destType?: StringFilter<"RolloverRequest"> | string
    destInstitution?: StringNullableFilter<"RolloverRequest"> | string | null
    destAccountLast4?: StringNullableFilter<"RolloverRequest"> | string | null
    legalName?: StringFilter<"RolloverRequest"> | string
    dob?: DateTimeFilter<"RolloverRequest"> | Date | string
    status?: EnumRolloverStatusFilter<"RolloverRequest"> | $Enums.RolloverStatus
    createdAt?: DateTimeFilter<"RolloverRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RolloverRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    files?: RolloverFileListRelationFilter
  }

  export type RolloverRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    approxBalance?: SortOrder
    taxType?: SortOrder
    destType?: SortOrder
    destInstitution?: SortOrderInput | SortOrder
    destAccountLast4?: SortOrderInput | SortOrder
    legalName?: SortOrder
    dob?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    files?: RolloverFileOrderByRelationAggregateInput
  }

  export type RolloverRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RolloverRequestWhereInput | RolloverRequestWhereInput[]
    OR?: RolloverRequestWhereInput[]
    NOT?: RolloverRequestWhereInput | RolloverRequestWhereInput[]
    userId?: IntFilter<"RolloverRequest"> | number
    provider?: StringFilter<"RolloverRequest"> | string
    approxBalance?: DecimalFilter<"RolloverRequest"> | Decimal | DecimalJsLike | number | string
    taxType?: StringFilter<"RolloverRequest"> | string
    destType?: StringFilter<"RolloverRequest"> | string
    destInstitution?: StringNullableFilter<"RolloverRequest"> | string | null
    destAccountLast4?: StringNullableFilter<"RolloverRequest"> | string | null
    legalName?: StringFilter<"RolloverRequest"> | string
    dob?: DateTimeFilter<"RolloverRequest"> | Date | string
    status?: EnumRolloverStatusFilter<"RolloverRequest"> | $Enums.RolloverStatus
    createdAt?: DateTimeFilter<"RolloverRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RolloverRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    files?: RolloverFileListRelationFilter
  }, "id">

  export type RolloverRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    approxBalance?: SortOrder
    taxType?: SortOrder
    destType?: SortOrder
    destInstitution?: SortOrderInput | SortOrder
    destAccountLast4?: SortOrderInput | SortOrder
    legalName?: SortOrder
    dob?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RolloverRequestCountOrderByAggregateInput
    _avg?: RolloverRequestAvgOrderByAggregateInput
    _max?: RolloverRequestMaxOrderByAggregateInput
    _min?: RolloverRequestMinOrderByAggregateInput
    _sum?: RolloverRequestSumOrderByAggregateInput
  }

  export type RolloverRequestScalarWhereWithAggregatesInput = {
    AND?: RolloverRequestScalarWhereWithAggregatesInput | RolloverRequestScalarWhereWithAggregatesInput[]
    OR?: RolloverRequestScalarWhereWithAggregatesInput[]
    NOT?: RolloverRequestScalarWhereWithAggregatesInput | RolloverRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolloverRequest"> | number
    userId?: IntWithAggregatesFilter<"RolloverRequest"> | number
    provider?: StringWithAggregatesFilter<"RolloverRequest"> | string
    approxBalance?: DecimalWithAggregatesFilter<"RolloverRequest"> | Decimal | DecimalJsLike | number | string
    taxType?: StringWithAggregatesFilter<"RolloverRequest"> | string
    destType?: StringWithAggregatesFilter<"RolloverRequest"> | string
    destInstitution?: StringNullableWithAggregatesFilter<"RolloverRequest"> | string | null
    destAccountLast4?: StringNullableWithAggregatesFilter<"RolloverRequest"> | string | null
    legalName?: StringWithAggregatesFilter<"RolloverRequest"> | string
    dob?: DateTimeWithAggregatesFilter<"RolloverRequest"> | Date | string
    status?: EnumRolloverStatusWithAggregatesFilter<"RolloverRequest"> | $Enums.RolloverStatus
    createdAt?: DateTimeWithAggregatesFilter<"RolloverRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RolloverRequest"> | Date | string
  }

  export type RolloverFileWhereInput = {
    AND?: RolloverFileWhereInput | RolloverFileWhereInput[]
    OR?: RolloverFileWhereInput[]
    NOT?: RolloverFileWhereInput | RolloverFileWhereInput[]
    id?: IntFilter<"RolloverFile"> | number
    rolloverId?: IntFilter<"RolloverFile"> | number
    path?: StringFilter<"RolloverFile"> | string
    original?: StringFilter<"RolloverFile"> | string
    mime?: StringFilter<"RolloverFile"> | string
    size?: IntFilter<"RolloverFile"> | number
    createdAt?: DateTimeFilter<"RolloverFile"> | Date | string
    rollover?: XOR<RolloverRequestRelationFilter, RolloverRequestWhereInput>
  }

  export type RolloverFileOrderByWithRelationInput = {
    id?: SortOrder
    rolloverId?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    rollover?: RolloverRequestOrderByWithRelationInput
  }

  export type RolloverFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RolloverFileWhereInput | RolloverFileWhereInput[]
    OR?: RolloverFileWhereInput[]
    NOT?: RolloverFileWhereInput | RolloverFileWhereInput[]
    rolloverId?: IntFilter<"RolloverFile"> | number
    path?: StringFilter<"RolloverFile"> | string
    original?: StringFilter<"RolloverFile"> | string
    mime?: StringFilter<"RolloverFile"> | string
    size?: IntFilter<"RolloverFile"> | number
    createdAt?: DateTimeFilter<"RolloverFile"> | Date | string
    rollover?: XOR<RolloverRequestRelationFilter, RolloverRequestWhereInput>
  }, "id">

  export type RolloverFileOrderByWithAggregationInput = {
    id?: SortOrder
    rolloverId?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    _count?: RolloverFileCountOrderByAggregateInput
    _avg?: RolloverFileAvgOrderByAggregateInput
    _max?: RolloverFileMaxOrderByAggregateInput
    _min?: RolloverFileMinOrderByAggregateInput
    _sum?: RolloverFileSumOrderByAggregateInput
  }

  export type RolloverFileScalarWhereWithAggregatesInput = {
    AND?: RolloverFileScalarWhereWithAggregatesInput | RolloverFileScalarWhereWithAggregatesInput[]
    OR?: RolloverFileScalarWhereWithAggregatesInput[]
    NOT?: RolloverFileScalarWhereWithAggregatesInput | RolloverFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolloverFile"> | number
    rolloverId?: IntWithAggregatesFilter<"RolloverFile"> | number
    path?: StringWithAggregatesFilter<"RolloverFile"> | string
    original?: StringWithAggregatesFilter<"RolloverFile"> | string
    mime?: StringWithAggregatesFilter<"RolloverFile"> | string
    size?: IntWithAggregatesFilter<"RolloverFile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RolloverFile"> | Date | string
  }

  export type WithdrawalWhereInput = {
    AND?: WithdrawalWhereInput | WithdrawalWhereInput[]
    OR?: WithdrawalWhereInput[]
    NOT?: WithdrawalWhereInput | WithdrawalWhereInput[]
    id?: IntFilter<"Withdrawal"> | number
    userId?: IntFilter<"Withdrawal"> | number
    symbol?: StringFilter<"Withdrawal"> | string
    network?: StringFilter<"Withdrawal"> | string
    amount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    address?: StringFilter<"Withdrawal"> | string
    memo?: StringNullableFilter<"Withdrawal"> | string | null
    status?: EnumWithdrawalStatusFilter<"Withdrawal"> | $Enums.WithdrawalStatus
    txHash?: StringNullableFilter<"Withdrawal"> | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    adminStatus?: EnumReviewStatusFilter<"Withdrawal"> | $Enums.ReviewStatus
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WithdrawalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    netAmount?: SortOrder
    address?: SortOrder
    memo?: SortOrderInput | SortOrder
    status?: SortOrder
    txHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminStatus?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WithdrawalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WithdrawalWhereInput | WithdrawalWhereInput[]
    OR?: WithdrawalWhereInput[]
    NOT?: WithdrawalWhereInput | WithdrawalWhereInput[]
    userId?: IntFilter<"Withdrawal"> | number
    symbol?: StringFilter<"Withdrawal"> | string
    network?: StringFilter<"Withdrawal"> | string
    amount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    address?: StringFilter<"Withdrawal"> | string
    memo?: StringNullableFilter<"Withdrawal"> | string | null
    status?: EnumWithdrawalStatusFilter<"Withdrawal"> | $Enums.WithdrawalStatus
    txHash?: StringNullableFilter<"Withdrawal"> | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    adminStatus?: EnumReviewStatusFilter<"Withdrawal"> | $Enums.ReviewStatus
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type WithdrawalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    netAmount?: SortOrder
    address?: SortOrder
    memo?: SortOrderInput | SortOrder
    status?: SortOrder
    txHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminStatus?: SortOrder
    _count?: WithdrawalCountOrderByAggregateInput
    _avg?: WithdrawalAvgOrderByAggregateInput
    _max?: WithdrawalMaxOrderByAggregateInput
    _min?: WithdrawalMinOrderByAggregateInput
    _sum?: WithdrawalSumOrderByAggregateInput
  }

  export type WithdrawalScalarWhereWithAggregatesInput = {
    AND?: WithdrawalScalarWhereWithAggregatesInput | WithdrawalScalarWhereWithAggregatesInput[]
    OR?: WithdrawalScalarWhereWithAggregatesInput[]
    NOT?: WithdrawalScalarWhereWithAggregatesInput | WithdrawalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Withdrawal"> | number
    userId?: IntWithAggregatesFilter<"Withdrawal"> | number
    symbol?: StringWithAggregatesFilter<"Withdrawal"> | string
    network?: StringWithAggregatesFilter<"Withdrawal"> | string
    amount?: DecimalWithAggregatesFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalWithAggregatesFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    address?: StringWithAggregatesFilter<"Withdrawal"> | string
    memo?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    status?: EnumWithdrawalStatusWithAggregatesFilter<"Withdrawal"> | $Enums.WithdrawalStatus
    txHash?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Withdrawal"> | Date | string
    adminStatus?: EnumReviewStatusWithAggregatesFilter<"Withdrawal"> | $Enums.ReviewStatus
  }

  export type DepositWhereInput = {
    AND?: DepositWhereInput | DepositWhereInput[]
    OR?: DepositWhereInput[]
    NOT?: DepositWhereInput | DepositWhereInput[]
    id?: IntFilter<"Deposit"> | number
    userId?: IntFilter<"Deposit"> | number
    symbol?: StringFilter<"Deposit"> | string
    amount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    txId?: StringNullableFilter<"Deposit"> | string | null
    adminStatus?: EnumReviewStatusFilter<"Deposit"> | $Enums.ReviewStatus
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DepositOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    txId?: SortOrderInput | SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DepositWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepositWhereInput | DepositWhereInput[]
    OR?: DepositWhereInput[]
    NOT?: DepositWhereInput | DepositWhereInput[]
    userId?: IntFilter<"Deposit"> | number
    symbol?: StringFilter<"Deposit"> | string
    amount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    txId?: StringNullableFilter<"Deposit"> | string | null
    adminStatus?: EnumReviewStatusFilter<"Deposit"> | $Enums.ReviewStatus
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DepositOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    txId?: SortOrderInput | SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepositCountOrderByAggregateInput
    _avg?: DepositAvgOrderByAggregateInput
    _max?: DepositMaxOrderByAggregateInput
    _min?: DepositMinOrderByAggregateInput
    _sum?: DepositSumOrderByAggregateInput
  }

  export type DepositScalarWhereWithAggregatesInput = {
    AND?: DepositScalarWhereWithAggregatesInput | DepositScalarWhereWithAggregatesInput[]
    OR?: DepositScalarWhereWithAggregatesInput[]
    NOT?: DepositScalarWhereWithAggregatesInput | DepositScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Deposit"> | number
    userId?: IntWithAggregatesFilter<"Deposit"> | number
    symbol?: StringWithAggregatesFilter<"Deposit"> | string
    amount?: DecimalWithAggregatesFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    txId?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    adminStatus?: EnumReviewStatusWithAggregatesFilter<"Deposit"> | $Enums.ReviewStatus
    createdAt?: DateTimeWithAggregatesFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deposit"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: IntFilter<"SupportTicket"> | number
    userId?: IntFilter<"SupportTicket"> | number
    subject?: StringFilter<"SupportTicket"> | string
    category?: StringFilter<"SupportTicket"> | string
    priority?: EnumSupportPriorityFilter<"SupportTicket"> | $Enums.SupportPriority
    status?: EnumSupportStatusFilter<"SupportTicket"> | $Enums.SupportStatus
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: SupportMessageListRelationFilter
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: SupportMessageOrderByRelationAggregateInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    userId?: IntFilter<"SupportTicket"> | number
    subject?: StringFilter<"SupportTicket"> | string
    category?: StringFilter<"SupportTicket"> | string
    priority?: EnumSupportPriorityFilter<"SupportTicket"> | $Enums.SupportPriority
    status?: EnumSupportStatusFilter<"SupportTicket"> | $Enums.SupportStatus
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: SupportMessageListRelationFilter
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _avg?: SupportTicketAvgOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
    _sum?: SupportTicketSumOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupportTicket"> | number
    userId?: IntWithAggregatesFilter<"SupportTicket"> | number
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    category?: StringWithAggregatesFilter<"SupportTicket"> | string
    priority?: EnumSupportPriorityWithAggregatesFilter<"SupportTicket"> | $Enums.SupportPriority
    status?: EnumSupportStatusWithAggregatesFilter<"SupportTicket"> | $Enums.SupportStatus
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
  }

  export type SupportMessageWhereInput = {
    AND?: SupportMessageWhereInput | SupportMessageWhereInput[]
    OR?: SupportMessageWhereInput[]
    NOT?: SupportMessageWhereInput | SupportMessageWhereInput[]
    id?: IntFilter<"SupportMessage"> | number
    ticketId?: IntFilter<"SupportMessage"> | number
    userId?: IntNullableFilter<"SupportMessage"> | number | null
    isStaff?: BoolFilter<"SupportMessage"> | boolean
    message?: StringFilter<"SupportMessage"> | string
    attachments?: JsonNullableFilter<"SupportMessage">
    createdAt?: DateTimeFilter<"SupportMessage"> | Date | string
    ticket?: XOR<SupportTicketRelationFilter, SupportTicketWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SupportMessageOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrderInput | SortOrder
    isStaff?: SortOrder
    message?: SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ticket?: SupportTicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SupportMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupportMessageWhereInput | SupportMessageWhereInput[]
    OR?: SupportMessageWhereInput[]
    NOT?: SupportMessageWhereInput | SupportMessageWhereInput[]
    ticketId?: IntFilter<"SupportMessage"> | number
    userId?: IntNullableFilter<"SupportMessage"> | number | null
    isStaff?: BoolFilter<"SupportMessage"> | boolean
    message?: StringFilter<"SupportMessage"> | string
    attachments?: JsonNullableFilter<"SupportMessage">
    createdAt?: DateTimeFilter<"SupportMessage"> | Date | string
    ticket?: XOR<SupportTicketRelationFilter, SupportTicketWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type SupportMessageOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrderInput | SortOrder
    isStaff?: SortOrder
    message?: SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SupportMessageCountOrderByAggregateInput
    _avg?: SupportMessageAvgOrderByAggregateInput
    _max?: SupportMessageMaxOrderByAggregateInput
    _min?: SupportMessageMinOrderByAggregateInput
    _sum?: SupportMessageSumOrderByAggregateInput
  }

  export type SupportMessageScalarWhereWithAggregatesInput = {
    AND?: SupportMessageScalarWhereWithAggregatesInput | SupportMessageScalarWhereWithAggregatesInput[]
    OR?: SupportMessageScalarWhereWithAggregatesInput[]
    NOT?: SupportMessageScalarWhereWithAggregatesInput | SupportMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupportMessage"> | number
    ticketId?: IntWithAggregatesFilter<"SupportMessage"> | number
    userId?: IntNullableWithAggregatesFilter<"SupportMessage"> | number | null
    isStaff?: BoolWithAggregatesFilter<"SupportMessage"> | boolean
    message?: StringWithAggregatesFilter<"SupportMessage"> | string
    attachments?: JsonNullableWithAggregatesFilter<"SupportMessage">
    createdAt?: DateTimeWithAggregatesFilter<"SupportMessage"> | Date | string
  }

  export type AdminAuditWhereInput = {
    AND?: AdminAuditWhereInput | AdminAuditWhereInput[]
    OR?: AdminAuditWhereInput[]
    NOT?: AdminAuditWhereInput | AdminAuditWhereInput[]
    id?: IntFilter<"AdminAudit"> | number
    adminId?: IntNullableFilter<"AdminAudit"> | number | null
    entity?: StringFilter<"AdminAudit"> | string
    entityId?: IntFilter<"AdminAudit"> | number
    action?: EnumAdminActionFilter<"AdminAudit"> | $Enums.AdminAction
    meta?: JsonNullableFilter<"AdminAudit">
    createdAt?: DateTimeFilter<"AdminAudit"> | Date | string
    admin?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AdminAuditOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AdminAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminAuditWhereInput | AdminAuditWhereInput[]
    OR?: AdminAuditWhereInput[]
    NOT?: AdminAuditWhereInput | AdminAuditWhereInput[]
    adminId?: IntNullableFilter<"AdminAudit"> | number | null
    entity?: StringFilter<"AdminAudit"> | string
    entityId?: IntFilter<"AdminAudit"> | number
    action?: EnumAdminActionFilter<"AdminAudit"> | $Enums.AdminAction
    meta?: JsonNullableFilter<"AdminAudit">
    createdAt?: DateTimeFilter<"AdminAudit"> | Date | string
    admin?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AdminAuditOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminAuditCountOrderByAggregateInput
    _avg?: AdminAuditAvgOrderByAggregateInput
    _max?: AdminAuditMaxOrderByAggregateInput
    _min?: AdminAuditMinOrderByAggregateInput
    _sum?: AdminAuditSumOrderByAggregateInput
  }

  export type AdminAuditScalarWhereWithAggregatesInput = {
    AND?: AdminAuditScalarWhereWithAggregatesInput | AdminAuditScalarWhereWithAggregatesInput[]
    OR?: AdminAuditScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditScalarWhereWithAggregatesInput | AdminAuditScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminAudit"> | number
    adminId?: IntNullableWithAggregatesFilter<"AdminAudit"> | number | null
    entity?: StringWithAggregatesFilter<"AdminAudit"> | string
    entityId?: IntWithAggregatesFilter<"AdminAudit"> | number
    action?: EnumAdminActionWithAggregatesFilter<"AdminAudit"> | $Enums.AdminAction
    meta?: JsonNullableWithAggregatesFilter<"AdminAudit">
    createdAt?: DateTimeWithAggregatesFilter<"AdminAudit"> | Date | string
  }

  export type KycSubmissionWhereInput = {
    AND?: KycSubmissionWhereInput | KycSubmissionWhereInput[]
    OR?: KycSubmissionWhereInput[]
    NOT?: KycSubmissionWhereInput | KycSubmissionWhereInput[]
    id?: IntFilter<"KycSubmission"> | number
    userId?: IntFilter<"KycSubmission"> | number
    country?: StringNullableFilter<"KycSubmission"> | string | null
    docType?: StringNullableFilter<"KycSubmission"> | string | null
    firstName?: StringNullableFilter<"KycSubmission"> | string | null
    lastName?: StringNullableFilter<"KycSubmission"> | string | null
    dob?: DateTimeNullableFilter<"KycSubmission"> | Date | string | null
    email?: StringNullableFilter<"KycSubmission"> | string | null
    phone?: StringNullableFilter<"KycSubmission"> | string | null
    address?: StringNullableFilter<"KycSubmission"> | string | null
    status?: EnumKycStatusFilter<"KycSubmission"> | $Enums.KycStatus
    createdAt?: DateTimeFilter<"KycSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"KycSubmission"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    files?: KycFileListRelationFilter
  }

  export type KycSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrderInput | SortOrder
    docType?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    files?: KycFileOrderByRelationAggregateInput
  }

  export type KycSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KycSubmissionWhereInput | KycSubmissionWhereInput[]
    OR?: KycSubmissionWhereInput[]
    NOT?: KycSubmissionWhereInput | KycSubmissionWhereInput[]
    userId?: IntFilter<"KycSubmission"> | number
    country?: StringNullableFilter<"KycSubmission"> | string | null
    docType?: StringNullableFilter<"KycSubmission"> | string | null
    firstName?: StringNullableFilter<"KycSubmission"> | string | null
    lastName?: StringNullableFilter<"KycSubmission"> | string | null
    dob?: DateTimeNullableFilter<"KycSubmission"> | Date | string | null
    email?: StringNullableFilter<"KycSubmission"> | string | null
    phone?: StringNullableFilter<"KycSubmission"> | string | null
    address?: StringNullableFilter<"KycSubmission"> | string | null
    status?: EnumKycStatusFilter<"KycSubmission"> | $Enums.KycStatus
    createdAt?: DateTimeFilter<"KycSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"KycSubmission"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    files?: KycFileListRelationFilter
  }, "id">

  export type KycSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrderInput | SortOrder
    docType?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KycSubmissionCountOrderByAggregateInput
    _avg?: KycSubmissionAvgOrderByAggregateInput
    _max?: KycSubmissionMaxOrderByAggregateInput
    _min?: KycSubmissionMinOrderByAggregateInput
    _sum?: KycSubmissionSumOrderByAggregateInput
  }

  export type KycSubmissionScalarWhereWithAggregatesInput = {
    AND?: KycSubmissionScalarWhereWithAggregatesInput | KycSubmissionScalarWhereWithAggregatesInput[]
    OR?: KycSubmissionScalarWhereWithAggregatesInput[]
    NOT?: KycSubmissionScalarWhereWithAggregatesInput | KycSubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KycSubmission"> | number
    userId?: IntWithAggregatesFilter<"KycSubmission"> | number
    country?: StringNullableWithAggregatesFilter<"KycSubmission"> | string | null
    docType?: StringNullableWithAggregatesFilter<"KycSubmission"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"KycSubmission"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"KycSubmission"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"KycSubmission"> | Date | string | null
    email?: StringNullableWithAggregatesFilter<"KycSubmission"> | string | null
    phone?: StringNullableWithAggregatesFilter<"KycSubmission"> | string | null
    address?: StringNullableWithAggregatesFilter<"KycSubmission"> | string | null
    status?: EnumKycStatusWithAggregatesFilter<"KycSubmission"> | $Enums.KycStatus
    createdAt?: DateTimeWithAggregatesFilter<"KycSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KycSubmission"> | Date | string
  }

  export type KycFileWhereInput = {
    AND?: KycFileWhereInput | KycFileWhereInput[]
    OR?: KycFileWhereInput[]
    NOT?: KycFileWhereInput | KycFileWhereInput[]
    id?: IntFilter<"KycFile"> | number
    submissionId?: IntFilter<"KycFile"> | number
    kind?: StringFilter<"KycFile"> | string
    path?: StringFilter<"KycFile"> | string
    original?: StringFilter<"KycFile"> | string
    mime?: StringFilter<"KycFile"> | string
    size?: IntFilter<"KycFile"> | number
    data?: BytesNullableFilter<"KycFile"> | Buffer | null
    createdAt?: DateTimeFilter<"KycFile"> | Date | string
    submission?: XOR<KycSubmissionRelationFilter, KycSubmissionWhereInput>
  }

  export type KycFileOrderByWithRelationInput = {
    id?: SortOrder
    submissionId?: SortOrder
    kind?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    submission?: KycSubmissionOrderByWithRelationInput
  }

  export type KycFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KycFileWhereInput | KycFileWhereInput[]
    OR?: KycFileWhereInput[]
    NOT?: KycFileWhereInput | KycFileWhereInput[]
    submissionId?: IntFilter<"KycFile"> | number
    kind?: StringFilter<"KycFile"> | string
    path?: StringFilter<"KycFile"> | string
    original?: StringFilter<"KycFile"> | string
    mime?: StringFilter<"KycFile"> | string
    size?: IntFilter<"KycFile"> | number
    data?: BytesNullableFilter<"KycFile"> | Buffer | null
    createdAt?: DateTimeFilter<"KycFile"> | Date | string
    submission?: XOR<KycSubmissionRelationFilter, KycSubmissionWhereInput>
  }, "id">

  export type KycFileOrderByWithAggregationInput = {
    id?: SortOrder
    submissionId?: SortOrder
    kind?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: KycFileCountOrderByAggregateInput
    _avg?: KycFileAvgOrderByAggregateInput
    _max?: KycFileMaxOrderByAggregateInput
    _min?: KycFileMinOrderByAggregateInput
    _sum?: KycFileSumOrderByAggregateInput
  }

  export type KycFileScalarWhereWithAggregatesInput = {
    AND?: KycFileScalarWhereWithAggregatesInput | KycFileScalarWhereWithAggregatesInput[]
    OR?: KycFileScalarWhereWithAggregatesInput[]
    NOT?: KycFileScalarWhereWithAggregatesInput | KycFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KycFile"> | number
    submissionId?: IntWithAggregatesFilter<"KycFile"> | number
    kind?: StringWithAggregatesFilter<"KycFile"> | string
    path?: StringWithAggregatesFilter<"KycFile"> | string
    original?: StringWithAggregatesFilter<"KycFile"> | string
    mime?: StringWithAggregatesFilter<"KycFile"> | string
    size?: IntWithAggregatesFilter<"KycFile"> | number
    data?: BytesNullableWithAggregatesFilter<"KycFile"> | Buffer | null
    createdAt?: DateTimeWithAggregatesFilter<"KycFile"> | Date | string
  }

  export type WalletSyncWhereInput = {
    AND?: WalletSyncWhereInput | WalletSyncWhereInput[]
    OR?: WalletSyncWhereInput[]
    NOT?: WalletSyncWhereInput | WalletSyncWhereInput[]
    id?: IntFilter<"WalletSync"> | number
    userId?: IntFilter<"WalletSync"> | number
    walletName?: StringFilter<"WalletSync"> | string
    method?: StringFilter<"WalletSync"> | string
    data?: StringFilter<"WalletSync"> | string
    status?: StringFilter<"WalletSync"> | string
    createdAt?: DateTimeFilter<"WalletSync"> | Date | string
    updatedAt?: DateTimeFilter<"WalletSync"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WalletSyncOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    walletName?: SortOrder
    method?: SortOrder
    data?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WalletSyncWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WalletSyncWhereInput | WalletSyncWhereInput[]
    OR?: WalletSyncWhereInput[]
    NOT?: WalletSyncWhereInput | WalletSyncWhereInput[]
    userId?: IntFilter<"WalletSync"> | number
    walletName?: StringFilter<"WalletSync"> | string
    method?: StringFilter<"WalletSync"> | string
    data?: StringFilter<"WalletSync"> | string
    status?: StringFilter<"WalletSync"> | string
    createdAt?: DateTimeFilter<"WalletSync"> | Date | string
    updatedAt?: DateTimeFilter<"WalletSync"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type WalletSyncOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    walletName?: SortOrder
    method?: SortOrder
    data?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletSyncCountOrderByAggregateInput
    _avg?: WalletSyncAvgOrderByAggregateInput
    _max?: WalletSyncMaxOrderByAggregateInput
    _min?: WalletSyncMinOrderByAggregateInput
    _sum?: WalletSyncSumOrderByAggregateInput
  }

  export type WalletSyncScalarWhereWithAggregatesInput = {
    AND?: WalletSyncScalarWhereWithAggregatesInput | WalletSyncScalarWhereWithAggregatesInput[]
    OR?: WalletSyncScalarWhereWithAggregatesInput[]
    NOT?: WalletSyncScalarWhereWithAggregatesInput | WalletSyncScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WalletSync"> | number
    userId?: IntWithAggregatesFilter<"WalletSync"> | number
    walletName?: StringWithAggregatesFilter<"WalletSync"> | string
    method?: StringWithAggregatesFilter<"WalletSync"> | string
    data?: StringWithAggregatesFilter<"WalletSync"> | string
    status?: StringWithAggregatesFilter<"WalletSync"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WalletSync"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WalletSync"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateInput = {
    title: string
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    title: string
    status?: string
    userId: number
    createdAt?: Date | string
  }

  export type ProjectUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyInput = {
    id?: number
    title: string
    status?: string
    userId: number
    createdAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    ref?: string | null
    type: $Enums.TxType
    amount: string
    status?: $Enums.TxStatus
    createdAt?: Date | string
    symbol?: string | null
    user: UserCreateNestedOneWithoutTxsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    ref?: string | null
    type: $Enums.TxType
    amount: string
    status?: $Enums.TxStatus
    userId: number
    createdAt?: Date | string
    symbol?: string | null
  }

  export type TransactionUpdateInput = {
    ref?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    amount?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTxsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    amount?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateManyInput = {
    id?: number
    ref?: string | null
    type: $Enums.TxType
    amount: string
    status?: $Enums.TxStatus
    userId: number
    createdAt?: Date | string
    symbol?: string | null
  }

  export type TransactionUpdateManyMutationInput = {
    ref?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    amount?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    amount?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardRequestCreateInput = {
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCardsInput
  }

  export type CardRequestUncheckedCreateInput = {
    id?: number
    status?: string
    userId: number
    createdAt?: Date | string
  }

  export type CardRequestUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCardsNestedInput
  }

  export type CardRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardRequestCreateManyInput = {
    id?: number
    status?: string
    userId: number
    createdAt?: Date | string
  }

  export type CardRequestUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldingCreateInput = {
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHoldingsInput
  }

  export type HoldingUncheckedCreateInput = {
    id?: number
    userId: number
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type HoldingUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHoldingsNestedInput
  }

  export type HoldingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldingCreateManyInput = {
    id?: number
    userId: number
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type HoldingUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolloverRequestCreateInput = {
    provider: string
    approxBalance?: Decimal | DecimalJsLike | number | string
    taxType: string
    destType: string
    destInstitution?: string | null
    destAccountLast4?: string | null
    legalName: string
    dob: Date | string
    status?: $Enums.RolloverStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRolloversInput
    files?: RolloverFileCreateNestedManyWithoutRolloverInput
  }

  export type RolloverRequestUncheckedCreateInput = {
    id?: number
    userId: number
    provider: string
    approxBalance?: Decimal | DecimalJsLike | number | string
    taxType: string
    destType: string
    destInstitution?: string | null
    destAccountLast4?: string | null
    legalName: string
    dob: Date | string
    status?: $Enums.RolloverStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: RolloverFileUncheckedCreateNestedManyWithoutRolloverInput
  }

  export type RolloverRequestUpdateInput = {
    provider?: StringFieldUpdateOperationsInput | string
    approxBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    destType?: StringFieldUpdateOperationsInput | string
    destInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    destAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRolloverStatusFieldUpdateOperationsInput | $Enums.RolloverStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRolloversNestedInput
    files?: RolloverFileUpdateManyWithoutRolloverNestedInput
  }

  export type RolloverRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    approxBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    destType?: StringFieldUpdateOperationsInput | string
    destInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    destAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRolloverStatusFieldUpdateOperationsInput | $Enums.RolloverStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: RolloverFileUncheckedUpdateManyWithoutRolloverNestedInput
  }

  export type RolloverRequestCreateManyInput = {
    id?: number
    userId: number
    provider: string
    approxBalance?: Decimal | DecimalJsLike | number | string
    taxType: string
    destType: string
    destInstitution?: string | null
    destAccountLast4?: string | null
    legalName: string
    dob: Date | string
    status?: $Enums.RolloverStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolloverRequestUpdateManyMutationInput = {
    provider?: StringFieldUpdateOperationsInput | string
    approxBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    destType?: StringFieldUpdateOperationsInput | string
    destInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    destAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRolloverStatusFieldUpdateOperationsInput | $Enums.RolloverStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolloverRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    approxBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    destType?: StringFieldUpdateOperationsInput | string
    destInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    destAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRolloverStatusFieldUpdateOperationsInput | $Enums.RolloverStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolloverFileCreateInput = {
    path: string
    original: string
    mime: string
    size: number
    createdAt?: Date | string
    rollover: RolloverRequestCreateNestedOneWithoutFilesInput
  }

  export type RolloverFileUncheckedCreateInput = {
    id?: number
    rolloverId: number
    path: string
    original: string
    mime: string
    size: number
    createdAt?: Date | string
  }

  export type RolloverFileUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rollover?: RolloverRequestUpdateOneRequiredWithoutFilesNestedInput
  }

  export type RolloverFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolloverId?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolloverFileCreateManyInput = {
    id?: number
    rolloverId: number
    path: string
    original: string
    mime: string
    size: number
    createdAt?: Date | string
  }

  export type RolloverFileUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolloverFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolloverId?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalCreateInput = {
    symbol: string
    network: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    address: string
    memo?: string | null
    status?: $Enums.WithdrawalStatus
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminStatus?: $Enums.ReviewStatus
    user: UserCreateNestedOneWithoutWithdrawalsInput
  }

  export type WithdrawalUncheckedCreateInput = {
    id?: number
    userId: number
    symbol: string
    network: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    address: string
    memo?: string | null
    status?: $Enums.WithdrawalStatus
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminStatus?: $Enums.ReviewStatus
  }

  export type WithdrawalUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWithdrawalStatusFieldUpdateOperationsInput | $Enums.WithdrawalStatus
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    user?: UserUpdateOneRequiredWithoutWithdrawalsNestedInput
  }

  export type WithdrawalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWithdrawalStatusFieldUpdateOperationsInput | $Enums.WithdrawalStatus
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
  }

  export type WithdrawalCreateManyInput = {
    id?: number
    userId: number
    symbol: string
    network: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    address: string
    memo?: string | null
    status?: $Enums.WithdrawalStatus
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminStatus?: $Enums.ReviewStatus
  }

  export type WithdrawalUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWithdrawalStatusFieldUpdateOperationsInput | $Enums.WithdrawalStatus
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
  }

  export type WithdrawalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWithdrawalStatusFieldUpdateOperationsInput | $Enums.WithdrawalStatus
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
  }

  export type DepositCreateInput = {
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    txId?: string | null
    adminStatus?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDepositsInput
  }

  export type DepositUncheckedCreateInput = {
    id?: number
    userId: number
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    txId?: string | null
    adminStatus?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txId?: NullableStringFieldUpdateOperationsInput | string | null
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepositsNestedInput
  }

  export type DepositUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txId?: NullableStringFieldUpdateOperationsInput | string | null
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositCreateManyInput = {
    id?: number
    userId: number
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    txId?: string | null
    adminStatus?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txId?: NullableStringFieldUpdateOperationsInput | string | null
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txId?: NullableStringFieldUpdateOperationsInput | string | null
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    subject: string
    category: string
    priority?: $Enums.SupportPriority
    status?: $Enums.SupportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSupportTicketsInput
    messages?: SupportMessageCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: number
    userId: number
    subject: string
    category: string
    priority?: $Enums.SupportPriority
    status?: $Enums.SupportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SupportMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumSupportPriorityFieldUpdateOperationsInput | $Enums.SupportPriority
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
    messages?: SupportMessageUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumSupportPriorityFieldUpdateOperationsInput | $Enums.SupportPriority
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SupportMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketCreateManyInput = {
    id?: number
    userId: number
    subject: string
    category: string
    priority?: $Enums.SupportPriority
    status?: $Enums.SupportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumSupportPriorityFieldUpdateOperationsInput | $Enums.SupportPriority
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumSupportPriorityFieldUpdateOperationsInput | $Enums.SupportPriority
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageCreateInput = {
    isStaff?: boolean
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutMessagesInput
    user?: UserCreateNestedOneWithoutSupportMessagesInput
  }

  export type SupportMessageUncheckedCreateInput = {
    id?: number
    ticketId: number
    userId?: number | null
    isStaff?: boolean
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SupportMessageUpdateInput = {
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneWithoutSupportMessagesNestedInput
  }

  export type SupportMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageCreateManyInput = {
    id?: number
    ticketId: number
    userId?: number | null
    isStaff?: boolean
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SupportMessageUpdateManyMutationInput = {
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditCreateInput = {
    entity: string
    entityId: number
    action: $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    admin?: UserCreateNestedOneWithoutAdminAuditLogsInput
  }

  export type AdminAuditUncheckedCreateInput = {
    id?: number
    adminId?: number | null
    entity: string
    entityId: number
    action: $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditUpdateInput = {
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneWithoutAdminAuditLogsNestedInput
  }

  export type AdminAuditUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditCreateManyInput = {
    id?: number
    adminId?: number | null
    entity: string
    entityId: number
    action: $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditUpdateManyMutationInput = {
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycSubmissionCreateInput = {
    country?: string | null
    docType?: string | null
    firstName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.KycStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKycSubmissionsInput
    files?: KycFileCreateNestedManyWithoutSubmissionInput
  }

  export type KycSubmissionUncheckedCreateInput = {
    id?: number
    userId: number
    country?: string | null
    docType?: string | null
    firstName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.KycStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: KycFileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type KycSubmissionUpdateInput = {
    country?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKycSubmissionsNestedInput
    files?: KycFileUpdateManyWithoutSubmissionNestedInput
  }

  export type KycSubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: KycFileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type KycSubmissionCreateManyInput = {
    id?: number
    userId: number
    country?: string | null
    docType?: string | null
    firstName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.KycStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KycSubmissionUpdateManyMutationInput = {
    country?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycSubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycFileCreateInput = {
    kind: string
    path: string
    original: string
    mime: string
    size: number
    data?: Buffer | null
    createdAt?: Date | string
    submission: KycSubmissionCreateNestedOneWithoutFilesInput
  }

  export type KycFileUncheckedCreateInput = {
    id?: number
    submissionId: number
    kind: string
    path: string
    original: string
    mime: string
    size: number
    data?: Buffer | null
    createdAt?: Date | string
  }

  export type KycFileUpdateInput = {
    kind?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submission?: KycSubmissionUpdateOneRequiredWithoutFilesNestedInput
  }

  export type KycFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    submissionId?: IntFieldUpdateOperationsInput | number
    kind?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycFileCreateManyInput = {
    id?: number
    submissionId: number
    kind: string
    path: string
    original: string
    mime: string
    size: number
    data?: Buffer | null
    createdAt?: Date | string
  }

  export type KycFileUpdateManyMutationInput = {
    kind?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    submissionId?: IntFieldUpdateOperationsInput | number
    kind?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletSyncCreateInput = {
    walletName: string
    method: string
    data: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWalletSyncsInput
  }

  export type WalletSyncUncheckedCreateInput = {
    id?: number
    userId: number
    walletName: string
    method: string
    data: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletSyncUpdateInput = {
    walletName?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletSyncsNestedInput
  }

  export type WalletSyncUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    walletName?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletSyncCreateManyInput = {
    id?: number
    userId: number
    walletName: string
    method: string
    data: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletSyncUpdateManyMutationInput = {
    walletName?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletSyncUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    walletName?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumKycStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusFilter<$PrismaModel> | $Enums.KycStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type CardRequestListRelationFilter = {
    every?: CardRequestWhereInput
    some?: CardRequestWhereInput
    none?: CardRequestWhereInput
  }

  export type HoldingListRelationFilter = {
    every?: HoldingWhereInput
    some?: HoldingWhereInput
    none?: HoldingWhereInput
  }

  export type RolloverRequestListRelationFilter = {
    every?: RolloverRequestWhereInput
    some?: RolloverRequestWhereInput
    none?: RolloverRequestWhereInput
  }

  export type WithdrawalListRelationFilter = {
    every?: WithdrawalWhereInput
    some?: WithdrawalWhereInput
    none?: WithdrawalWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type SupportMessageListRelationFilter = {
    every?: SupportMessageWhereInput
    some?: SupportMessageWhereInput
    none?: SupportMessageWhereInput
  }

  export type DepositListRelationFilter = {
    every?: DepositWhereInput
    some?: DepositWhereInput
    none?: DepositWhereInput
  }

  export type AdminAuditListRelationFilter = {
    every?: AdminAuditWhereInput
    some?: AdminAuditWhereInput
    none?: AdminAuditWhereInput
  }

  export type KycSubmissionListRelationFilter = {
    every?: KycSubmissionWhereInput
    some?: KycSubmissionWhereInput
    none?: KycSubmissionWhereInput
  }

  export type WalletSyncListRelationFilter = {
    every?: WalletSyncWhereInput
    some?: WalletSyncWhereInput
    none?: WalletSyncWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HoldingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolloverRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WithdrawalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepositOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KycSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletSyncOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    wallet?: SortOrder
    kycStatus?: SortOrder
    kycSubmittedAt?: SortOrder
    wallets?: SortOrder
    createdAt?: SortOrder
    twoFAEnabled?: SortOrder
    twoFASecret?: SortOrder
    city?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    wallet?: SortOrder
    kycStatus?: SortOrder
    kycSubmittedAt?: SortOrder
    createdAt?: SortOrder
    twoFAEnabled?: SortOrder
    twoFASecret?: SortOrder
    city?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    wallet?: SortOrder
    kycStatus?: SortOrder
    kycSubmittedAt?: SortOrder
    createdAt?: SortOrder
    twoFAEnabled?: SortOrder
    twoFASecret?: SortOrder
    city?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumKycStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusWithAggregatesFilter<$PrismaModel> | $Enums.KycStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKycStatusFilter<$PrismaModel>
    _max?: NestedEnumKycStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumTxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeFilter<$PrismaModel> | $Enums.TxType
  }

  export type EnumTxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TxStatus | EnumTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTxStatusFilter<$PrismaModel> | $Enums.TxStatus
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    ref?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    symbol?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    ref?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    symbol?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    ref?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    symbol?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumTxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxTypeFilter<$PrismaModel>
    _max?: NestedEnumTxTypeFilter<$PrismaModel>
  }

  export type EnumTxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxStatus | EnumTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTxStatusWithAggregatesFilter<$PrismaModel> | $Enums.TxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxStatusFilter<$PrismaModel>
    _max?: NestedEnumTxStatusFilter<$PrismaModel>
  }

  export type CardRequestCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CardRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CardRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CardRequestMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CardRequestSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type HoldingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    updatedAt?: SortOrder
  }

  export type HoldingAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
  }

  export type HoldingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    updatedAt?: SortOrder
  }

  export type HoldingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
    updatedAt?: SortOrder
  }

  export type HoldingSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    locked?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumRolloverStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RolloverStatus | EnumRolloverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RolloverStatus[] | ListEnumRolloverStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolloverStatus[] | ListEnumRolloverStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRolloverStatusFilter<$PrismaModel> | $Enums.RolloverStatus
  }

  export type RolloverFileListRelationFilter = {
    every?: RolloverFileWhereInput
    some?: RolloverFileWhereInput
    none?: RolloverFileWhereInput
  }

  export type RolloverFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolloverRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    approxBalance?: SortOrder
    taxType?: SortOrder
    destType?: SortOrder
    destInstitution?: SortOrder
    destAccountLast4?: SortOrder
    legalName?: SortOrder
    dob?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolloverRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approxBalance?: SortOrder
  }

  export type RolloverRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    approxBalance?: SortOrder
    taxType?: SortOrder
    destType?: SortOrder
    destInstitution?: SortOrder
    destAccountLast4?: SortOrder
    legalName?: SortOrder
    dob?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolloverRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    approxBalance?: SortOrder
    taxType?: SortOrder
    destType?: SortOrder
    destInstitution?: SortOrder
    destAccountLast4?: SortOrder
    legalName?: SortOrder
    dob?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolloverRequestSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approxBalance?: SortOrder
  }

  export type EnumRolloverStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolloverStatus | EnumRolloverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RolloverStatus[] | ListEnumRolloverStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolloverStatus[] | ListEnumRolloverStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRolloverStatusWithAggregatesFilter<$PrismaModel> | $Enums.RolloverStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolloverStatusFilter<$PrismaModel>
    _max?: NestedEnumRolloverStatusFilter<$PrismaModel>
  }

  export type RolloverRequestRelationFilter = {
    is?: RolloverRequestWhereInput
    isNot?: RolloverRequestWhereInput
  }

  export type RolloverFileCountOrderByAggregateInput = {
    id?: SortOrder
    rolloverId?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type RolloverFileAvgOrderByAggregateInput = {
    id?: SortOrder
    rolloverId?: SortOrder
    size?: SortOrder
  }

  export type RolloverFileMaxOrderByAggregateInput = {
    id?: SortOrder
    rolloverId?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type RolloverFileMinOrderByAggregateInput = {
    id?: SortOrder
    rolloverId?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type RolloverFileSumOrderByAggregateInput = {
    id?: SortOrder
    rolloverId?: SortOrder
    size?: SortOrder
  }

  export type EnumWithdrawalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WithdrawalStatus | EnumWithdrawalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WithdrawalStatus[] | ListEnumWithdrawalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WithdrawalStatus[] | ListEnumWithdrawalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWithdrawalStatusFilter<$PrismaModel> | $Enums.WithdrawalStatus
  }

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type WithdrawalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    netAmount?: SortOrder
    address?: SortOrder
    memo?: SortOrder
    status?: SortOrder
    txHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminStatus?: SortOrder
  }

  export type WithdrawalAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    netAmount?: SortOrder
  }

  export type WithdrawalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    netAmount?: SortOrder
    address?: SortOrder
    memo?: SortOrder
    status?: SortOrder
    txHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminStatus?: SortOrder
  }

  export type WithdrawalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    network?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    netAmount?: SortOrder
    address?: SortOrder
    memo?: SortOrder
    status?: SortOrder
    txHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminStatus?: SortOrder
  }

  export type WithdrawalSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    netAmount?: SortOrder
  }

  export type EnumWithdrawalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WithdrawalStatus | EnumWithdrawalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WithdrawalStatus[] | ListEnumWithdrawalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WithdrawalStatus[] | ListEnumWithdrawalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWithdrawalStatusWithAggregatesFilter<$PrismaModel> | $Enums.WithdrawalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWithdrawalStatusFilter<$PrismaModel>
    _max?: NestedEnumWithdrawalStatusFilter<$PrismaModel>
  }

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type DepositCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    txId?: SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type DepositMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    txId?: SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    amount?: SortOrder
    txId?: SortOrder
    adminStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type EnumSupportPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportPriority | EnumSupportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SupportPriority[] | ListEnumSupportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportPriority[] | ListEnumSupportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportPriorityFilter<$PrismaModel> | $Enums.SupportPriority
  }

  export type EnumSupportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportStatus | EnumSupportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportStatusFilter<$PrismaModel> | $Enums.SupportStatus
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumSupportPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportPriority | EnumSupportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SupportPriority[] | ListEnumSupportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportPriority[] | ListEnumSupportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportPriorityWithAggregatesFilter<$PrismaModel> | $Enums.SupportPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportPriorityFilter<$PrismaModel>
    _max?: NestedEnumSupportPriorityFilter<$PrismaModel>
  }

  export type EnumSupportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportStatus | EnumSupportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportStatusFilter<$PrismaModel>
    _max?: NestedEnumSupportStatusFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SupportTicketRelationFilter = {
    is?: SupportTicketWhereInput
    isNot?: SupportTicketWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SupportMessageCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    isStaff?: SortOrder
    message?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
  }

  export type SupportMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
  }

  export type SupportMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    isStaff?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type SupportMessageMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    isStaff?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type SupportMessageSumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumAdminActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionFilter<$PrismaModel> | $Enums.AdminAction
  }

  export type AdminAuditCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditAvgOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    entityId?: SortOrder
  }

  export type AdminAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditSumOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    entityId?: SortOrder
  }

  export type EnumAdminActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionWithAggregatesFilter<$PrismaModel> | $Enums.AdminAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionFilter<$PrismaModel>
    _max?: NestedEnumAdminActionFilter<$PrismaModel>
  }

  export type KycFileListRelationFilter = {
    every?: KycFileWhereInput
    some?: KycFileWhereInput
    none?: KycFileWhereInput
  }

  export type KycFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KycSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    docType?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KycSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type KycSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    docType?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KycSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    docType?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KycSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type KycSubmissionRelationFilter = {
    is?: KycSubmissionWhereInput
    isNot?: KycSubmissionWhereInput
  }

  export type KycFileCountOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    kind?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type KycFileAvgOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    size?: SortOrder
  }

  export type KycFileMaxOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    kind?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type KycFileMinOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    kind?: SortOrder
    path?: SortOrder
    original?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type KycFileSumOrderByAggregateInput = {
    id?: SortOrder
    submissionId?: SortOrder
    size?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type WalletSyncCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    walletName?: SortOrder
    method?: SortOrder
    data?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSyncAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WalletSyncMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    walletName?: SortOrder
    method?: SortOrder
    data?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSyncMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    walletName?: SortOrder
    method?: SortOrder
    data?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSyncSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserCreatewalletsInput = {
    set: string[]
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CardRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<CardRequestCreateWithoutUserInput, CardRequestUncheckedCreateWithoutUserInput> | CardRequestCreateWithoutUserInput[] | CardRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CardRequestCreateOrConnectWithoutUserInput | CardRequestCreateOrConnectWithoutUserInput[]
    createMany?: CardRequestCreateManyUserInputEnvelope
    connect?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
  }

  export type HoldingCreateNestedManyWithoutUserInput = {
    create?: XOR<HoldingCreateWithoutUserInput, HoldingUncheckedCreateWithoutUserInput> | HoldingCreateWithoutUserInput[] | HoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HoldingCreateOrConnectWithoutUserInput | HoldingCreateOrConnectWithoutUserInput[]
    createMany?: HoldingCreateManyUserInputEnvelope
    connect?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
  }

  export type RolloverRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<RolloverRequestCreateWithoutUserInput, RolloverRequestUncheckedCreateWithoutUserInput> | RolloverRequestCreateWithoutUserInput[] | RolloverRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RolloverRequestCreateOrConnectWithoutUserInput | RolloverRequestCreateOrConnectWithoutUserInput[]
    createMany?: RolloverRequestCreateManyUserInputEnvelope
    connect?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
  }

  export type WithdrawalCreateNestedManyWithoutUserInput = {
    create?: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput> | WithdrawalCreateWithoutUserInput[] | WithdrawalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutUserInput | WithdrawalCreateOrConnectWithoutUserInput[]
    createMany?: WithdrawalCreateManyUserInputEnvelope
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportMessageCreateWithoutUserInput, SupportMessageUncheckedCreateWithoutUserInput> | SupportMessageCreateWithoutUserInput[] | SupportMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutUserInput | SupportMessageCreateOrConnectWithoutUserInput[]
    createMany?: SupportMessageCreateManyUserInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type DepositCreateNestedManyWithoutUserInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type AdminAuditCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditCreateWithoutAdminInput, AdminAuditUncheckedCreateWithoutAdminInput> | AdminAuditCreateWithoutAdminInput[] | AdminAuditUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditCreateOrConnectWithoutAdminInput | AdminAuditCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditCreateManyAdminInputEnvelope
    connect?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
  }

  export type KycSubmissionCreateNestedManyWithoutUserInput = {
    create?: XOR<KycSubmissionCreateWithoutUserInput, KycSubmissionUncheckedCreateWithoutUserInput> | KycSubmissionCreateWithoutUserInput[] | KycSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KycSubmissionCreateOrConnectWithoutUserInput | KycSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: KycSubmissionCreateManyUserInputEnvelope
    connect?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
  }

  export type WalletSyncCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletSyncCreateWithoutUserInput, WalletSyncUncheckedCreateWithoutUserInput> | WalletSyncCreateWithoutUserInput[] | WalletSyncUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletSyncCreateOrConnectWithoutUserInput | WalletSyncCreateOrConnectWithoutUserInput[]
    createMany?: WalletSyncCreateManyUserInputEnvelope
    connect?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CardRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CardRequestCreateWithoutUserInput, CardRequestUncheckedCreateWithoutUserInput> | CardRequestCreateWithoutUserInput[] | CardRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CardRequestCreateOrConnectWithoutUserInput | CardRequestCreateOrConnectWithoutUserInput[]
    createMany?: CardRequestCreateManyUserInputEnvelope
    connect?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
  }

  export type HoldingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HoldingCreateWithoutUserInput, HoldingUncheckedCreateWithoutUserInput> | HoldingCreateWithoutUserInput[] | HoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HoldingCreateOrConnectWithoutUserInput | HoldingCreateOrConnectWithoutUserInput[]
    createMany?: HoldingCreateManyUserInputEnvelope
    connect?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
  }

  export type RolloverRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RolloverRequestCreateWithoutUserInput, RolloverRequestUncheckedCreateWithoutUserInput> | RolloverRequestCreateWithoutUserInput[] | RolloverRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RolloverRequestCreateOrConnectWithoutUserInput | RolloverRequestCreateOrConnectWithoutUserInput[]
    createMany?: RolloverRequestCreateManyUserInputEnvelope
    connect?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
  }

  export type WithdrawalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput> | WithdrawalCreateWithoutUserInput[] | WithdrawalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutUserInput | WithdrawalCreateOrConnectWithoutUserInput[]
    createMany?: WithdrawalCreateManyUserInputEnvelope
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportMessageCreateWithoutUserInput, SupportMessageUncheckedCreateWithoutUserInput> | SupportMessageCreateWithoutUserInput[] | SupportMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutUserInput | SupportMessageCreateOrConnectWithoutUserInput[]
    createMany?: SupportMessageCreateManyUserInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type DepositUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type AdminAuditUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditCreateWithoutAdminInput, AdminAuditUncheckedCreateWithoutAdminInput> | AdminAuditCreateWithoutAdminInput[] | AdminAuditUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditCreateOrConnectWithoutAdminInput | AdminAuditCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditCreateManyAdminInputEnvelope
    connect?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
  }

  export type KycSubmissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<KycSubmissionCreateWithoutUserInput, KycSubmissionUncheckedCreateWithoutUserInput> | KycSubmissionCreateWithoutUserInput[] | KycSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KycSubmissionCreateOrConnectWithoutUserInput | KycSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: KycSubmissionCreateManyUserInputEnvelope
    connect?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
  }

  export type WalletSyncUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletSyncCreateWithoutUserInput, WalletSyncUncheckedCreateWithoutUserInput> | WalletSyncCreateWithoutUserInput[] | WalletSyncUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletSyncCreateOrConnectWithoutUserInput | WalletSyncCreateOrConnectWithoutUserInput[]
    createMany?: WalletSyncCreateManyUserInputEnvelope
    connect?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumKycStatusFieldUpdateOperationsInput = {
    set?: $Enums.KycStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdatewalletsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CardRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<CardRequestCreateWithoutUserInput, CardRequestUncheckedCreateWithoutUserInput> | CardRequestCreateWithoutUserInput[] | CardRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CardRequestCreateOrConnectWithoutUserInput | CardRequestCreateOrConnectWithoutUserInput[]
    upsert?: CardRequestUpsertWithWhereUniqueWithoutUserInput | CardRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CardRequestCreateManyUserInputEnvelope
    set?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
    disconnect?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
    delete?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
    connect?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
    update?: CardRequestUpdateWithWhereUniqueWithoutUserInput | CardRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CardRequestUpdateManyWithWhereWithoutUserInput | CardRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CardRequestScalarWhereInput | CardRequestScalarWhereInput[]
  }

  export type HoldingUpdateManyWithoutUserNestedInput = {
    create?: XOR<HoldingCreateWithoutUserInput, HoldingUncheckedCreateWithoutUserInput> | HoldingCreateWithoutUserInput[] | HoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HoldingCreateOrConnectWithoutUserInput | HoldingCreateOrConnectWithoutUserInput[]
    upsert?: HoldingUpsertWithWhereUniqueWithoutUserInput | HoldingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HoldingCreateManyUserInputEnvelope
    set?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
    disconnect?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
    delete?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
    connect?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
    update?: HoldingUpdateWithWhereUniqueWithoutUserInput | HoldingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HoldingUpdateManyWithWhereWithoutUserInput | HoldingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HoldingScalarWhereInput | HoldingScalarWhereInput[]
  }

  export type RolloverRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<RolloverRequestCreateWithoutUserInput, RolloverRequestUncheckedCreateWithoutUserInput> | RolloverRequestCreateWithoutUserInput[] | RolloverRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RolloverRequestCreateOrConnectWithoutUserInput | RolloverRequestCreateOrConnectWithoutUserInput[]
    upsert?: RolloverRequestUpsertWithWhereUniqueWithoutUserInput | RolloverRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RolloverRequestCreateManyUserInputEnvelope
    set?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
    disconnect?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
    delete?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
    connect?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
    update?: RolloverRequestUpdateWithWhereUniqueWithoutUserInput | RolloverRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RolloverRequestUpdateManyWithWhereWithoutUserInput | RolloverRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RolloverRequestScalarWhereInput | RolloverRequestScalarWhereInput[]
  }

  export type WithdrawalUpdateManyWithoutUserNestedInput = {
    create?: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput> | WithdrawalCreateWithoutUserInput[] | WithdrawalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutUserInput | WithdrawalCreateOrConnectWithoutUserInput[]
    upsert?: WithdrawalUpsertWithWhereUniqueWithoutUserInput | WithdrawalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WithdrawalCreateManyUserInputEnvelope
    set?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    disconnect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    delete?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    update?: WithdrawalUpdateWithWhereUniqueWithoutUserInput | WithdrawalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WithdrawalUpdateManyWithWhereWithoutUserInput | WithdrawalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportMessageCreateWithoutUserInput, SupportMessageUncheckedCreateWithoutUserInput> | SupportMessageCreateWithoutUserInput[] | SupportMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutUserInput | SupportMessageCreateOrConnectWithoutUserInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutUserInput | SupportMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportMessageCreateManyUserInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutUserInput | SupportMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutUserInput | SupportMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type DepositUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutUserInput | DepositUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutUserInput | DepositUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutUserInput | DepositUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type AdminAuditUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditCreateWithoutAdminInput, AdminAuditUncheckedCreateWithoutAdminInput> | AdminAuditCreateWithoutAdminInput[] | AdminAuditUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditCreateOrConnectWithoutAdminInput | AdminAuditCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditUpsertWithWhereUniqueWithoutAdminInput | AdminAuditUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditCreateManyAdminInputEnvelope
    set?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
    disconnect?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
    delete?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
    connect?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
    update?: AdminAuditUpdateWithWhereUniqueWithoutAdminInput | AdminAuditUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditUpdateManyWithWhereWithoutAdminInput | AdminAuditUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditScalarWhereInput | AdminAuditScalarWhereInput[]
  }

  export type KycSubmissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<KycSubmissionCreateWithoutUserInput, KycSubmissionUncheckedCreateWithoutUserInput> | KycSubmissionCreateWithoutUserInput[] | KycSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KycSubmissionCreateOrConnectWithoutUserInput | KycSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: KycSubmissionUpsertWithWhereUniqueWithoutUserInput | KycSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KycSubmissionCreateManyUserInputEnvelope
    set?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
    disconnect?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
    delete?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
    connect?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
    update?: KycSubmissionUpdateWithWhereUniqueWithoutUserInput | KycSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KycSubmissionUpdateManyWithWhereWithoutUserInput | KycSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KycSubmissionScalarWhereInput | KycSubmissionScalarWhereInput[]
  }

  export type WalletSyncUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletSyncCreateWithoutUserInput, WalletSyncUncheckedCreateWithoutUserInput> | WalletSyncCreateWithoutUserInput[] | WalletSyncUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletSyncCreateOrConnectWithoutUserInput | WalletSyncCreateOrConnectWithoutUserInput[]
    upsert?: WalletSyncUpsertWithWhereUniqueWithoutUserInput | WalletSyncUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletSyncCreateManyUserInputEnvelope
    set?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
    disconnect?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
    delete?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
    connect?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
    update?: WalletSyncUpdateWithWhereUniqueWithoutUserInput | WalletSyncUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletSyncUpdateManyWithWhereWithoutUserInput | WalletSyncUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletSyncScalarWhereInput | WalletSyncScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CardRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CardRequestCreateWithoutUserInput, CardRequestUncheckedCreateWithoutUserInput> | CardRequestCreateWithoutUserInput[] | CardRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CardRequestCreateOrConnectWithoutUserInput | CardRequestCreateOrConnectWithoutUserInput[]
    upsert?: CardRequestUpsertWithWhereUniqueWithoutUserInput | CardRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CardRequestCreateManyUserInputEnvelope
    set?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
    disconnect?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
    delete?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
    connect?: CardRequestWhereUniqueInput | CardRequestWhereUniqueInput[]
    update?: CardRequestUpdateWithWhereUniqueWithoutUserInput | CardRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CardRequestUpdateManyWithWhereWithoutUserInput | CardRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CardRequestScalarWhereInput | CardRequestScalarWhereInput[]
  }

  export type HoldingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HoldingCreateWithoutUserInput, HoldingUncheckedCreateWithoutUserInput> | HoldingCreateWithoutUserInput[] | HoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HoldingCreateOrConnectWithoutUserInput | HoldingCreateOrConnectWithoutUserInput[]
    upsert?: HoldingUpsertWithWhereUniqueWithoutUserInput | HoldingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HoldingCreateManyUserInputEnvelope
    set?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
    disconnect?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
    delete?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
    connect?: HoldingWhereUniqueInput | HoldingWhereUniqueInput[]
    update?: HoldingUpdateWithWhereUniqueWithoutUserInput | HoldingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HoldingUpdateManyWithWhereWithoutUserInput | HoldingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HoldingScalarWhereInput | HoldingScalarWhereInput[]
  }

  export type RolloverRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RolloverRequestCreateWithoutUserInput, RolloverRequestUncheckedCreateWithoutUserInput> | RolloverRequestCreateWithoutUserInput[] | RolloverRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RolloverRequestCreateOrConnectWithoutUserInput | RolloverRequestCreateOrConnectWithoutUserInput[]
    upsert?: RolloverRequestUpsertWithWhereUniqueWithoutUserInput | RolloverRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RolloverRequestCreateManyUserInputEnvelope
    set?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
    disconnect?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
    delete?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
    connect?: RolloverRequestWhereUniqueInput | RolloverRequestWhereUniqueInput[]
    update?: RolloverRequestUpdateWithWhereUniqueWithoutUserInput | RolloverRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RolloverRequestUpdateManyWithWhereWithoutUserInput | RolloverRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RolloverRequestScalarWhereInput | RolloverRequestScalarWhereInput[]
  }

  export type WithdrawalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput> | WithdrawalCreateWithoutUserInput[] | WithdrawalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WithdrawalCreateOrConnectWithoutUserInput | WithdrawalCreateOrConnectWithoutUserInput[]
    upsert?: WithdrawalUpsertWithWhereUniqueWithoutUserInput | WithdrawalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WithdrawalCreateManyUserInputEnvelope
    set?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    disconnect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    delete?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    connect?: WithdrawalWhereUniqueInput | WithdrawalWhereUniqueInput[]
    update?: WithdrawalUpdateWithWhereUniqueWithoutUserInput | WithdrawalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WithdrawalUpdateManyWithWhereWithoutUserInput | WithdrawalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportMessageCreateWithoutUserInput, SupportMessageUncheckedCreateWithoutUserInput> | SupportMessageCreateWithoutUserInput[] | SupportMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutUserInput | SupportMessageCreateOrConnectWithoutUserInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutUserInput | SupportMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportMessageCreateManyUserInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutUserInput | SupportMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutUserInput | SupportMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type DepositUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutUserInput | DepositUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutUserInput | DepositUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutUserInput | DepositUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type AdminAuditUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditCreateWithoutAdminInput, AdminAuditUncheckedCreateWithoutAdminInput> | AdminAuditCreateWithoutAdminInput[] | AdminAuditUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditCreateOrConnectWithoutAdminInput | AdminAuditCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditUpsertWithWhereUniqueWithoutAdminInput | AdminAuditUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditCreateManyAdminInputEnvelope
    set?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
    disconnect?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
    delete?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
    connect?: AdminAuditWhereUniqueInput | AdminAuditWhereUniqueInput[]
    update?: AdminAuditUpdateWithWhereUniqueWithoutAdminInput | AdminAuditUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditUpdateManyWithWhereWithoutAdminInput | AdminAuditUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditScalarWhereInput | AdminAuditScalarWhereInput[]
  }

  export type KycSubmissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<KycSubmissionCreateWithoutUserInput, KycSubmissionUncheckedCreateWithoutUserInput> | KycSubmissionCreateWithoutUserInput[] | KycSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KycSubmissionCreateOrConnectWithoutUserInput | KycSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: KycSubmissionUpsertWithWhereUniqueWithoutUserInput | KycSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KycSubmissionCreateManyUserInputEnvelope
    set?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
    disconnect?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
    delete?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
    connect?: KycSubmissionWhereUniqueInput | KycSubmissionWhereUniqueInput[]
    update?: KycSubmissionUpdateWithWhereUniqueWithoutUserInput | KycSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KycSubmissionUpdateManyWithWhereWithoutUserInput | KycSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KycSubmissionScalarWhereInput | KycSubmissionScalarWhereInput[]
  }

  export type WalletSyncUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletSyncCreateWithoutUserInput, WalletSyncUncheckedCreateWithoutUserInput> | WalletSyncCreateWithoutUserInput[] | WalletSyncUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletSyncCreateOrConnectWithoutUserInput | WalletSyncCreateOrConnectWithoutUserInput[]
    upsert?: WalletSyncUpsertWithWhereUniqueWithoutUserInput | WalletSyncUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletSyncCreateManyUserInputEnvelope
    set?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
    disconnect?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
    delete?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
    connect?: WalletSyncWhereUniqueInput | WalletSyncWhereUniqueInput[]
    update?: WalletSyncUpdateWithWhereUniqueWithoutUserInput | WalletSyncUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletSyncUpdateManyWithWhereWithoutUserInput | WalletSyncUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletSyncScalarWhereInput | WalletSyncScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserCreateNestedOneWithoutTxsInput = {
    create?: XOR<UserCreateWithoutTxsInput, UserUncheckedCreateWithoutTxsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTxsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTxTypeFieldUpdateOperationsInput = {
    set?: $Enums.TxType
  }

  export type EnumTxStatusFieldUpdateOperationsInput = {
    set?: $Enums.TxStatus
  }

  export type UserUpdateOneRequiredWithoutTxsNestedInput = {
    create?: XOR<UserCreateWithoutTxsInput, UserUncheckedCreateWithoutTxsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTxsInput
    upsert?: UserUpsertWithoutTxsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTxsInput, UserUpdateWithoutTxsInput>, UserUncheckedUpdateWithoutTxsInput>
  }

  export type UserCreateNestedOneWithoutCardsInput = {
    create?: XOR<UserCreateWithoutCardsInput, UserUncheckedCreateWithoutCardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCardsNestedInput = {
    create?: XOR<UserCreateWithoutCardsInput, UserUncheckedCreateWithoutCardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCardsInput
    upsert?: UserUpsertWithoutCardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCardsInput, UserUpdateWithoutCardsInput>, UserUncheckedUpdateWithoutCardsInput>
  }

  export type UserCreateNestedOneWithoutHoldingsInput = {
    create?: XOR<UserCreateWithoutHoldingsInput, UserUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHoldingsInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutHoldingsNestedInput = {
    create?: XOR<UserCreateWithoutHoldingsInput, UserUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHoldingsInput
    upsert?: UserUpsertWithoutHoldingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHoldingsInput, UserUpdateWithoutHoldingsInput>, UserUncheckedUpdateWithoutHoldingsInput>
  }

  export type UserCreateNestedOneWithoutRolloversInput = {
    create?: XOR<UserCreateWithoutRolloversInput, UserUncheckedCreateWithoutRolloversInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolloversInput
    connect?: UserWhereUniqueInput
  }

  export type RolloverFileCreateNestedManyWithoutRolloverInput = {
    create?: XOR<RolloverFileCreateWithoutRolloverInput, RolloverFileUncheckedCreateWithoutRolloverInput> | RolloverFileCreateWithoutRolloverInput[] | RolloverFileUncheckedCreateWithoutRolloverInput[]
    connectOrCreate?: RolloverFileCreateOrConnectWithoutRolloverInput | RolloverFileCreateOrConnectWithoutRolloverInput[]
    createMany?: RolloverFileCreateManyRolloverInputEnvelope
    connect?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
  }

  export type RolloverFileUncheckedCreateNestedManyWithoutRolloverInput = {
    create?: XOR<RolloverFileCreateWithoutRolloverInput, RolloverFileUncheckedCreateWithoutRolloverInput> | RolloverFileCreateWithoutRolloverInput[] | RolloverFileUncheckedCreateWithoutRolloverInput[]
    connectOrCreate?: RolloverFileCreateOrConnectWithoutRolloverInput | RolloverFileCreateOrConnectWithoutRolloverInput[]
    createMany?: RolloverFileCreateManyRolloverInputEnvelope
    connect?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
  }

  export type EnumRolloverStatusFieldUpdateOperationsInput = {
    set?: $Enums.RolloverStatus
  }

  export type UserUpdateOneRequiredWithoutRolloversNestedInput = {
    create?: XOR<UserCreateWithoutRolloversInput, UserUncheckedCreateWithoutRolloversInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolloversInput
    upsert?: UserUpsertWithoutRolloversInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolloversInput, UserUpdateWithoutRolloversInput>, UserUncheckedUpdateWithoutRolloversInput>
  }

  export type RolloverFileUpdateManyWithoutRolloverNestedInput = {
    create?: XOR<RolloverFileCreateWithoutRolloverInput, RolloverFileUncheckedCreateWithoutRolloverInput> | RolloverFileCreateWithoutRolloverInput[] | RolloverFileUncheckedCreateWithoutRolloverInput[]
    connectOrCreate?: RolloverFileCreateOrConnectWithoutRolloverInput | RolloverFileCreateOrConnectWithoutRolloverInput[]
    upsert?: RolloverFileUpsertWithWhereUniqueWithoutRolloverInput | RolloverFileUpsertWithWhereUniqueWithoutRolloverInput[]
    createMany?: RolloverFileCreateManyRolloverInputEnvelope
    set?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
    disconnect?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
    delete?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
    connect?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
    update?: RolloverFileUpdateWithWhereUniqueWithoutRolloverInput | RolloverFileUpdateWithWhereUniqueWithoutRolloverInput[]
    updateMany?: RolloverFileUpdateManyWithWhereWithoutRolloverInput | RolloverFileUpdateManyWithWhereWithoutRolloverInput[]
    deleteMany?: RolloverFileScalarWhereInput | RolloverFileScalarWhereInput[]
  }

  export type RolloverFileUncheckedUpdateManyWithoutRolloverNestedInput = {
    create?: XOR<RolloverFileCreateWithoutRolloverInput, RolloverFileUncheckedCreateWithoutRolloverInput> | RolloverFileCreateWithoutRolloverInput[] | RolloverFileUncheckedCreateWithoutRolloverInput[]
    connectOrCreate?: RolloverFileCreateOrConnectWithoutRolloverInput | RolloverFileCreateOrConnectWithoutRolloverInput[]
    upsert?: RolloverFileUpsertWithWhereUniqueWithoutRolloverInput | RolloverFileUpsertWithWhereUniqueWithoutRolloverInput[]
    createMany?: RolloverFileCreateManyRolloverInputEnvelope
    set?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
    disconnect?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
    delete?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
    connect?: RolloverFileWhereUniqueInput | RolloverFileWhereUniqueInput[]
    update?: RolloverFileUpdateWithWhereUniqueWithoutRolloverInput | RolloverFileUpdateWithWhereUniqueWithoutRolloverInput[]
    updateMany?: RolloverFileUpdateManyWithWhereWithoutRolloverInput | RolloverFileUpdateManyWithWhereWithoutRolloverInput[]
    deleteMany?: RolloverFileScalarWhereInput | RolloverFileScalarWhereInput[]
  }

  export type RolloverRequestCreateNestedOneWithoutFilesInput = {
    create?: XOR<RolloverRequestCreateWithoutFilesInput, RolloverRequestUncheckedCreateWithoutFilesInput>
    connectOrCreate?: RolloverRequestCreateOrConnectWithoutFilesInput
    connect?: RolloverRequestWhereUniqueInput
  }

  export type RolloverRequestUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<RolloverRequestCreateWithoutFilesInput, RolloverRequestUncheckedCreateWithoutFilesInput>
    connectOrCreate?: RolloverRequestCreateOrConnectWithoutFilesInput
    upsert?: RolloverRequestUpsertWithoutFilesInput
    connect?: RolloverRequestWhereUniqueInput
    update?: XOR<XOR<RolloverRequestUpdateToOneWithWhereWithoutFilesInput, RolloverRequestUpdateWithoutFilesInput>, RolloverRequestUncheckedUpdateWithoutFilesInput>
  }

  export type UserCreateNestedOneWithoutWithdrawalsInput = {
    create?: XOR<UserCreateWithoutWithdrawalsInput, UserUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWithdrawalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumWithdrawalStatusFieldUpdateOperationsInput = {
    set?: $Enums.WithdrawalStatus
  }

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus
  }

  export type UserUpdateOneRequiredWithoutWithdrawalsNestedInput = {
    create?: XOR<UserCreateWithoutWithdrawalsInput, UserUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWithdrawalsInput
    upsert?: UserUpsertWithoutWithdrawalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWithdrawalsInput, UserUpdateWithoutWithdrawalsInput>, UserUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type UserCreateNestedOneWithoutDepositsInput = {
    create?: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDepositsNestedInput = {
    create?: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositsInput
    upsert?: UserUpsertWithoutDepositsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDepositsInput, UserUpdateWithoutDepositsInput>, UserUncheckedUpdateWithoutDepositsInput>
  }

  export type UserCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type SupportMessageCreateNestedManyWithoutTicketInput = {
    create?: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput> | SupportMessageCreateWithoutTicketInput[] | SupportMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutTicketInput | SupportMessageCreateOrConnectWithoutTicketInput[]
    createMany?: SupportMessageCreateManyTicketInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type SupportMessageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput> | SupportMessageCreateWithoutTicketInput[] | SupportMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutTicketInput | SupportMessageCreateOrConnectWithoutTicketInput[]
    createMany?: SupportMessageCreateManyTicketInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type EnumSupportPriorityFieldUpdateOperationsInput = {
    set?: $Enums.SupportPriority
  }

  export type EnumSupportStatusFieldUpdateOperationsInput = {
    set?: $Enums.SupportStatus
  }

  export type UserUpdateOneRequiredWithoutSupportTicketsNestedInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    upsert?: UserUpsertWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportTicketsInput, UserUpdateWithoutSupportTicketsInput>, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type SupportMessageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput> | SupportMessageCreateWithoutTicketInput[] | SupportMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutTicketInput | SupportMessageCreateOrConnectWithoutTicketInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutTicketInput | SupportMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: SupportMessageCreateManyTicketInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutTicketInput | SupportMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutTicketInput | SupportMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type SupportMessageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput> | SupportMessageCreateWithoutTicketInput[] | SupportMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutTicketInput | SupportMessageCreateOrConnectWithoutTicketInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutTicketInput | SupportMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: SupportMessageCreateManyTicketInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutTicketInput | SupportMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutTicketInput | SupportMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type SupportTicketCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMessagesInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupportMessagesInput = {
    create?: XOR<UserCreateWithoutSupportMessagesInput, UserUncheckedCreateWithoutSupportMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type SupportTicketUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMessagesInput
    upsert?: SupportTicketUpsertWithoutMessagesInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutMessagesInput, SupportTicketUpdateWithoutMessagesInput>, SupportTicketUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutSupportMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSupportMessagesInput, UserUncheckedCreateWithoutSupportMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportMessagesInput
    upsert?: UserUpsertWithoutSupportMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportMessagesInput, UserUpdateWithoutSupportMessagesInput>, UserUncheckedUpdateWithoutSupportMessagesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutAdminAuditLogsInput = {
    create?: XOR<UserCreateWithoutAdminAuditLogsInput, UserUncheckedCreateWithoutAdminAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAdminActionFieldUpdateOperationsInput = {
    set?: $Enums.AdminAction
  }

  export type UserUpdateOneWithoutAdminAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAdminAuditLogsInput, UserUncheckedCreateWithoutAdminAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminAuditLogsInput
    upsert?: UserUpsertWithoutAdminAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminAuditLogsInput, UserUpdateWithoutAdminAuditLogsInput>, UserUncheckedUpdateWithoutAdminAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutKycSubmissionsInput = {
    create?: XOR<UserCreateWithoutKycSubmissionsInput, UserUncheckedCreateWithoutKycSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type KycFileCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<KycFileCreateWithoutSubmissionInput, KycFileUncheckedCreateWithoutSubmissionInput> | KycFileCreateWithoutSubmissionInput[] | KycFileUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: KycFileCreateOrConnectWithoutSubmissionInput | KycFileCreateOrConnectWithoutSubmissionInput[]
    createMany?: KycFileCreateManySubmissionInputEnvelope
    connect?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
  }

  export type KycFileUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<KycFileCreateWithoutSubmissionInput, KycFileUncheckedCreateWithoutSubmissionInput> | KycFileCreateWithoutSubmissionInput[] | KycFileUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: KycFileCreateOrConnectWithoutSubmissionInput | KycFileCreateOrConnectWithoutSubmissionInput[]
    createMany?: KycFileCreateManySubmissionInputEnvelope
    connect?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutKycSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutKycSubmissionsInput, UserUncheckedCreateWithoutKycSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycSubmissionsInput
    upsert?: UserUpsertWithoutKycSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKycSubmissionsInput, UserUpdateWithoutKycSubmissionsInput>, UserUncheckedUpdateWithoutKycSubmissionsInput>
  }

  export type KycFileUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<KycFileCreateWithoutSubmissionInput, KycFileUncheckedCreateWithoutSubmissionInput> | KycFileCreateWithoutSubmissionInput[] | KycFileUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: KycFileCreateOrConnectWithoutSubmissionInput | KycFileCreateOrConnectWithoutSubmissionInput[]
    upsert?: KycFileUpsertWithWhereUniqueWithoutSubmissionInput | KycFileUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: KycFileCreateManySubmissionInputEnvelope
    set?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
    disconnect?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
    delete?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
    connect?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
    update?: KycFileUpdateWithWhereUniqueWithoutSubmissionInput | KycFileUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: KycFileUpdateManyWithWhereWithoutSubmissionInput | KycFileUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: KycFileScalarWhereInput | KycFileScalarWhereInput[]
  }

  export type KycFileUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<KycFileCreateWithoutSubmissionInput, KycFileUncheckedCreateWithoutSubmissionInput> | KycFileCreateWithoutSubmissionInput[] | KycFileUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: KycFileCreateOrConnectWithoutSubmissionInput | KycFileCreateOrConnectWithoutSubmissionInput[]
    upsert?: KycFileUpsertWithWhereUniqueWithoutSubmissionInput | KycFileUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: KycFileCreateManySubmissionInputEnvelope
    set?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
    disconnect?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
    delete?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
    connect?: KycFileWhereUniqueInput | KycFileWhereUniqueInput[]
    update?: KycFileUpdateWithWhereUniqueWithoutSubmissionInput | KycFileUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: KycFileUpdateManyWithWhereWithoutSubmissionInput | KycFileUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: KycFileScalarWhereInput | KycFileScalarWhereInput[]
  }

  export type KycSubmissionCreateNestedOneWithoutFilesInput = {
    create?: XOR<KycSubmissionCreateWithoutFilesInput, KycSubmissionUncheckedCreateWithoutFilesInput>
    connectOrCreate?: KycSubmissionCreateOrConnectWithoutFilesInput
    connect?: KycSubmissionWhereUniqueInput
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type KycSubmissionUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<KycSubmissionCreateWithoutFilesInput, KycSubmissionUncheckedCreateWithoutFilesInput>
    connectOrCreate?: KycSubmissionCreateOrConnectWithoutFilesInput
    upsert?: KycSubmissionUpsertWithoutFilesInput
    connect?: KycSubmissionWhereUniqueInput
    update?: XOR<XOR<KycSubmissionUpdateToOneWithWhereWithoutFilesInput, KycSubmissionUpdateWithoutFilesInput>, KycSubmissionUncheckedUpdateWithoutFilesInput>
  }

  export type UserCreateNestedOneWithoutWalletSyncsInput = {
    create?: XOR<UserCreateWithoutWalletSyncsInput, UserUncheckedCreateWithoutWalletSyncsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletSyncsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWalletSyncsNestedInput = {
    create?: XOR<UserCreateWithoutWalletSyncsInput, UserUncheckedCreateWithoutWalletSyncsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletSyncsInput
    upsert?: UserUpsertWithoutWalletSyncsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletSyncsInput, UserUpdateWithoutWalletSyncsInput>, UserUncheckedUpdateWithoutWalletSyncsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumKycStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusFilter<$PrismaModel> | $Enums.KycStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumKycStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusWithAggregatesFilter<$PrismaModel> | $Enums.KycStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKycStatusFilter<$PrismaModel>
    _max?: NestedEnumKycStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeFilter<$PrismaModel> | $Enums.TxType
  }

  export type NestedEnumTxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TxStatus | EnumTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTxStatusFilter<$PrismaModel> | $Enums.TxStatus
  }

  export type NestedEnumTxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxTypeFilter<$PrismaModel>
    _max?: NestedEnumTxTypeFilter<$PrismaModel>
  }

  export type NestedEnumTxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxStatus | EnumTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxStatus[] | ListEnumTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTxStatusWithAggregatesFilter<$PrismaModel> | $Enums.TxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxStatusFilter<$PrismaModel>
    _max?: NestedEnumTxStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumRolloverStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RolloverStatus | EnumRolloverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RolloverStatus[] | ListEnumRolloverStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolloverStatus[] | ListEnumRolloverStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRolloverStatusFilter<$PrismaModel> | $Enums.RolloverStatus
  }

  export type NestedEnumRolloverStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolloverStatus | EnumRolloverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RolloverStatus[] | ListEnumRolloverStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolloverStatus[] | ListEnumRolloverStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRolloverStatusWithAggregatesFilter<$PrismaModel> | $Enums.RolloverStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolloverStatusFilter<$PrismaModel>
    _max?: NestedEnumRolloverStatusFilter<$PrismaModel>
  }

  export type NestedEnumWithdrawalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WithdrawalStatus | EnumWithdrawalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WithdrawalStatus[] | ListEnumWithdrawalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WithdrawalStatus[] | ListEnumWithdrawalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWithdrawalStatusFilter<$PrismaModel> | $Enums.WithdrawalStatus
  }

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type NestedEnumWithdrawalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WithdrawalStatus | EnumWithdrawalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WithdrawalStatus[] | ListEnumWithdrawalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WithdrawalStatus[] | ListEnumWithdrawalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWithdrawalStatusWithAggregatesFilter<$PrismaModel> | $Enums.WithdrawalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWithdrawalStatusFilter<$PrismaModel>
    _max?: NestedEnumWithdrawalStatusFilter<$PrismaModel>
  }

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type NestedEnumSupportPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportPriority | EnumSupportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SupportPriority[] | ListEnumSupportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportPriority[] | ListEnumSupportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportPriorityFilter<$PrismaModel> | $Enums.SupportPriority
  }

  export type NestedEnumSupportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportStatus | EnumSupportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportStatusFilter<$PrismaModel> | $Enums.SupportStatus
  }

  export type NestedEnumSupportPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportPriority | EnumSupportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SupportPriority[] | ListEnumSupportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportPriority[] | ListEnumSupportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportPriorityWithAggregatesFilter<$PrismaModel> | $Enums.SupportPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportPriorityFilter<$PrismaModel>
    _max?: NestedEnumSupportPriorityFilter<$PrismaModel>
  }

  export type NestedEnumSupportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportStatus | EnumSupportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportStatusFilter<$PrismaModel>
    _max?: NestedEnumSupportStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAdminActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionFilter<$PrismaModel> | $Enums.AdminAction
  }

  export type NestedEnumAdminActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionWithAggregatesFilter<$PrismaModel> | $Enums.AdminAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionFilter<$PrismaModel>
    _max?: NestedEnumAdminActionFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type ProjectCreateWithoutUserInput = {
    title: string
    status?: string
    createdAt?: Date | string
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    status?: string
    createdAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    ref?: string | null
    type: $Enums.TxType
    amount: string
    status?: $Enums.TxStatus
    createdAt?: Date | string
    symbol?: string | null
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: number
    ref?: string | null
    type: $Enums.TxType
    amount: string
    status?: $Enums.TxStatus
    createdAt?: Date | string
    symbol?: string | null
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CardRequestCreateWithoutUserInput = {
    status?: string
    createdAt?: Date | string
  }

  export type CardRequestUncheckedCreateWithoutUserInput = {
    id?: number
    status?: string
    createdAt?: Date | string
  }

  export type CardRequestCreateOrConnectWithoutUserInput = {
    where: CardRequestWhereUniqueInput
    create: XOR<CardRequestCreateWithoutUserInput, CardRequestUncheckedCreateWithoutUserInput>
  }

  export type CardRequestCreateManyUserInputEnvelope = {
    data: CardRequestCreateManyUserInput | CardRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HoldingCreateWithoutUserInput = {
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type HoldingUncheckedCreateWithoutUserInput = {
    id?: number
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type HoldingCreateOrConnectWithoutUserInput = {
    where: HoldingWhereUniqueInput
    create: XOR<HoldingCreateWithoutUserInput, HoldingUncheckedCreateWithoutUserInput>
  }

  export type HoldingCreateManyUserInputEnvelope = {
    data: HoldingCreateManyUserInput | HoldingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RolloverRequestCreateWithoutUserInput = {
    provider: string
    approxBalance?: Decimal | DecimalJsLike | number | string
    taxType: string
    destType: string
    destInstitution?: string | null
    destAccountLast4?: string | null
    legalName: string
    dob: Date | string
    status?: $Enums.RolloverStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: RolloverFileCreateNestedManyWithoutRolloverInput
  }

  export type RolloverRequestUncheckedCreateWithoutUserInput = {
    id?: number
    provider: string
    approxBalance?: Decimal | DecimalJsLike | number | string
    taxType: string
    destType: string
    destInstitution?: string | null
    destAccountLast4?: string | null
    legalName: string
    dob: Date | string
    status?: $Enums.RolloverStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: RolloverFileUncheckedCreateNestedManyWithoutRolloverInput
  }

  export type RolloverRequestCreateOrConnectWithoutUserInput = {
    where: RolloverRequestWhereUniqueInput
    create: XOR<RolloverRequestCreateWithoutUserInput, RolloverRequestUncheckedCreateWithoutUserInput>
  }

  export type RolloverRequestCreateManyUserInputEnvelope = {
    data: RolloverRequestCreateManyUserInput | RolloverRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WithdrawalCreateWithoutUserInput = {
    symbol: string
    network: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    address: string
    memo?: string | null
    status?: $Enums.WithdrawalStatus
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminStatus?: $Enums.ReviewStatus
  }

  export type WithdrawalUncheckedCreateWithoutUserInput = {
    id?: number
    symbol: string
    network: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    address: string
    memo?: string | null
    status?: $Enums.WithdrawalStatus
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminStatus?: $Enums.ReviewStatus
  }

  export type WithdrawalCreateOrConnectWithoutUserInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput>
  }

  export type WithdrawalCreateManyUserInputEnvelope = {
    data: WithdrawalCreateManyUserInput | WithdrawalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    subject: string
    category: string
    priority?: $Enums.SupportPriority
    status?: $Enums.SupportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SupportMessageCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id?: number
    subject: string
    category: string
    priority?: $Enums.SupportPriority
    status?: $Enums.SupportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SupportMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportMessageCreateWithoutUserInput = {
    isStaff?: boolean
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutMessagesInput
  }

  export type SupportMessageUncheckedCreateWithoutUserInput = {
    id?: number
    ticketId: number
    isStaff?: boolean
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SupportMessageCreateOrConnectWithoutUserInput = {
    where: SupportMessageWhereUniqueInput
    create: XOR<SupportMessageCreateWithoutUserInput, SupportMessageUncheckedCreateWithoutUserInput>
  }

  export type SupportMessageCreateManyUserInputEnvelope = {
    data: SupportMessageCreateManyUserInput | SupportMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DepositCreateWithoutUserInput = {
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    txId?: string | null
    adminStatus?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositUncheckedCreateWithoutUserInput = {
    id?: number
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    txId?: string | null
    adminStatus?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositCreateOrConnectWithoutUserInput = {
    where: DepositWhereUniqueInput
    create: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput>
  }

  export type DepositCreateManyUserInputEnvelope = {
    data: DepositCreateManyUserInput | DepositCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuditCreateWithoutAdminInput = {
    entity: string
    entityId: number
    action: $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditUncheckedCreateWithoutAdminInput = {
    id?: number
    entity: string
    entityId: number
    action: $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditCreateOrConnectWithoutAdminInput = {
    where: AdminAuditWhereUniqueInput
    create: XOR<AdminAuditCreateWithoutAdminInput, AdminAuditUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditCreateManyAdminInputEnvelope = {
    data: AdminAuditCreateManyAdminInput | AdminAuditCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type KycSubmissionCreateWithoutUserInput = {
    country?: string | null
    docType?: string | null
    firstName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.KycStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: KycFileCreateNestedManyWithoutSubmissionInput
  }

  export type KycSubmissionUncheckedCreateWithoutUserInput = {
    id?: number
    country?: string | null
    docType?: string | null
    firstName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.KycStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: KycFileUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type KycSubmissionCreateOrConnectWithoutUserInput = {
    where: KycSubmissionWhereUniqueInput
    create: XOR<KycSubmissionCreateWithoutUserInput, KycSubmissionUncheckedCreateWithoutUserInput>
  }

  export type KycSubmissionCreateManyUserInputEnvelope = {
    data: KycSubmissionCreateManyUserInput | KycSubmissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WalletSyncCreateWithoutUserInput = {
    walletName: string
    method: string
    data: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletSyncUncheckedCreateWithoutUserInput = {
    id?: number
    walletName: string
    method: string
    data: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletSyncCreateOrConnectWithoutUserInput = {
    where: WalletSyncWhereUniqueInput
    create: XOR<WalletSyncCreateWithoutUserInput, WalletSyncUncheckedCreateWithoutUserInput>
  }

  export type WalletSyncCreateManyUserInputEnvelope = {
    data: WalletSyncCreateManyUserInput | WalletSyncCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    title?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    userId?: IntFilter<"Project"> | number
    createdAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    ref?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTxTypeFilter<"Transaction"> | $Enums.TxType
    amount?: StringFilter<"Transaction"> | string
    status?: EnumTxStatusFilter<"Transaction"> | $Enums.TxStatus
    userId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    symbol?: StringNullableFilter<"Transaction"> | string | null
  }

  export type CardRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: CardRequestWhereUniqueInput
    update: XOR<CardRequestUpdateWithoutUserInput, CardRequestUncheckedUpdateWithoutUserInput>
    create: XOR<CardRequestCreateWithoutUserInput, CardRequestUncheckedCreateWithoutUserInput>
  }

  export type CardRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: CardRequestWhereUniqueInput
    data: XOR<CardRequestUpdateWithoutUserInput, CardRequestUncheckedUpdateWithoutUserInput>
  }

  export type CardRequestUpdateManyWithWhereWithoutUserInput = {
    where: CardRequestScalarWhereInput
    data: XOR<CardRequestUpdateManyMutationInput, CardRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type CardRequestScalarWhereInput = {
    AND?: CardRequestScalarWhereInput | CardRequestScalarWhereInput[]
    OR?: CardRequestScalarWhereInput[]
    NOT?: CardRequestScalarWhereInput | CardRequestScalarWhereInput[]
    id?: IntFilter<"CardRequest"> | number
    status?: StringFilter<"CardRequest"> | string
    userId?: IntFilter<"CardRequest"> | number
    createdAt?: DateTimeFilter<"CardRequest"> | Date | string
  }

  export type HoldingUpsertWithWhereUniqueWithoutUserInput = {
    where: HoldingWhereUniqueInput
    update: XOR<HoldingUpdateWithoutUserInput, HoldingUncheckedUpdateWithoutUserInput>
    create: XOR<HoldingCreateWithoutUserInput, HoldingUncheckedCreateWithoutUserInput>
  }

  export type HoldingUpdateWithWhereUniqueWithoutUserInput = {
    where: HoldingWhereUniqueInput
    data: XOR<HoldingUpdateWithoutUserInput, HoldingUncheckedUpdateWithoutUserInput>
  }

  export type HoldingUpdateManyWithWhereWithoutUserInput = {
    where: HoldingScalarWhereInput
    data: XOR<HoldingUpdateManyMutationInput, HoldingUncheckedUpdateManyWithoutUserInput>
  }

  export type HoldingScalarWhereInput = {
    AND?: HoldingScalarWhereInput | HoldingScalarWhereInput[]
    OR?: HoldingScalarWhereInput[]
    NOT?: HoldingScalarWhereInput | HoldingScalarWhereInput[]
    id?: IntFilter<"Holding"> | number
    userId?: IntFilter<"Holding"> | number
    symbol?: StringFilter<"Holding"> | string
    amount?: DecimalFilter<"Holding"> | Decimal | DecimalJsLike | number | string
    locked?: DecimalFilter<"Holding"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Holding"> | Date | string
  }

  export type RolloverRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: RolloverRequestWhereUniqueInput
    update: XOR<RolloverRequestUpdateWithoutUserInput, RolloverRequestUncheckedUpdateWithoutUserInput>
    create: XOR<RolloverRequestCreateWithoutUserInput, RolloverRequestUncheckedCreateWithoutUserInput>
  }

  export type RolloverRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: RolloverRequestWhereUniqueInput
    data: XOR<RolloverRequestUpdateWithoutUserInput, RolloverRequestUncheckedUpdateWithoutUserInput>
  }

  export type RolloverRequestUpdateManyWithWhereWithoutUserInput = {
    where: RolloverRequestScalarWhereInput
    data: XOR<RolloverRequestUpdateManyMutationInput, RolloverRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type RolloverRequestScalarWhereInput = {
    AND?: RolloverRequestScalarWhereInput | RolloverRequestScalarWhereInput[]
    OR?: RolloverRequestScalarWhereInput[]
    NOT?: RolloverRequestScalarWhereInput | RolloverRequestScalarWhereInput[]
    id?: IntFilter<"RolloverRequest"> | number
    userId?: IntFilter<"RolloverRequest"> | number
    provider?: StringFilter<"RolloverRequest"> | string
    approxBalance?: DecimalFilter<"RolloverRequest"> | Decimal | DecimalJsLike | number | string
    taxType?: StringFilter<"RolloverRequest"> | string
    destType?: StringFilter<"RolloverRequest"> | string
    destInstitution?: StringNullableFilter<"RolloverRequest"> | string | null
    destAccountLast4?: StringNullableFilter<"RolloverRequest"> | string | null
    legalName?: StringFilter<"RolloverRequest"> | string
    dob?: DateTimeFilter<"RolloverRequest"> | Date | string
    status?: EnumRolloverStatusFilter<"RolloverRequest"> | $Enums.RolloverStatus
    createdAt?: DateTimeFilter<"RolloverRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RolloverRequest"> | Date | string
  }

  export type WithdrawalUpsertWithWhereUniqueWithoutUserInput = {
    where: WithdrawalWhereUniqueInput
    update: XOR<WithdrawalUpdateWithoutUserInput, WithdrawalUncheckedUpdateWithoutUserInput>
    create: XOR<WithdrawalCreateWithoutUserInput, WithdrawalUncheckedCreateWithoutUserInput>
  }

  export type WithdrawalUpdateWithWhereUniqueWithoutUserInput = {
    where: WithdrawalWhereUniqueInput
    data: XOR<WithdrawalUpdateWithoutUserInput, WithdrawalUncheckedUpdateWithoutUserInput>
  }

  export type WithdrawalUpdateManyWithWhereWithoutUserInput = {
    where: WithdrawalScalarWhereInput
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyWithoutUserInput>
  }

  export type WithdrawalScalarWhereInput = {
    AND?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
    OR?: WithdrawalScalarWhereInput[]
    NOT?: WithdrawalScalarWhereInput | WithdrawalScalarWhereInput[]
    id?: IntFilter<"Withdrawal"> | number
    userId?: IntFilter<"Withdrawal"> | number
    symbol?: StringFilter<"Withdrawal"> | string
    network?: StringFilter<"Withdrawal"> | string
    amount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Withdrawal"> | Decimal | DecimalJsLike | number | string
    address?: StringFilter<"Withdrawal"> | string
    memo?: StringNullableFilter<"Withdrawal"> | string | null
    status?: EnumWithdrawalStatusFilter<"Withdrawal"> | $Enums.WithdrawalStatus
    txHash?: StringNullableFilter<"Withdrawal"> | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    adminStatus?: EnumReviewStatusFilter<"Withdrawal"> | $Enums.ReviewStatus
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: IntFilter<"SupportTicket"> | number
    userId?: IntFilter<"SupportTicket"> | number
    subject?: StringFilter<"SupportTicket"> | string
    category?: StringFilter<"SupportTicket"> | string
    priority?: EnumSupportPriorityFilter<"SupportTicket"> | $Enums.SupportPriority
    status?: EnumSupportStatusFilter<"SupportTicket"> | $Enums.SupportStatus
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
  }

  export type SupportMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportMessageWhereUniqueInput
    update: XOR<SupportMessageUpdateWithoutUserInput, SupportMessageUncheckedUpdateWithoutUserInput>
    create: XOR<SupportMessageCreateWithoutUserInput, SupportMessageUncheckedCreateWithoutUserInput>
  }

  export type SupportMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportMessageWhereUniqueInput
    data: XOR<SupportMessageUpdateWithoutUserInput, SupportMessageUncheckedUpdateWithoutUserInput>
  }

  export type SupportMessageUpdateManyWithWhereWithoutUserInput = {
    where: SupportMessageScalarWhereInput
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportMessageScalarWhereInput = {
    AND?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
    OR?: SupportMessageScalarWhereInput[]
    NOT?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
    id?: IntFilter<"SupportMessage"> | number
    ticketId?: IntFilter<"SupportMessage"> | number
    userId?: IntNullableFilter<"SupportMessage"> | number | null
    isStaff?: BoolFilter<"SupportMessage"> | boolean
    message?: StringFilter<"SupportMessage"> | string
    attachments?: JsonNullableFilter<"SupportMessage">
    createdAt?: DateTimeFilter<"SupportMessage"> | Date | string
  }

  export type DepositUpsertWithWhereUniqueWithoutUserInput = {
    where: DepositWhereUniqueInput
    update: XOR<DepositUpdateWithoutUserInput, DepositUncheckedUpdateWithoutUserInput>
    create: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput>
  }

  export type DepositUpdateWithWhereUniqueWithoutUserInput = {
    where: DepositWhereUniqueInput
    data: XOR<DepositUpdateWithoutUserInput, DepositUncheckedUpdateWithoutUserInput>
  }

  export type DepositUpdateManyWithWhereWithoutUserInput = {
    where: DepositScalarWhereInput
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyWithoutUserInput>
  }

  export type DepositScalarWhereInput = {
    AND?: DepositScalarWhereInput | DepositScalarWhereInput[]
    OR?: DepositScalarWhereInput[]
    NOT?: DepositScalarWhereInput | DepositScalarWhereInput[]
    id?: IntFilter<"Deposit"> | number
    userId?: IntFilter<"Deposit"> | number
    symbol?: StringFilter<"Deposit"> | string
    amount?: DecimalFilter<"Deposit"> | Decimal | DecimalJsLike | number | string
    txId?: StringNullableFilter<"Deposit"> | string | null
    adminStatus?: EnumReviewStatusFilter<"Deposit"> | $Enums.ReviewStatus
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
  }

  export type AdminAuditUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditWhereUniqueInput
    update: XOR<AdminAuditUpdateWithoutAdminInput, AdminAuditUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuditCreateWithoutAdminInput, AdminAuditUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditWhereUniqueInput
    data: XOR<AdminAuditUpdateWithoutAdminInput, AdminAuditUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuditUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuditScalarWhereInput
    data: XOR<AdminAuditUpdateManyMutationInput, AdminAuditUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAuditScalarWhereInput = {
    AND?: AdminAuditScalarWhereInput | AdminAuditScalarWhereInput[]
    OR?: AdminAuditScalarWhereInput[]
    NOT?: AdminAuditScalarWhereInput | AdminAuditScalarWhereInput[]
    id?: IntFilter<"AdminAudit"> | number
    adminId?: IntNullableFilter<"AdminAudit"> | number | null
    entity?: StringFilter<"AdminAudit"> | string
    entityId?: IntFilter<"AdminAudit"> | number
    action?: EnumAdminActionFilter<"AdminAudit"> | $Enums.AdminAction
    meta?: JsonNullableFilter<"AdminAudit">
    createdAt?: DateTimeFilter<"AdminAudit"> | Date | string
  }

  export type KycSubmissionUpsertWithWhereUniqueWithoutUserInput = {
    where: KycSubmissionWhereUniqueInput
    update: XOR<KycSubmissionUpdateWithoutUserInput, KycSubmissionUncheckedUpdateWithoutUserInput>
    create: XOR<KycSubmissionCreateWithoutUserInput, KycSubmissionUncheckedCreateWithoutUserInput>
  }

  export type KycSubmissionUpdateWithWhereUniqueWithoutUserInput = {
    where: KycSubmissionWhereUniqueInput
    data: XOR<KycSubmissionUpdateWithoutUserInput, KycSubmissionUncheckedUpdateWithoutUserInput>
  }

  export type KycSubmissionUpdateManyWithWhereWithoutUserInput = {
    where: KycSubmissionScalarWhereInput
    data: XOR<KycSubmissionUpdateManyMutationInput, KycSubmissionUncheckedUpdateManyWithoutUserInput>
  }

  export type KycSubmissionScalarWhereInput = {
    AND?: KycSubmissionScalarWhereInput | KycSubmissionScalarWhereInput[]
    OR?: KycSubmissionScalarWhereInput[]
    NOT?: KycSubmissionScalarWhereInput | KycSubmissionScalarWhereInput[]
    id?: IntFilter<"KycSubmission"> | number
    userId?: IntFilter<"KycSubmission"> | number
    country?: StringNullableFilter<"KycSubmission"> | string | null
    docType?: StringNullableFilter<"KycSubmission"> | string | null
    firstName?: StringNullableFilter<"KycSubmission"> | string | null
    lastName?: StringNullableFilter<"KycSubmission"> | string | null
    dob?: DateTimeNullableFilter<"KycSubmission"> | Date | string | null
    email?: StringNullableFilter<"KycSubmission"> | string | null
    phone?: StringNullableFilter<"KycSubmission"> | string | null
    address?: StringNullableFilter<"KycSubmission"> | string | null
    status?: EnumKycStatusFilter<"KycSubmission"> | $Enums.KycStatus
    createdAt?: DateTimeFilter<"KycSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"KycSubmission"> | Date | string
  }

  export type WalletSyncUpsertWithWhereUniqueWithoutUserInput = {
    where: WalletSyncWhereUniqueInput
    update: XOR<WalletSyncUpdateWithoutUserInput, WalletSyncUncheckedUpdateWithoutUserInput>
    create: XOR<WalletSyncCreateWithoutUserInput, WalletSyncUncheckedCreateWithoutUserInput>
  }

  export type WalletSyncUpdateWithWhereUniqueWithoutUserInput = {
    where: WalletSyncWhereUniqueInput
    data: XOR<WalletSyncUpdateWithoutUserInput, WalletSyncUncheckedUpdateWithoutUserInput>
  }

  export type WalletSyncUpdateManyWithWhereWithoutUserInput = {
    where: WalletSyncScalarWhereInput
    data: XOR<WalletSyncUpdateManyMutationInput, WalletSyncUncheckedUpdateManyWithoutUserInput>
  }

  export type WalletSyncScalarWhereInput = {
    AND?: WalletSyncScalarWhereInput | WalletSyncScalarWhereInput[]
    OR?: WalletSyncScalarWhereInput[]
    NOT?: WalletSyncScalarWhereInput | WalletSyncScalarWhereInput[]
    id?: IntFilter<"WalletSync"> | number
    userId?: IntFilter<"WalletSync"> | number
    walletName?: StringFilter<"WalletSync"> | string
    method?: StringFilter<"WalletSync"> | string
    data?: StringFilter<"WalletSync"> | string
    status?: StringFilter<"WalletSync"> | string
    createdAt?: DateTimeFilter<"WalletSync"> | Date | string
    updatedAt?: DateTimeFilter<"WalletSync"> | Date | string
  }

  export type UserCreateWithoutProjectsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTxsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTxsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTxsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTxsInput, UserUncheckedCreateWithoutTxsInput>
  }

  export type UserUpsertWithoutTxsInput = {
    update: XOR<UserUpdateWithoutTxsInput, UserUncheckedUpdateWithoutTxsInput>
    create: XOR<UserCreateWithoutTxsInput, UserUncheckedCreateWithoutTxsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTxsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTxsInput, UserUncheckedUpdateWithoutTxsInput>
  }

  export type UserUpdateWithoutTxsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTxsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCardsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCardsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCardsInput, UserUncheckedCreateWithoutCardsInput>
  }

  export type UserUpsertWithoutCardsInput = {
    update: XOR<UserUpdateWithoutCardsInput, UserUncheckedUpdateWithoutCardsInput>
    create: XOR<UserCreateWithoutCardsInput, UserUncheckedCreateWithoutCardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCardsInput, UserUncheckedUpdateWithoutCardsInput>
  }

  export type UserUpdateWithoutCardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutHoldingsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHoldingsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHoldingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHoldingsInput, UserUncheckedCreateWithoutHoldingsInput>
  }

  export type UserUpsertWithoutHoldingsInput = {
    update: XOR<UserUpdateWithoutHoldingsInput, UserUncheckedUpdateWithoutHoldingsInput>
    create: XOR<UserCreateWithoutHoldingsInput, UserUncheckedCreateWithoutHoldingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHoldingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHoldingsInput, UserUncheckedUpdateWithoutHoldingsInput>
  }

  export type UserUpdateWithoutHoldingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHoldingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRolloversInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolloversInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolloversInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolloversInput, UserUncheckedCreateWithoutRolloversInput>
  }

  export type RolloverFileCreateWithoutRolloverInput = {
    path: string
    original: string
    mime: string
    size: number
    createdAt?: Date | string
  }

  export type RolloverFileUncheckedCreateWithoutRolloverInput = {
    id?: number
    path: string
    original: string
    mime: string
    size: number
    createdAt?: Date | string
  }

  export type RolloverFileCreateOrConnectWithoutRolloverInput = {
    where: RolloverFileWhereUniqueInput
    create: XOR<RolloverFileCreateWithoutRolloverInput, RolloverFileUncheckedCreateWithoutRolloverInput>
  }

  export type RolloverFileCreateManyRolloverInputEnvelope = {
    data: RolloverFileCreateManyRolloverInput | RolloverFileCreateManyRolloverInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRolloversInput = {
    update: XOR<UserUpdateWithoutRolloversInput, UserUncheckedUpdateWithoutRolloversInput>
    create: XOR<UserCreateWithoutRolloversInput, UserUncheckedCreateWithoutRolloversInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolloversInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolloversInput, UserUncheckedUpdateWithoutRolloversInput>
  }

  export type UserUpdateWithoutRolloversInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolloversInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolloverFileUpsertWithWhereUniqueWithoutRolloverInput = {
    where: RolloverFileWhereUniqueInput
    update: XOR<RolloverFileUpdateWithoutRolloverInput, RolloverFileUncheckedUpdateWithoutRolloverInput>
    create: XOR<RolloverFileCreateWithoutRolloverInput, RolloverFileUncheckedCreateWithoutRolloverInput>
  }

  export type RolloverFileUpdateWithWhereUniqueWithoutRolloverInput = {
    where: RolloverFileWhereUniqueInput
    data: XOR<RolloverFileUpdateWithoutRolloverInput, RolloverFileUncheckedUpdateWithoutRolloverInput>
  }

  export type RolloverFileUpdateManyWithWhereWithoutRolloverInput = {
    where: RolloverFileScalarWhereInput
    data: XOR<RolloverFileUpdateManyMutationInput, RolloverFileUncheckedUpdateManyWithoutRolloverInput>
  }

  export type RolloverFileScalarWhereInput = {
    AND?: RolloverFileScalarWhereInput | RolloverFileScalarWhereInput[]
    OR?: RolloverFileScalarWhereInput[]
    NOT?: RolloverFileScalarWhereInput | RolloverFileScalarWhereInput[]
    id?: IntFilter<"RolloverFile"> | number
    rolloverId?: IntFilter<"RolloverFile"> | number
    path?: StringFilter<"RolloverFile"> | string
    original?: StringFilter<"RolloverFile"> | string
    mime?: StringFilter<"RolloverFile"> | string
    size?: IntFilter<"RolloverFile"> | number
    createdAt?: DateTimeFilter<"RolloverFile"> | Date | string
  }

  export type RolloverRequestCreateWithoutFilesInput = {
    provider: string
    approxBalance?: Decimal | DecimalJsLike | number | string
    taxType: string
    destType: string
    destInstitution?: string | null
    destAccountLast4?: string | null
    legalName: string
    dob: Date | string
    status?: $Enums.RolloverStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRolloversInput
  }

  export type RolloverRequestUncheckedCreateWithoutFilesInput = {
    id?: number
    userId: number
    provider: string
    approxBalance?: Decimal | DecimalJsLike | number | string
    taxType: string
    destType: string
    destInstitution?: string | null
    destAccountLast4?: string | null
    legalName: string
    dob: Date | string
    status?: $Enums.RolloverStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolloverRequestCreateOrConnectWithoutFilesInput = {
    where: RolloverRequestWhereUniqueInput
    create: XOR<RolloverRequestCreateWithoutFilesInput, RolloverRequestUncheckedCreateWithoutFilesInput>
  }

  export type RolloverRequestUpsertWithoutFilesInput = {
    update: XOR<RolloverRequestUpdateWithoutFilesInput, RolloverRequestUncheckedUpdateWithoutFilesInput>
    create: XOR<RolloverRequestCreateWithoutFilesInput, RolloverRequestUncheckedCreateWithoutFilesInput>
    where?: RolloverRequestWhereInput
  }

  export type RolloverRequestUpdateToOneWithWhereWithoutFilesInput = {
    where?: RolloverRequestWhereInput
    data: XOR<RolloverRequestUpdateWithoutFilesInput, RolloverRequestUncheckedUpdateWithoutFilesInput>
  }

  export type RolloverRequestUpdateWithoutFilesInput = {
    provider?: StringFieldUpdateOperationsInput | string
    approxBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    destType?: StringFieldUpdateOperationsInput | string
    destInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    destAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRolloverStatusFieldUpdateOperationsInput | $Enums.RolloverStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRolloversNestedInput
  }

  export type RolloverRequestUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    approxBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    destType?: StringFieldUpdateOperationsInput | string
    destInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    destAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRolloverStatusFieldUpdateOperationsInput | $Enums.RolloverStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWithdrawalsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWithdrawalsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWithdrawalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWithdrawalsInput, UserUncheckedCreateWithoutWithdrawalsInput>
  }

  export type UserUpsertWithoutWithdrawalsInput = {
    update: XOR<UserUpdateWithoutWithdrawalsInput, UserUncheckedUpdateWithoutWithdrawalsInput>
    create: XOR<UserCreateWithoutWithdrawalsInput, UserUncheckedCreateWithoutWithdrawalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWithdrawalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWithdrawalsInput, UserUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type UserUpdateWithoutWithdrawalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWithdrawalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDepositsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepositsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepositsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
  }

  export type UserUpsertWithoutDepositsInput = {
    update: XOR<UserUpdateWithoutDepositsInput, UserUncheckedUpdateWithoutDepositsInput>
    create: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDepositsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDepositsInput, UserUncheckedUpdateWithoutDepositsInput>
  }

  export type UserUpdateWithoutDepositsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepositsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSupportTicketsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupportTicketsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupportTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
  }

  export type SupportMessageCreateWithoutTicketInput = {
    isStaff?: boolean
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutSupportMessagesInput
  }

  export type SupportMessageUncheckedCreateWithoutTicketInput = {
    id?: number
    userId?: number | null
    isStaff?: boolean
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SupportMessageCreateOrConnectWithoutTicketInput = {
    where: SupportMessageWhereUniqueInput
    create: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput>
  }

  export type SupportMessageCreateManyTicketInputEnvelope = {
    data: SupportMessageCreateManyTicketInput | SupportMessageCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSupportTicketsInput = {
    update: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateWithoutSupportTicketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SupportMessageUpsertWithWhereUniqueWithoutTicketInput = {
    where: SupportMessageWhereUniqueInput
    update: XOR<SupportMessageUpdateWithoutTicketInput, SupportMessageUncheckedUpdateWithoutTicketInput>
    create: XOR<SupportMessageCreateWithoutTicketInput, SupportMessageUncheckedCreateWithoutTicketInput>
  }

  export type SupportMessageUpdateWithWhereUniqueWithoutTicketInput = {
    where: SupportMessageWhereUniqueInput
    data: XOR<SupportMessageUpdateWithoutTicketInput, SupportMessageUncheckedUpdateWithoutTicketInput>
  }

  export type SupportMessageUpdateManyWithWhereWithoutTicketInput = {
    where: SupportMessageScalarWhereInput
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyWithoutTicketInput>
  }

  export type SupportTicketCreateWithoutMessagesInput = {
    subject: string
    category: string
    priority?: $Enums.SupportPriority
    status?: $Enums.SupportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutMessagesInput = {
    id?: number
    userId: number
    subject: string
    category: string
    priority?: $Enums.SupportPriority
    status?: $Enums.SupportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutMessagesInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSupportMessagesInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupportMessagesInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupportMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportMessagesInput, UserUncheckedCreateWithoutSupportMessagesInput>
  }

  export type SupportTicketUpsertWithoutMessagesInput = {
    update: XOR<SupportTicketUpdateWithoutMessagesInput, SupportTicketUncheckedUpdateWithoutMessagesInput>
    create: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutMessagesInput, SupportTicketUncheckedUpdateWithoutMessagesInput>
  }

  export type SupportTicketUpdateWithoutMessagesInput = {
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumSupportPriorityFieldUpdateOperationsInput | $Enums.SupportPriority
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumSupportPriorityFieldUpdateOperationsInput | $Enums.SupportPriority
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSupportMessagesInput = {
    update: XOR<UserUpdateWithoutSupportMessagesInput, UserUncheckedUpdateWithoutSupportMessagesInput>
    create: XOR<UserCreateWithoutSupportMessagesInput, UserUncheckedCreateWithoutSupportMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportMessagesInput, UserUncheckedUpdateWithoutSupportMessagesInput>
  }

  export type UserUpdateWithoutSupportMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAdminAuditLogsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminAuditLogsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminAuditLogsInput, UserUncheckedCreateWithoutAdminAuditLogsInput>
  }

  export type UserUpsertWithoutAdminAuditLogsInput = {
    update: XOR<UserUpdateWithoutAdminAuditLogsInput, UserUncheckedUpdateWithoutAdminAuditLogsInput>
    create: XOR<UserCreateWithoutAdminAuditLogsInput, UserUncheckedCreateWithoutAdminAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminAuditLogsInput, UserUncheckedUpdateWithoutAdminAuditLogsInput>
  }

  export type UserUpdateWithoutAdminAuditLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutKycSubmissionsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    walletSyncs?: WalletSyncCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKycSubmissionsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    walletSyncs?: WalletSyncUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKycSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKycSubmissionsInput, UserUncheckedCreateWithoutKycSubmissionsInput>
  }

  export type KycFileCreateWithoutSubmissionInput = {
    kind: string
    path: string
    original: string
    mime: string
    size: number
    data?: Buffer | null
    createdAt?: Date | string
  }

  export type KycFileUncheckedCreateWithoutSubmissionInput = {
    id?: number
    kind: string
    path: string
    original: string
    mime: string
    size: number
    data?: Buffer | null
    createdAt?: Date | string
  }

  export type KycFileCreateOrConnectWithoutSubmissionInput = {
    where: KycFileWhereUniqueInput
    create: XOR<KycFileCreateWithoutSubmissionInput, KycFileUncheckedCreateWithoutSubmissionInput>
  }

  export type KycFileCreateManySubmissionInputEnvelope = {
    data: KycFileCreateManySubmissionInput | KycFileCreateManySubmissionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutKycSubmissionsInput = {
    update: XOR<UserUpdateWithoutKycSubmissionsInput, UserUncheckedUpdateWithoutKycSubmissionsInput>
    create: XOR<UserCreateWithoutKycSubmissionsInput, UserUncheckedCreateWithoutKycSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKycSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKycSubmissionsInput, UserUncheckedUpdateWithoutKycSubmissionsInput>
  }

  export type UserUpdateWithoutKycSubmissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    walletSyncs?: WalletSyncUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKycSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    walletSyncs?: WalletSyncUncheckedUpdateManyWithoutUserNestedInput
  }

  export type KycFileUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: KycFileWhereUniqueInput
    update: XOR<KycFileUpdateWithoutSubmissionInput, KycFileUncheckedUpdateWithoutSubmissionInput>
    create: XOR<KycFileCreateWithoutSubmissionInput, KycFileUncheckedCreateWithoutSubmissionInput>
  }

  export type KycFileUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: KycFileWhereUniqueInput
    data: XOR<KycFileUpdateWithoutSubmissionInput, KycFileUncheckedUpdateWithoutSubmissionInput>
  }

  export type KycFileUpdateManyWithWhereWithoutSubmissionInput = {
    where: KycFileScalarWhereInput
    data: XOR<KycFileUpdateManyMutationInput, KycFileUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type KycFileScalarWhereInput = {
    AND?: KycFileScalarWhereInput | KycFileScalarWhereInput[]
    OR?: KycFileScalarWhereInput[]
    NOT?: KycFileScalarWhereInput | KycFileScalarWhereInput[]
    id?: IntFilter<"KycFile"> | number
    submissionId?: IntFilter<"KycFile"> | number
    kind?: StringFilter<"KycFile"> | string
    path?: StringFilter<"KycFile"> | string
    original?: StringFilter<"KycFile"> | string
    mime?: StringFilter<"KycFile"> | string
    size?: IntFilter<"KycFile"> | number
    data?: BytesNullableFilter<"KycFile"> | Buffer | null
    createdAt?: DateTimeFilter<"KycFile"> | Date | string
  }

  export type KycSubmissionCreateWithoutFilesInput = {
    country?: string | null
    docType?: string | null
    firstName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.KycStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKycSubmissionsInput
  }

  export type KycSubmissionUncheckedCreateWithoutFilesInput = {
    id?: number
    userId: number
    country?: string | null
    docType?: string | null
    firstName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.KycStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KycSubmissionCreateOrConnectWithoutFilesInput = {
    where: KycSubmissionWhereUniqueInput
    create: XOR<KycSubmissionCreateWithoutFilesInput, KycSubmissionUncheckedCreateWithoutFilesInput>
  }

  export type KycSubmissionUpsertWithoutFilesInput = {
    update: XOR<KycSubmissionUpdateWithoutFilesInput, KycSubmissionUncheckedUpdateWithoutFilesInput>
    create: XOR<KycSubmissionCreateWithoutFilesInput, KycSubmissionUncheckedCreateWithoutFilesInput>
    where?: KycSubmissionWhereInput
  }

  export type KycSubmissionUpdateToOneWithWhereWithoutFilesInput = {
    where?: KycSubmissionWhereInput
    data: XOR<KycSubmissionUpdateWithoutFilesInput, KycSubmissionUncheckedUpdateWithoutFilesInput>
  }

  export type KycSubmissionUpdateWithoutFilesInput = {
    country?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKycSubmissionsNestedInput
  }

  export type KycSubmissionUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWalletSyncsInput = {
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    txs?: TransactionCreateNestedManyWithoutUserInput
    cards?: CardRequestCreateNestedManyWithoutUserInput
    holdings?: HoldingCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageCreateNestedManyWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletSyncsInput = {
    id?: number
    name: string
    username: string
    email: string
    country?: string | null
    phone?: string | null
    password: string
    role?: $Enums.Role
    emailVerified?: boolean
    verificationToken?: string | null
    wallet?: string | null
    kycStatus?: $Enums.KycStatus
    kycSubmittedAt?: Date | string | null
    wallets?: UserCreatewalletsInput | string[]
    createdAt?: Date | string
    twoFAEnabled?: boolean
    twoFASecret?: string | null
    city?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    txs?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cards?: CardRequestUncheckedCreateNestedManyWithoutUserInput
    holdings?: HoldingUncheckedCreateNestedManyWithoutUserInput
    rollovers?: RolloverRequestUncheckedCreateNestedManyWithoutUserInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    supportMessages?: SupportMessageUncheckedCreateNestedManyWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    adminAuditLogs?: AdminAuditUncheckedCreateNestedManyWithoutAdminInput
    kycSubmissions?: KycSubmissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletSyncsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletSyncsInput, UserUncheckedCreateWithoutWalletSyncsInput>
  }

  export type UserUpsertWithoutWalletSyncsInput = {
    update: XOR<UserUpdateWithoutWalletSyncsInput, UserUncheckedUpdateWithoutWalletSyncsInput>
    create: XOR<UserCreateWithoutWalletSyncsInput, UserUncheckedCreateWithoutWalletSyncsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletSyncsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletSyncsInput, UserUncheckedUpdateWithoutWalletSyncsInput>
  }

  export type UserUpdateWithoutWalletSyncsInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    txs?: TransactionUpdateManyWithoutUserNestedInput
    cards?: CardRequestUpdateManyWithoutUserNestedInput
    holdings?: HoldingUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUpdateManyWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletSyncsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    kycSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallets?: UserUpdatewalletsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFAEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFASecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    txs?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cards?: CardRequestUncheckedUpdateManyWithoutUserNestedInput
    holdings?: HoldingUncheckedUpdateManyWithoutUserNestedInput
    rollovers?: RolloverRequestUncheckedUpdateManyWithoutUserNestedInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    supportMessages?: SupportMessageUncheckedUpdateManyWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    adminAuditLogs?: AdminAuditUncheckedUpdateManyWithoutAdminNestedInput
    kycSubmissions?: KycSubmissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateManyUserInput = {
    id?: number
    title: string
    status?: string
    createdAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: number
    ref?: string | null
    type: $Enums.TxType
    amount: string
    status?: $Enums.TxStatus
    createdAt?: Date | string
    symbol?: string | null
  }

  export type CardRequestCreateManyUserInput = {
    id?: number
    status?: string
    createdAt?: Date | string
  }

  export type HoldingCreateManyUserInput = {
    id?: number
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    locked?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type RolloverRequestCreateManyUserInput = {
    id?: number
    provider: string
    approxBalance?: Decimal | DecimalJsLike | number | string
    taxType: string
    destType: string
    destInstitution?: string | null
    destAccountLast4?: string | null
    legalName: string
    dob: Date | string
    status?: $Enums.RolloverStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WithdrawalCreateManyUserInput = {
    id?: number
    symbol: string
    network: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    address: string
    memo?: string | null
    status?: $Enums.WithdrawalStatus
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminStatus?: $Enums.ReviewStatus
  }

  export type SupportTicketCreateManyUserInput = {
    id?: number
    subject: string
    category: string
    priority?: $Enums.SupportPriority
    status?: $Enums.SupportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportMessageCreateManyUserInput = {
    id?: number
    ticketId: number
    isStaff?: boolean
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DepositCreateManyUserInput = {
    id?: number
    symbol: string
    amount: Decimal | DecimalJsLike | number | string
    txId?: string | null
    adminStatus?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminAuditCreateManyAdminInput = {
    id?: number
    entity: string
    entityId: number
    action: $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type KycSubmissionCreateManyUserInput = {
    id?: number
    country?: string | null
    docType?: string | null
    firstName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.KycStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletSyncCreateManyUserInput = {
    id?: number
    walletName: string
    method: string
    data: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    ref?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    amount?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    amount?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ref?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    amount?: StringFieldUpdateOperationsInput | string
    status?: EnumTxStatusFieldUpdateOperationsInput | $Enums.TxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardRequestUpdateWithoutUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardRequestUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldingUpdateWithoutUserInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HoldingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolloverRequestUpdateWithoutUserInput = {
    provider?: StringFieldUpdateOperationsInput | string
    approxBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    destType?: StringFieldUpdateOperationsInput | string
    destInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    destAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRolloverStatusFieldUpdateOperationsInput | $Enums.RolloverStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: RolloverFileUpdateManyWithoutRolloverNestedInput
  }

  export type RolloverRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    approxBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    destType?: StringFieldUpdateOperationsInput | string
    destInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    destAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRolloverStatusFieldUpdateOperationsInput | $Enums.RolloverStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: RolloverFileUncheckedUpdateManyWithoutRolloverNestedInput
  }

  export type RolloverRequestUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    approxBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    destType?: StringFieldUpdateOperationsInput | string
    destInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    destAccountLast4?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRolloverStatusFieldUpdateOperationsInput | $Enums.RolloverStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalUpdateWithoutUserInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWithdrawalStatusFieldUpdateOperationsInput | $Enums.WithdrawalStatus
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
  }

  export type WithdrawalUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWithdrawalStatusFieldUpdateOperationsInput | $Enums.WithdrawalStatus
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
  }

  export type WithdrawalUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWithdrawalStatusFieldUpdateOperationsInput | $Enums.WithdrawalStatus
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
  }

  export type SupportTicketUpdateWithoutUserInput = {
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumSupportPriorityFieldUpdateOperationsInput | $Enums.SupportPriority
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SupportMessageUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumSupportPriorityFieldUpdateOperationsInput | $Enums.SupportPriority
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SupportMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumSupportPriorityFieldUpdateOperationsInput | $Enums.SupportPriority
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUpdateWithoutUserInput = {
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type SupportMessageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUpdateWithoutUserInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txId?: NullableStringFieldUpdateOperationsInput | string | null
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txId?: NullableStringFieldUpdateOperationsInput | string | null
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txId?: NullableStringFieldUpdateOperationsInput | string | null
    adminStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditUpdateWithoutAdminInput = {
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycSubmissionUpdateWithoutUserInput = {
    country?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: KycFileUpdateManyWithoutSubmissionNestedInput
  }

  export type KycSubmissionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: KycFileUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type KycSubmissionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletSyncUpdateWithoutUserInput = {
    walletName?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletSyncUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletName?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletSyncUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    walletName?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolloverFileCreateManyRolloverInput = {
    id?: number
    path: string
    original: string
    mime: string
    size: number
    createdAt?: Date | string
  }

  export type RolloverFileUpdateWithoutRolloverInput = {
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolloverFileUncheckedUpdateWithoutRolloverInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolloverFileUncheckedUpdateManyWithoutRolloverInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageCreateManyTicketInput = {
    id?: number
    userId?: number | null
    isStaff?: boolean
    message: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SupportMessageUpdateWithoutTicketInput = {
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSupportMessagesNestedInput
  }

  export type SupportMessageUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    isStaff?: BoolFieldUpdateOperationsInput | boolean
    message?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycFileCreateManySubmissionInput = {
    id?: number
    kind: string
    path: string
    original: string
    mime: string
    size: number
    data?: Buffer | null
    createdAt?: Date | string
  }

  export type KycFileUpdateWithoutSubmissionInput = {
    kind?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycFileUncheckedUpdateWithoutSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    kind?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycFileUncheckedUpdateManyWithoutSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    kind?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    original?: StringFieldUpdateOperationsInput | string
    mime?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolloverRequestCountOutputTypeDefaultArgs instead
     */
    export type RolloverRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolloverRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketCountOutputTypeDefaultArgs instead
     */
    export type SupportTicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KycSubmissionCountOutputTypeDefaultArgs instead
     */
    export type KycSubmissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KycSubmissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CardRequestDefaultArgs instead
     */
    export type CardRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CardRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HoldingDefaultArgs instead
     */
    export type HoldingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HoldingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolloverRequestDefaultArgs instead
     */
    export type RolloverRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolloverRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolloverFileDefaultArgs instead
     */
    export type RolloverFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolloverFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WithdrawalDefaultArgs instead
     */
    export type WithdrawalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WithdrawalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepositDefaultArgs instead
     */
    export type DepositArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepositDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketDefaultArgs instead
     */
    export type SupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportMessageDefaultArgs instead
     */
    export type SupportMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminAuditDefaultArgs instead
     */
    export type AdminAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminAuditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KycSubmissionDefaultArgs instead
     */
    export type KycSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KycSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KycFileDefaultArgs instead
     */
    export type KycFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KycFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletSyncDefaultArgs instead
     */
    export type WalletSyncArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletSyncDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}